<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API · MatrixBandwidth.jl</title><meta name="title" content="Public API · MatrixBandwidth.jl"/><meta property="og:title" content="Public API · MatrixBandwidth.jl"/><meta property="twitter:title" content="Public API · MatrixBandwidth.jl"/><meta name="description" content="Documentation for MatrixBandwidth.jl."/><meta property="og:description" content="Documentation for MatrixBandwidth.jl."/><meta property="twitter:description" content="Documentation for MatrixBandwidth.jl."/><meta property="og:url" content="https://Luis-Varona.github.io/MatrixBandwidth.jl/public_api/"/><meta property="twitter:url" content="https://Luis-Varona.github.io/MatrixBandwidth.jl/public_api/"/><link rel="canonical" href="https://Luis-Varona.github.io/MatrixBandwidth.jl/public_api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="MatrixBandwidth.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">MatrixBandwidth.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>Public API</a><ul class="internal"><li><a class="tocitem" href="#MatrixBandwidth-(Public)"><span><code>MatrixBandwidth</code> (Public)</span></a></li><li><a class="tocitem" href="#MatrixBandwidth.Minimization-(Public)"><span><code>MatrixBandwidth.Minimization</code> (Public)</span></a></li><li><a class="tocitem" href="#MatrixBandwidth.Minimization.Exact-(Public)"><span><code>MatrixBandwidth.Minimization.Exact</code> (Public)</span></a></li><li><a class="tocitem" href="#MatrixBandwidth.Minimization.Heuristic-(Public)"><span><code>MatrixBandwidth.Minimization.Heuristic</code> (Public)</span></a></li><li><a class="tocitem" href="#MatrixBandwidth.Minimization.Metaheuristic-(Public)"><span><code>MatrixBandwidth.Minimization.Metaheuristic</code> (Public)</span></a></li><li><a class="tocitem" href="#MatrixBandwidth.Recognition-(Public)"><span><code>MatrixBandwidth.Recognition</code> (Public)</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../private_api/">Private API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Public API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Luis-Varona/MatrixBandwidth.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/main/docs/src/public_api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-API-Documentation"><a class="docs-heading-anchor" href="#Public-API-Documentation">Public API Documentation</a><a id="Public-API-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API-Documentation" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/Luis-Varona/MatrixBandwidth.jl">MatrixBandwidth</a>&#39;s public API.</p><div class="admonition is-info" id="Note-b1a6c219d931d054"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-b1a6c219d931d054" title="Permalink"></a></header><div class="admonition-body"><p>The following documentation covers only the public API of the package. For internal details, see the <a href="../private_api/">private API documentation</a>.</p></div></div><h2 id="MatrixBandwidth-(Public)"><a class="docs-heading-anchor" href="#MatrixBandwidth-(Public)"><code>MatrixBandwidth</code> (Public)</a><a id="MatrixBandwidth-(Public)-1"></a><a class="docs-heading-anchor-permalink" href="#MatrixBandwidth-(Public)" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MatrixBandwidth.MatrixBandwidth"><a class="docstring-binding" href="#MatrixBandwidth.MatrixBandwidth"><code>MatrixBandwidth.MatrixBandwidth</code></a> — <span class="docstring-category">Module</span></summary><section><div><pre><code class="language-julia hljs">MatrixBandwidth</code></pre><p>Fast algorithms for matrix bandwidth minimization and recognition, written in Julia.</p><p>The <em>bandwidth</em> of an <span>$n×n$</span> matrix <span>$A$</span> is the minimum non-negative integer <span>$k ∈ \{0, 1, …, n - 1\}$</span> such that <span>$A[i, j] = 0$</span> whenever <span>$|i - j| &gt; k$</span>. Reordering the rows and columns of a matrix to reduce its bandwidth has many practical applications in engineering and scientific computing: it can improve performance when solving linear systems, approximating partial differential equations, optimizing circuit layout, and more [Maf14, p. 184]. There are two variants of this problem: <em>minimization</em>, which involves finding a permutation matrix <span>$P$</span> such that the bandwidth of <span>$PAPᵀ$</span> is minimized, and <em>recognition</em>, which entails determining whether there exists a permutation matrix <span>$P$</span> such that the bandwidth of <span>$PAPᵀ$</span> is at most some fixed non-negative integer (an optimal permutation that fully minimizes the bandwidth of <span>$A$</span> is not required).</p><p>Many matrix bandwidth reduction algorithms exist in the literature, but implementations in the open-source ecosystem are scarce, with those that do exist primarily tackling older, less efficient algorithms. The <a href="https://www.boost.org/">Boost</a> libraries in C++, the <a href="https://networkx.org/">NetworkX</a> library in Python, and the MATLAB standard library all only implement the reverse Cuthill–McKee algorithm from 1971. This gap in the ecosystem not only makes it difficult for theoretical researchers to benchmark and compare new proposed algorithms but also precludes the application of the most performant modern algorithms in real-life industry settings. MatrixBandwidth.jl aims to bridge this gap by presenting a unified interface for matrix bandwidth reduction algorithms in Julia, designed with extensibility to further methods in mind.</p><p>The following matrix bandwidth reduction algorithms are currently available:</p><ul><li><strong>Minimization</strong><ul><li><em>Exact</em><ul><li>Del Corso–Manzini (<a href="#MatrixBandwidth.Minimization.Exact.DelCorsoManzini"><code>Minimization.DelCorsoManzini</code></a>)</li><li>Del Corso–Manzini with perimeter search   (<a href="#MatrixBandwidth.Minimization.Exact.DelCorsoManziniWithPS"><code>Minimization.DelCorsoManziniWithPS</code></a>)</li><li>Caprara–Salazar-González (<a href="#MatrixBandwidth.Minimization.Exact.CapraraSalazarGonzalez"><code>Minimization.CapraraSalazarGonzalez</code></a>)</li><li>Saxe–Gurari–Sudborough (<a href="#MatrixBandwidth.Minimization.Exact.SaxeGurariSudborough"><code>Minimization.SaxeGurariSudborough</code></a>)</li><li>Brute-force search (<a href="#MatrixBandwidth.Minimization.Exact.BruteForceSearch"><code>Minimization.BruteForceSearch</code></a>)</li></ul></li><li><em>Heuristic</em><ul><li>Gibbs–Poole–Stockmeyer (<a href="#MatrixBandwidth.Minimization.Heuristic.GibbsPooleStockmeyer"><code>Minimization.GibbsPooleStockmeyer</code></a>)</li><li>Cuthill–McKee (<a href="#MatrixBandwidth.Minimization.Heuristic.CuthillMcKee"><code>Minimization.CuthillMcKee</code></a>)</li><li>Reverse Cuthill–McKee (<a href="#MatrixBandwidth.Minimization.Heuristic.ReverseCuthillMcKee"><code>Minimization.ReverseCuthillMcKee</code></a>)</li></ul></li></ul></li><li><strong>Recognition</strong><ul><li>Del Corso–Manzini (<a href="#MatrixBandwidth.Recognition.DelCorsoManzini"><code>Recognition.DelCorsoManzini</code></a>)</li><li>Del Corso–Manzini with perimeter search (<a href="#MatrixBandwidth.Recognition.DelCorsoManziniWithPS"><code>Recognition.DelCorsoManziniWithPS</code></a>)</li><li>Caprara–Salazar-González (<a href="#MatrixBandwidth.Recognition.CapraraSalazarGonzalez"><code>Recognition.CapraraSalazarGonzalez</code></a>)</li><li>Saxe–Gurari–Sudborough (<a href="#MatrixBandwidth.Recognition.SaxeGurariSudborough"><code>Recognition.SaxeGurariSudborough</code></a>)</li><li>Brute-force search (<a href="#MatrixBandwidth.Recognition.BruteForceSearch"><code>Recognition.BruteForceSearch</code></a>)</li></ul></li></ul><p>Recognition algorithms determine whether any row-and-column permutation of a matrix induces bandwidth less than or equal to some fixed integer. Exact minimization algorithms always guarantee optimal orderings to minimize bandwidth, while heuristic minimization algorithms produce near-optimal solutions more quickly. Metaheuristic minimization algorithms employ iterative search frameworks to find better solutions than heuristic methods (albeit more slowly); no such algorithms are already implemented, but several (e.g., simulated annealing) are currently under development.</p><p>This package also exports several additional core functions, including (but not limited to) <a href="#MatrixBandwidth.bandwidth-Tuple{AbstractMatrix{&lt;:Number}}"><code>bandwidth</code></a> and <a href="#MatrixBandwidth.profile-Tuple{AbstractMatrix{&lt;:Number}}"><code>profile</code></a> to compute the original bandwidth and profile of a matrix prior to any reordering.</p><p>The full documentation is available at <a href="https://luis-varona.github.io/MatrixBandwidth.jl/">GitHub Pages</a>.</p><p><strong>References</strong></p><ul><li>[<a href="#Maf14">Maf14</a>]: L. O. Mafteiu-Scai. <em>The Bandwidths of a Matrix. A Survey of Algorithms</em>.   Annals of West University of Timisoara - Mathematics and Computer Science <strong>52</strong>,   183–223 (2014). https://doi.org/10.2478/awutm-2014-0019.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/MatrixBandwidth.jl#L7-L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.AbstractAlgorithm"><a class="docstring-binding" href="#MatrixBandwidth.AbstractAlgorithm"><code>MatrixBandwidth.AbstractAlgorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractAlgorithm</code></pre><p>Abstract base type for all matrix bandwidth reduction algorithms.</p><p><strong>Interface</strong></p><p>Concrete subtypes of <code>AbstractAlgorithm</code> must implement the following methods:</p><ul><li><code>Base.summary(::T) where {T&lt;:AbstractAlgorithm}</code>: returns a <code>String</code> indicating the name   of the algorithm (e.g., <code>&quot;Gibbs–Poole–Stockmeyer&quot;</code>).</li><li><code>_requires_structural_symmetry(::T) where {T&lt;:AbstractAlgorithm}</code>: returns a <code>Bool</code>   indicating whether the algorithm requires the input matrix to be structurally symmetric.</li></ul><p>Direct subtypes of <code>AbstractAlgorithm</code> must implement the following method:</p><ul><li><code>_problem(::T) where {T&lt;:AbstractAlgorithm}</code>: returns a <code>Symbol</code> indicating the   matrix bandwidth problem tackled by the algorithm (e.g., <code>:minimization</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/types.jl#L7-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.AbstractResult"><a class="docstring-binding" href="#MatrixBandwidth.AbstractResult"><code>MatrixBandwidth.AbstractResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractResult</code></pre><p>Abstract base type for all matrix bandwidth reduction results.</p><p><strong>Interface</strong></p><p>Concrete subtypes of <code>AbstractResult</code> <em>must</em> implement parametric types</p><ul><li><code>A&lt;:AbstractAlgorithm</code>;</li><li><code>M&lt;:AbstractMatrix{&lt;:Number}</code>; and</li><li><code>O&lt;:Union{Nothing,Vector{Int}}</code>,</li></ul><p>alongside the following fields:</p><ul><li><code>algorithm::A</code>: the algorithm used to investigate the bandwidth.</li><li><code>matrix::M</code>: the matrix whose bandwidth is investigated.</li><li><code>ordering::O</code>: the corresponding ordering of the rows and columns, if a relevant one is   found; otherwise, <code>nothing</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/types.jl#L41-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.bandwidth-Tuple{AbstractMatrix{&lt;:Number}}"><a class="docstring-binding" href="#MatrixBandwidth.bandwidth-Tuple{AbstractMatrix{&lt;:Number}}"><code>MatrixBandwidth.bandwidth</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bandwidth(A) -&gt; Int</code></pre><p>Compute the bandwidth of <code>A</code> before any permutation of its rows and columns.</p><p>The <em>bandwidth</em> of an <span>$n×n$</span> matrix <span>$A$</span> is the minimum non-negative integer <span>$k ∈ \{0, 1, …, n - 1\}$</span> such that <span>$A[i, j] = 0$</span> whenever <span>$|i - j| &gt; k$</span>.</p><p>In contrast to <a href="#MatrixBandwidth.Minimization.minimize_bandwidth"><code>minimize_bandwidth</code></a>, this function does not attempt to minimize the bandwidth of <code>A</code> by permuting its rows and columns—it simply computes its bandwidth as is.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractMatrix{&lt;:Number}</code>: the (square) matrix whose bandwidth is computed.</li></ul><p><strong>Returns</strong></p><ul><li><code>::Int</code>: the bandwidth of <code>A</code>.</li></ul><p><strong>Performance</strong></p><p>Given an <span>$n×n$</span> input matrix, this relatively simple algorithm runs in <span>$O(n²)$</span> time.</p><p><strong>Examples</strong></p><p><code>bandwidth</code> correctly identifies the bandwidth of a pentadiagonal matrix as <span>$2$</span> and does not attempt to find a minimizing permutation upon shuffling of its rows and columns:</p><pre><code class="language- hljs">using Random
Random.seed!(242622);
(n, k) = (8, 2);
perm = randperm(n);
A = (!iszero).(MatrixBandwidth.random_banded_matrix(n, k))
bandwidth(A)
A_shuffled = A[perm, perm]
bandwidth(A_shuffled)</code></pre><p><strong>Notes</strong></p><p>Some texts define matrix bandwidth to be the minimum non-negative integer <span>$k$</span> such that <span>$A[i, j] = 0$</span> whenever <span>$|i - j| ≥ k$</span> instead, particularly in more mathematically-minded communities. Effectively, this definition treats diagonal matrices as bandwidth <span>$1$</span>, tridiagonal matrices as bandwidth <span>$2$</span>, and so on. Our definition, on the other hand, is more common in computer science contexts, treating diagonal matrices as bandwidth <span>$0$</span> and tridiagonal matrices as bandwidth <span>$1$</span>. (Both definitions, however, agree that the bandwidth of an empty matrix is simply <span>$0$</span>.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/core.jl#L7-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.bandwidth_lower_bound-Tuple{AbstractMatrix{&lt;:Number}}"><a class="docstring-binding" href="#MatrixBandwidth.bandwidth_lower_bound-Tuple{AbstractMatrix{&lt;:Number}}"><code>MatrixBandwidth.bandwidth_lower_bound</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bandwidth_lower_bound(A) -&gt; Int</code></pre><p>Compute a lower bound on the bandwidth of <code>A</code> using [CS05, pp. 359–60]&#39;s results.</p><p><code>A</code> is assumed to be structurally symmetric, since the bound from [CS05, pp.359–60] was discovered in the context of undirected graphs (whose adjacency matrices are symmetric). Since the original algorithm is defined only for connected graphs, we compute the bound on each connected component of the graph represented by <code>A</code> and return the maximum of these.</p><p>The <em>bandwidth</em> of an <span>$n×n$</span> matrix <span>$A$</span> is the minimum non-negative integer <span>$k ∈ \{0, 1, …, n - 1\}$</span> such that <span>$A[i, j] = 0$</span> whenever <span>$|i - j| &gt; k$</span>.</p><p>In contrast to <a href="#MatrixBandwidth.Minimization.minimize_bandwidth"><code>minimize_bandwidth</code></a>, this function does not attempt to truly minimize the bandwidth of <code>A</code>—it simply returns a lower bound on its bandwidth up to symmetric permutation of its rows and columns. This bound is not generally tight, but it indeed matches the true minimum in many non-trivial cases and is easily computable in <span>$O(n³)$</span> time (dominated by the Floyd–Warshall algorithm call; the core logic itself runs in <span>$O(n²)$</span> time).</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractMatrix{&lt;:Number}</code>: the (square) matrix on whose bandwidth a lower bound is to   be computed. <code>A</code> must be structurally symmetric (i.e., <code>A[i, j]</code> must be nonzero if   and only if <code>A[j, i]</code> is nonzero for <span>$1 ≤ i, j ≤ n$</span>).</li></ul><p><strong>Returns</strong></p><ul><li><code>::Int</code>: a lower bound on the bandwidth of <code>A</code>. (This bound is tight in many non-trivial   cases but not universally so.)</li></ul><p><strong>Examples</strong></p><pre><code class="language- hljs">using Random, SparseArrays, Combinatorics
Random.seed!(21);
(n, p) = (9, 0.4);
A = sprand(n, n, p);
A = A + A&#39; # Ensure structural symmetry;
minimize_bandwidth(A, Minimization.BruteForceSearch())
bandwidth_lower_bound(A) # Always less than or equal to the true minimum bandwidth</code></pre><p><strong>Notes</strong></p><p>Some texts define matrix bandwidth to be the minimum non-negative integer <span>$k$</span> such that <span>$A[i, j] = 0$</span> whenever <span>$|i - j| ≥ k$</span> instead, particularly in more mathematically-minded communities. Effectively, this definition treats diagonal matrices as bandwidth <span>$1$</span>, tridiagonal matrices as bandwidth <span>$2$</span>, and so on. Our definition, on the other hand, is more common in computer science contexts, treating diagonal matrices as bandwidth <span>$0$</span> and tridiagonal matrices as bandwidth <span>$1$</span>. (Both definitions, however, agree that the bandwidth of an empty matrix is simply <span>$0$</span>.)</p><p><strong>References</strong></p><ul><li>[<a href="#CS05">CS05</a>]: A. Caprara and J.-J. Salazar-González. <em>Laying Out Sparse Graphs with   Provably Minimum Bandwidth</em>. INFORMS Journal on Computing <strong>17</strong>, 356–73 (2005).   https://doi.org/10.1287/ijoc.1040.0083.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/core.jl#L163-L216">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.profile-Tuple{AbstractMatrix{&lt;:Number}}"><a class="docstring-binding" href="#MatrixBandwidth.profile-Tuple{AbstractMatrix{&lt;:Number}}"><code>MatrixBandwidth.profile</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">profile(A) -&gt; Int</code></pre><p>Compute the profile of <code>A</code> before any permutation of its rows and columns.</p><p>The <em>profile</em> of a structurally symmetric <span>$n×n$</span> matrix <span>$A$</span> is traditionally defined as the sum of the distances from each diagonal entry to the leftmost nonzero entry in that row—in other words, <span>$∑ᵢ₌₁ⁿ (i - fᵢ)$</span>, where each <span>$fᵢ$</span> is the smallest index such that <span>$A[i, fᵢ] ≠ 0$</span> [Maf14, pp. 187-88]. Generalizing this property to all square matrices, we define the <em>column profile</em> of a matrix to be the sum of the distances from each diagonal entry to the farthest (not necessarily topmost) nonzero entry in that column and the <em>row profile</em> to be the sum of the distances from each diagonal entry to the farthest (not necessarily leftmost) nonzero entry in that row. (Note that both of these properties are equal to traditional matrix profile for structurally symmetric matrices.)</p><p>One of the most common contexts in which matrix profile is relevant is sparse matrix storage, where lower-profile matrices occupy less space in memory [Maf14, p.188]. Since the SparseArrays.jl standard library package defaults to compressed sparse column storage over compressed sparse row, we therefore compute column profile by default unless the dimension is otherwise specified.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractMatrix{&lt;:Number}</code>: the (square) matrix whose profile is computed.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>dim::Symbol=:col</code>: the dimension along which the profile is computed; must be either   <code>:col</code> (the default) or <code>:row</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>::Int</code>: the profile of <code>A</code> along the specified dimension.</li></ul><p><strong>Performance</strong></p><p>Given an <span>$n×n$</span> input matrix, this relatively simple algorithm runs in <span>$O(n²)$</span> time.</p><p><strong>Examples</strong></p><p><code>profile</code> computes the column profile of a matrix by default:</p><pre><code class="language- hljs">using Random, SparseArrays
Random.seed!(2287);
(n, p) = (25, 0.05);
A = sprand(n, n, p)
profile(A)
211</code></pre><p>The dimension (<code>:row</code> or <code>:col</code>) can also be explicitly specified:</p><pre><code class="language- hljs">using Random, SparseArrays
Random.seed!(3647);
(n, p) = (25, 0.05);
A = sprand(n, n, p)
profile(A, dim=:row)
profile(A, dim=:col)</code></pre><p><strong>References</strong></p><ul><li>[<a href="#Maf14">Maf14</a>]: L. O. Mafteiu-Scai. <em>The Bandwidths of a Matrix. A Survey of Algorithms</em>.   Annals of West University of Timisoara - Mathematics and Computer Science <strong>52</strong>,   183–223 (2014). https://doi.org/10.2478/awutm-2014-0019.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/core.jl#L66-L125">source</a></section></details></article><h2 id="MatrixBandwidth.Minimization-(Public)"><a class="docs-heading-anchor" href="#MatrixBandwidth.Minimization-(Public)"><code>MatrixBandwidth.Minimization</code> (Public)</a><a id="MatrixBandwidth.Minimization-(Public)-1"></a><a class="docs-heading-anchor-permalink" href="#MatrixBandwidth.Minimization-(Public)" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Minimization"><a class="docstring-binding" href="#MatrixBandwidth.Minimization"><code>MatrixBandwidth.Minimization</code></a> — <span class="docstring-category">Module</span></summary><section><div><pre><code class="language-julia hljs">MatrixBandwidth.Minimization</code></pre><p>Exact, heuristic, and metaheuristic algorithms for matrix bandwidth minimization in Julia.</p><p>The <em>bandwidth</em> of an <span>$n×n$</span> matrix <span>$A$</span> is the minimum non-negative integer <span>$k ∈ \{0, 1, …, n - 1\}$</span> such that <span>$A[i, j] = 0$</span> whenever <span>$|i - j| &gt; k$</span>. The <em>matrix bandwidth minimization problem</em> involves finding a permutation matrix <span>$P$</span> such that the bandwidth of <span>$PAPᵀ$</span> is minimized.</p><p>The following matrix bandwidth minimization algorithms are currently available:</p><ul><li><em>Exact</em><ul><li>Del Corso–Manzini (<a href="#MatrixBandwidth.Minimization.Exact.DelCorsoManzini"><code>DelCorsoManzini</code></a>)</li><li>Del Corso–Manzini with perimeter search (<a href="#MatrixBandwidth.Minimization.Exact.DelCorsoManziniWithPS"><code>DelCorsoManziniWithPS</code></a>)</li><li>Caprara–Salazar-González (<a href="#MatrixBandwidth.Minimization.Exact.CapraraSalazarGonzalez"><code>CapraraSalazarGonzalez</code></a>)</li><li>Saxe–Gurari–Sudborough (<a href="#MatrixBandwidth.Minimization.Exact.SaxeGurariSudborough"><code>SaxeGurariSudborough</code></a>)</li><li>Brute-force search (<a href="#MatrixBandwidth.Minimization.Exact.BruteForceSearch"><code>BruteForceSearch</code></a>)</li></ul></li><li><em>Heuristic</em><ul><li>Gibbs–Poole–Stockmeyer (<a href="#MatrixBandwidth.Minimization.Heuristic.GibbsPooleStockmeyer"><code>GibbsPooleStockmeyer</code></a>)</li><li>Cuthill–McKee (<a href="#MatrixBandwidth.Minimization.Heuristic.CuthillMcKee"><code>CuthillMcKee</code></a>)</li><li>Reverse Cuthill–McKee (<a href="#MatrixBandwidth.Minimization.Heuristic.ReverseCuthillMcKee"><code>ReverseCuthillMcKee</code></a>)</li></ul></li></ul><p>Exact minimization algorithms always guarantee optimal orderings to minimize bandwidth, while heuristic minimization algorithms produce near-optimal solutions more quickly. Metaheuristic minimization algorithms employ iterative search frameworks to find better solutions than heuristic methods (albeit more slowly); no such algorithms are already implemented, but several (e.g., simulated annealing) are currently under development.</p><p>This submodule is part of the <a href="https://github.com/Luis-Varona/MatrixBandwidth.jl">MatrixBandwidth.jl</a> package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Minimization/Minimization.jl#L7-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Minimization.AbstractSolver"><a class="docstring-binding" href="#MatrixBandwidth.Minimization.AbstractSolver"><code>MatrixBandwidth.Minimization.AbstractSolver</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractSolver &lt;: AbstractAlgorithm</code></pre><p>Abstract base type for all matrix bandwidth minimization solvers.</p><p><strong>Interface</strong></p><p>As per the interface of supertype <a href="#MatrixBandwidth.AbstractAlgorithm"><code>AbstractAlgorithm</code></a>, concrete subtypes of <code>AbstractSolver</code> must implement the following methods:</p><ul><li><code>Base.summary(::T) where {T&lt;:AbstractSolver}</code>: returns a <code>String</code> indicating the name   of the solver (e.g., <code>&quot;Gibbs–Poole–Stockmeyer&quot;</code>).</li><li><code>_requires_structural_symmetry(::T) where {T&lt;:AbstractSolver}</code>: returns a <code>Bool</code>   indicating whether the solver requires the input matrix to be structurally symmetric.</li></ul><p>Direct subtypes of <code>AbstractSolver</code> must implement the following method:</p><ul><li><code>_approach(::T) where {T&lt;:AbstractSolver}</code>: returns a <code>Symbol</code> indicating the   category of solver (e.g., <code>:heuristic</code>).</li></ul><p><strong>Supertype Hierarchy</strong></p><p><code>AbstractSolver</code> &lt;: <a href="#MatrixBandwidth.AbstractAlgorithm"><code>AbstractAlgorithm</code></a></p><p><strong>Notes</strong></p><p>To implement a new matrix bandwidth minimization algorithm, define a new concrete subtype of <code>AbstractSolver</code> (or of one of its abstract subtypes like <a href="#MatrixBandwidth.Minimization.Metaheuristic.MetaheuristicSolver"><code>MetaheuristicSolver</code></a>) then implement a corresponding <code>_minimize_bandwidth_impl(::AbstractMatrix{Bool}, ::NewSolverType)</code> method. Do <em>not</em> attempt to directly implement a new <a href="#MatrixBandwidth.Minimization.minimize_bandwidth"><code>minimize_bandwidth</code></a> method, as the function contains common preprocessing logic independent of the specific algorithm used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Minimization/types.jl#L7-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Minimization.MinimizationResult"><a class="docstring-binding" href="#MatrixBandwidth.Minimization.MinimizationResult"><code>MatrixBandwidth.Minimization.MinimizationResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MinimizationResult{A,M,O} &lt;: AbstractResult</code></pre><p>Output struct for matrix bandwidth minimization results.</p><p><strong>Fields</strong></p><ul><li><code>algorithm::A&lt;:AbstractSolver</code>: the solver used to minimize the bandwidth.</li><li><code>matrix::M&lt;:AbstractMatrix{&lt;:Number}</code>: the original matrix whose bandwidth is minimized.</li><li><code>ordering::O&lt;:Vector{Int}</code>: the (near-)optimal ordering of the rows and columns.</li><li><code>bandwidth::Int</code>: the minimized bandwidth of the matrix.</li><li><code>approach::Symbol</code>: the approach used by the solver. (Should be one of <code>:exact</code>,   <code>:heuristic</code>, and <code>:metaheuristic</code>.)</li></ul><p><strong>Constructors</strong></p><ul><li><code>MinimizationResult(algorithm, matrix, ordering, bandwidth)</code>: constructs a new   <code>MinimizationResult</code> instance with the given fields. The <code>approach</code> field is   automatically determined based on the algorithm type.</li></ul><p><strong>Supertype Hierarchy</strong></p><p><code>MinimizationResult</code> &lt;: <a href="#MatrixBandwidth.AbstractResult"><code>AbstractResult</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Minimization/types.jl#L46-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Minimization.minimize_bandwidth"><a class="docstring-binding" href="#MatrixBandwidth.Minimization.minimize_bandwidth"><code>MatrixBandwidth.Minimization.minimize_bandwidth</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">minimize_bandwidth(A, solver=GibbsPooleStockmeyer()) -&gt; MinimizationResult</code></pre><p>Minimize the bandwidth of <code>A</code> using the algorithm defined by <code>solver</code>.</p><p>The <em>bandwidth</em> of an <span>$n×n$</span> matrix <span>$A$</span> is the minimum non-negative integer <span>$k ∈ \{0, 1, …, n - 1\}$</span> such that <span>$A[i, j] = 0$</span> whenever <span>$|i - j| &gt; k$</span>.</p><p>This function computes a (near-)optimal ordering <span>$π$</span> of the rows and columns of <span>$A$</span> so that the bandwidth of <span>$PAPᵀ$</span> is minimized, where <span>$P$</span> is the permutation matrix corresponding to <span>$π$</span>. This is known to be an NP-complete problem; however, several heuristic algorithms such as Gibbs–Poole–Stockmeyer run in polynomial time while still still producing near-optimal orderings in practice. Exact methods like Caprara–Salazar-González are also available, but they are at least exponential in time complexity and thus only feasible for relatively small matrices.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractMatrix{&lt;:Number}</code>: the (square) matrix whose bandwidth is minimized.</li><li><code>solver::AbstractSolver</code>: the matrix bandwidth minimization algorithm to use; defaults to   <a href="#MatrixBandwidth.Minimization.Heuristic.GibbsPooleStockmeyer"><code>GibbsPooleStockmeyer</code></a>. (See the <a href="#MatrixBandwidth.Minimization"><code>Minimization</code></a> module documentation for   a full list of supported solvers.)</li></ul><p><strong>Returns</strong></p><ul><li><code>::MinimizationResult</code>: a struct containing the algorithm used, the original matrix <code>A</code>,   the (near-)optimal ordering of the rows and columns, and the minimized bandwidth.</li></ul><p><strong>Examples</strong></p><p>Multiple algorithms to minimize the bandwidth of a given matrix are available. In particular, there are exact solvers (which always guarantee optimal solutions), heuristic solvers (which produce near-optimal solutions more quickly than exact methods), and metaheuristic solvers (which employ iterative search frameworks to find better solutions than heuristic methods, but even more slowly).</p><p>Certainly, exact solvers will always produce the same optimal bandwidth (but likely different orderings):</p><pre><code class="language- hljs">using Random, SparseArrays
Random.seed!(38);
(n, p) = (20, 0.05);
A = sprand(n, n, p);
A = A .+ A&#39; # Ensure structural symmetry
res_dcm = minimize_bandwidth(A, Minimization.DelCorsoManzini())
A[res_dcm.ordering, res_dcm.ordering]
res_sgs = minimize_bandwidth(A, Minimization.SaxeGurariSudborough())
A[res_sgs.ordering, res_sgs.ordering]</code></pre><p>However, the answers of (meta)heuristic solvers may differ from each other:</p><pre><code class="language- hljs">using Random, SparseArrays
Random.seed!(405);
(n, p) = (400, 0.002);
A = sprand(n, n, p);
A = A .+ A&#39; # Ensure structural symmetry;
minimize_bandwidth(A, Minimization.GibbsPooleStockmeyer())
minimize_bandwidth(A, Minimization.ReverseCuthillMcKee())</code></pre><p>If no solver is specified, then the heuristic Gibbs–Poole–Stockmeyer algorithm is used by default:</p><pre><code class="language- hljs">using Random, SparseArrays
Random.seed!(80);
(n, p) = (500, 0.001);
A = sprand(n, n, p);
A = A .+ A&#39; # Ensure structural symmetry
res = minimize_bandwidth(A)
A[res.ordering, res.ordering]</code></pre><p><strong>Notes</strong></p><p>To implement a new matrix bandwidth minimization algorithm, define a new concrete subtype of <a href="#MatrixBandwidth.Minimization.AbstractSolver"><code>AbstractSolver</code></a> (or of one of its abstract subtypes like <a href="#MatrixBandwidth.Minimization.Metaheuristic.MetaheuristicSolver"><code>MetaheuristicSolver</code></a>) then implement a corresponding <code>_minimize_bandwidth_impl(::AbstractMatrix{Bool}, ::NewSolverType)</code> method. Do <em>not</em> attempt to directly implement a new <code>minimize_bandwidth</code> method, as the function contains common preprocessing logic independent of the specific algorithm used.</p><p>Note also that some texts define matrix bandwidth to be the minimum non-negative integer <span>$k$</span> such that <span>$A[i, j] = 0$</span> whenever <span>$|i - j| ≥ k$</span> instead, particularly in more mathematically-minded communities. Effectively, this definition treats diagonal matrices as bandwidth <span>$1$</span>, tridiagonal matrices as bandwidth <span>$2$</span>, and so on. Our definition, on the other hand, is more common in computer science contexts, treating diagonal matrices as bandwidth <span>$0$</span> and tridiagonal matrices as bandwidth <span>$1$</span>. (Both definitions, however, agree that the bandwidth of an empty matrix is simply <span>$0$</span>.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Minimization/core.jl#L7-L95">source</a></section></details></article><h2 id="MatrixBandwidth.Minimization.Exact-(Public)"><a class="docs-heading-anchor" href="#MatrixBandwidth.Minimization.Exact-(Public)"><code>MatrixBandwidth.Minimization.Exact</code> (Public)</a><a id="MatrixBandwidth.Minimization.Exact-(Public)-1"></a><a class="docs-heading-anchor-permalink" href="#MatrixBandwidth.Minimization.Exact-(Public)" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Minimization.Exact"><a class="docstring-binding" href="#MatrixBandwidth.Minimization.Exact"><code>MatrixBandwidth.Minimization.Exact</code></a> — <span class="docstring-category">Module</span></summary><section><div><pre><code class="language-julia hljs">MatrixBandwidth.Minimization.Exact</code></pre><p>Exact solvers for matrix bandwidth minimization.</p><p>Exact methods are those which guarantee an optimal ordering producing the true minimum bandwidth of a matrix. Since bandwidth minimization is an NP-complete problem, existing exact algorithms are, at best, exponential in time complexity—much worse than many polynomial-time heuristic approaches (e.g., Gibbs–Poole–Stockmeyer). Such methods, therefore, are not feasible for large matrices, but they remain useful when precise solutions are required for small-to-medium-sized inputs (say, up to <span>$100×100$</span>).</p><p>The following exact matrix bandwidth minimization algorithms are currently available:</p><ul><li>Del Corso–Manzini (<a href="#MatrixBandwidth.Minimization.Exact.DelCorsoManzini"><code>DelCorsoManzini</code></a>)</li><li>Del Corso–Manzini with perimeter search (<a href="#MatrixBandwidth.Minimization.Exact.DelCorsoManziniWithPS"><code>DelCorsoManziniWithPS</code></a>)</li><li>Caprara–Salazar-González (<a href="#MatrixBandwidth.Minimization.Exact.CapraraSalazarGonzalez"><code>CapraraSalazarGonzalez</code></a>)</li><li>Saxe–Gurari–Sudborough (<a href="#MatrixBandwidth.Minimization.Exact.SaxeGurariSudborough"><code>SaxeGurariSudborough</code></a>)</li><li>Brute-force search (<a href="#MatrixBandwidth.Minimization.Exact.BruteForceSearch"><code>BruteForceSearch</code></a>)</li></ul><p>This submodule is part of the <code>MatrixBandwidth.Minimization</code> submodule of the <a href="https://github.com/Luis-Varona/MatrixBandwidth.jl">MatrixBandwidth.jl</a> package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Minimization/Exact/Exact.jl#L7-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Minimization.Exact.BruteForceSearch"><a class="docstring-binding" href="#MatrixBandwidth.Minimization.Exact.BruteForceSearch"><code>MatrixBandwidth.Minimization.Exact.BruteForceSearch</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BruteForceSearch &lt;: ExactSolver &lt;: AbstractSolver &lt;: AbstractAlgorithm</code></pre><p>The simplest exact method for minimizing the bandwidth of a matrix is to iterate over all possible symmetric permutations and compare the bandwidths they induce.</p><p>Since <span>$i₁, i₂, … iₙ$</span> induces the same bandwidth as <span>$iₙ, iₙ₋₁, … i₁$</span>, we restrict our search to orderings such that <span>$i₁ ≤ iₙ$</span> (with equality checked just in case <span>$n = 1$</span>).</p><p><strong>Supertype Hierarchy</strong></p><p><code>BruteForceSearch</code> &lt;: <a href="#MatrixBandwidth.Minimization.Exact.ExactSolver"><code>ExactSolver</code></a> &lt;: <a href="#MatrixBandwidth.Minimization.AbstractSolver"><code>AbstractSolver</code></a> &lt;: <a href="#MatrixBandwidth.AbstractAlgorithm"><code>MatrixBandwidth.AbstractAlgorithm</code></a></p><p><strong>Performance</strong></p><p>Given an <span>$n×n$</span> input matrix <span>$A$</span>, this brute-force algorithm runs in <span>$O(n! ⋅ n²)$</span> time:</p><ul><li>Precisely <span>$n!/2$</span> permutations are checked (except when <span>$n = 1$</span>, in which case   <span>$1! = 1$</span> permutation is checked). This is, clearly, <span>$O(n!)$</span>.</li><li>For each permutation, the <a href="#MatrixBandwidth.bandwidth-Tuple{AbstractMatrix{&lt;:Number}}"><code>bandwidth</code></a> function is called on <code>view(A, perm, perm)</code>,   which takes <span>$O(n²)$</span> time.</li><li>Therefore, the overall time complexity is <span>$O(n! ⋅ n²)$</span>.</li></ul><p>Indeed, due to the need to exhaustively check all permutations, this is close to a lower bound as well on the the algorithm&#39;s time complexity. (The only reason we cannot claim to have a precise value for the big-<span>$Θ$</span> complexity is that the <a href="#MatrixBandwidth.bandwidth-Tuple{AbstractMatrix{&lt;:Number}}"><code>bandwidth</code></a> function is not <em>exactly</em> <span>$Θ(n²)$</span>, although it is close.)</p><p><strong>Examples</strong></p><p>The algorithm always iterates over all possible permutations, so it is infeasible to go above <span>$9×9$</span> or <span>$10×10$</span> without incurring multiple-hour runtimes. Nevertheless, we see that it is quite effective for, say, <span>$8×8$</span>:</p><pre><code class="language- hljs">using Random, SparseArrays
Random.seed!(628318);
(n, p) = (8, 0.2);
A = sprand(n, n, p);
A = A + A&#39; # Ensure structural symmetry;
minimize_bandwidth(A, Minimization.BruteForceSearch())</code></pre><p><strong>Notes</strong></p><p>Brute force is by far the slowest approach to matrix bandwidth minimization and should only be used in very niche cases (like verifying the correctness of other algorithms in unit tests). For <span>$10×10$</span> matrices, the algorithm already takes several minutes to run (between <span>$2$</span> to <span>$5$</span> on most commercial machines) and allocates over <span>$4$</span> gigabytes of memory. Given the <span>$O(n! ⋅ n²)$</span> time complexity, minimizing the bandwidth of any <span>$11×11$</span> matrix would take over an hour.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Minimization/Exact/solvers/brute_force_search.jl#L7-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Minimization.Exact.CapraraSalazarGonzalez"><a class="docstring-binding" href="#MatrixBandwidth.Minimization.Exact.CapraraSalazarGonzalez"><code>MatrixBandwidth.Minimization.Exact.CapraraSalazarGonzalez</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CapraraSalazarGonzalez &lt;: ExactSolver &lt;: AbstractSolver &lt;: AbstractAlgorithm</code></pre><p>The <em>Caprara–Salazar-González minimization algorithm</em> is an exact method for minimizing the bandwidth of a structurally symmetric matrix <span>$A$</span>. For a fixed <span>$k ∈ ℕ$</span>, the algorithm performs a depth-first search of all partial orderings of the rows and columns of <span>$A$</span>, adding indices one at a time. Partial orderings are pruned not only by ensuring that adjacent pairs of currently placed indices are within <span>$k$</span> of each other but also by employing a branch-and-bound framework with lower bounds on bandwidth compatibility computed via integer linear programming relaxations. This search is repeated with incrementing values of <span>$k$</span> until a bandwidth-<span>$k$</span> ordering is found [CS05], with <span>$k$</span> initialized to some lower bound on the minimum bandwidth of <span>$A$</span> up to symmetric permutation.</p><p>Specifically, this implementation of the Caprara–Salazar-González algorithm uses the <span>$min(α(A), γ(A))$</span> lower bound from the original paper [CS05, pp. 359–60] as the initial value of <span>$k$</span>. (Further implementation details can be found in the source code for <a href="#MatrixBandwidth.bandwidth_lower_bound-Tuple{AbstractMatrix{&lt;:Number}}"><code>bandwidth_lower_bound</code></a>.)</p><p>As noted above, the Caprara–Salazar-González algorithm requires structurally symmetric input (that is, <span>$A[i, j]$</span> must be nonzero if and only if <span>$A[j, i]$</span> is nonzero for <span>$1 ≤ i, j ≤ n$</span>).</p><p><strong>Supertype Hierarchy</strong></p><p><code>CapraraSalazarGonzalez</code> &lt;: <a href="#MatrixBandwidth.Minimization.Exact.ExactSolver"><code>ExactSolver</code></a> &lt;: <a href="#MatrixBandwidth.Minimization.AbstractSolver"><code>AbstractSolver</code></a> &lt;: <a href="#MatrixBandwidth.AbstractAlgorithm"><code>MatrixBandwidth.AbstractAlgorithm</code></a></p><p><strong>Performance</strong></p><p>Given an <span>$n×n$</span> input matrix, the Caprara–Salazar-González algorithm runs in <span>$O(n! ⋅ n ⋅ Tᵢₗₚ(n, n²))$</span> time, where <span>$Tᵢₗₚ(n, m)$</span> is the time taken to solve an  integer linear programming (ILP) problem with <span>$O(n)$</span> variables and <span>$O(m)$</span> constraints:</p><ul><li>For each underlying &quot;bandwidth ≤ <span>$k$</span>&quot; check, we perform a depth-first search of   <span>$O(n!)$</span> partial orderings.</li><li>At each search node, we solve ILP relaxations with <span>$n$</span> variables and <span>$O(n²)$</span>   constraints (given by the number of nonzero entries in the computed distance matrix),   taking <span>$Tᵢₗₚ(n, n²)$</span> time. (This dominates the <span>$O(n²)$</span> auxiliary computations needed   to set up the ILP.) Thus, the overall time complexity for each value of <span>$k$</span> is   <span>$O(n! ⋅ Tᵢₗₚ(n, n²))$</span>.</li><li>The difference between the maximum possible bandwidth (<span>$n - 1$</span>) and our initial lower   bound grows linearly in <span>$n$</span>, so we run the underlying <span>$O(n! ⋅ Tᵢₗₚ(n, n²))$</span>   recognition algorithm <span>$O(n)$</span> times.</li><li>Therefore, the overall time complexity is <span>$O(n! ⋅ n ⋅ Tᵢₗₚ(n, n²))$</span>.</li></ul><p>Note that <span>$Tᵢₗₚ(n, n²)$</span> has worst-case complexity <span>$O(2ⁿ)$</span>, although this ultimately depends on the ILP solver used. (Here, we use the HiGHS solver from the <code>HiGHS.jl</code> package.)</p><p>Of course, this is all but an upper bound on the time complexity of Caprara–Salazar-González, achieved only in the most pathological of cases. In practice, efficient pruning techniques and compatibility checks—along with [CS05, pp. 359–60]&#39;s relatively tight initial lower bound on the minimum bandwidth—result in approximately exponential growth in time complexity with respect to <span>$n$</span>.</p><p><strong>Examples</strong></p><p>We verify the optimality of the ordering found by Caprara–Salazar-González for a random <span>$8×8$</span> matrix via a brute-force search over all possible permutations up to reversal:</p><pre><code class="language- hljs">using Random, SparseArrays
Random.seed!(5883);
(n, p) = (8, 0.25);
A = sprand(n, n, p);
A = A + A&#39; # Ensure structural symmetry;
res_bf = minimize_bandwidth(A, Minimization.BruteForceSearch())
res_csg = minimize_bandwidth(A, Minimization.CapraraSalazarGonzalez())</code></pre><p><strong>Notes</strong></p><p>For readers of the original paper, what we call the Caprara–Salazar-González algorithm here is designated the <code>LAYOUT_LEFT_TO_RIGHT</code> algorithm in [CS05]. The paper also describes a <code>LAYOUT_BOTH_WAYS</code> algorithm that performs a bidirectional search by adding indices to both the left and right ends of the current partial ordering. However, this version is considerably more complex to implement, and we ran into problems enforcing ILP constraints on node pairs added to opposite ends of the ordering. In any case, computational results demonstrate that neither <code>LAYOUT_LEFT_TO_RIGHT</code> nor <code>LAYOUT_BOTH_WAYS</code> is consistently faster, and the paper states that there is no known heuristic for determining which version will be more performant for a given input [CS05, pp. 368–69]. Therefore, we opt to implement only <code>LAYOUT_LEFT_TO_RIGHT</code> as a matter of practicality, although future developers may wish to extend the interface with <code>LAYOUT_BOTH_WAYS</code> as well.</p><p>A final implementation detail worth noting is that we use HiGHS as our solver; it is one of the fastest open-source solvers available for mixed-integer linear programming.</p><p><strong>References</strong></p><ul><li>[<a href="#CS05">CS05</a>]: A. Caprara and J.-J. Salazar-González. <em>Laying Out Sparse Graphs with   Provably Minimum Bandwidth</em>. INFORMS Journal on Computing <strong>17</strong>, 356–73 (2005).   https://doi.org/10.1287/ijoc.1040.0083.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Minimization/Exact/solvers/caprara_salazar_gonzalez.jl#L7-L91">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Minimization.Exact.DelCorsoManzini"><a class="docstring-binding" href="#MatrixBandwidth.Minimization.Exact.DelCorsoManzini"><code>MatrixBandwidth.Minimization.Exact.DelCorsoManzini</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DelCorsoManzini &lt;: ExactSolver &lt;: AbstractSolver &lt;: AbstractAlgorithm</code></pre><p>The <em>Del Corso–Manzini minimization algorithm</em> is an exact method for minimizing the bandwidth of a structurally symmetric matrix <span>$A$</span>. For a fixed <span>$k ∈ ℕ$</span>, the algorithm invokes a subroutine that determines whether <span>$A$</span> has bandwidth at most <span>$k$</span> up to symmetric permutation. This subroutine performs a depth-first search of all partial orderings of the rows and columns of <span>$A$</span>, adding indices one at a time. Partial orderings are pruned not only by ensuring that adjacent pairs of currently placed indices are within <span>$k$</span> of each other but also by tracking the latest positions at which the remaining indices can be placed. This search is repeated with incrementing values of <span>$k$</span> until a bandwidth-<span>$k$</span> ordering is found [DM99], with <span>$k$</span> initialized to some lower bound on the minimum bandwidth of <span>$A$</span> up to symmetric permutation.</p><p>Specifically, this implementation of the Del Corso–Manzini algorithm uses the <span>$min(α(A), γ(A))$</span> lower bound from [CS05, pp. 359–60] as the initial value of <span>$k$</span>. (Further implementation details can be found in the source code for <a href="#MatrixBandwidth.bandwidth_lower_bound-Tuple{AbstractMatrix{&lt;:Number}}"><code>bandwidth_lower_bound</code></a>.) This improves upon the original algorithm, which used the maximum number of nonzero off-diagonal entries in a single row as a lower bound on the minimum bandwidth of <span>$A$</span> up to symmetric permutation [DM99, p. 192–93].</p><p>As noted above, the Del Corso–Manzini algorithm requires structurally symmetric input (that is, <span>$A[i, j]$</span> must be nonzero if and only if <span>$A[j, i]$</span> is nonzero for <span>$1 ≤ i, j ≤ n$</span>).</p><p><strong>Supertype Hierarchy</strong></p><p><code>DelCorsoManzini</code> &lt;: <a href="#MatrixBandwidth.Minimization.Exact.ExactSolver"><code>ExactSolver</code></a> &lt;: <a href="#MatrixBandwidth.Minimization.AbstractSolver"><code>AbstractSolver</code></a> &lt;: <a href="#MatrixBandwidth.AbstractAlgorithm"><code>MatrixBandwidth.AbstractAlgorithm</code></a></p><p><strong>Performance</strong></p><p>Given an <span>$n×n$</span> input matrix, the Del Corso–Manzini algorithm runs in <span>$O(n! ⋅ n³)$</span> time:</p><ul><li>For each underlying &quot;bandwidth ≤ <span>$k$</span>&quot; check, we perform a depth-first search of   <span>$O(n!)$</span> partial orderings.</li><li>Checking plausibility of each partial ordering takes <span>$O(nk)$</span> time, resulting in   <span>$O(n! ⋅ nk)$</span> steps for each value of <span>$k$</span>.</li><li>The difference between the maximum possible bandwidth (<span>$n - 1$</span>) and our initial lower   bound grows linearly in <span>$n$</span>, so we run the underlying <span>$O(n! ⋅ nk)$</span> recognition   algorithm <span>$O(n)$</span> times.</li><li>Finally, <span>$∑ₖ₌₀ⁿ⁻¹ nk = O(n³)$</span>, so the overall time complexity is <span>$O(n! ⋅ n³)$</span>.</li></ul><p>Of course, this is but an upper bound on the time complexity of Del Corso–Manzini, achieved only in the most pathological of cases. In practice, efficient pruning techniques and compatibility checks—along with [CS05, pp. 359–60]&#39;s relatively tight initial lower bound on the minimum bandwidth—result in approximately exponential growth in time complexity with respect to <span>$n$</span>.</p><p>Based on experimental results, the algorithm is feasible for <span>$n×n$</span> matrices up to <span>$n ≈ 100$</span> or so.</p><p><strong>Examples</strong></p><p>We verify the optimality of the ordering found by Del Corso–Manzini for a random <span>$9×9$</span> matrix via a brute-force search over all possible permutations up to reversal:</p><pre><code class="language- hljs">using Random, SparseArrays
Random.seed!(0117);
(n, p) = (9, 0.5);
A = sprand(n, n, p);
A = A + A&#39; # Ensure structural symmetry;
res_bf = minimize_bandwidth(A, Minimization.BruteForceSearch())
res_dcm = minimize_bandwidth(A, Minimization.DelCorsoManzini())</code></pre><p>We now generate (and shuffle) a random <span>$40×40$</span> matrix with minimum bandwidth <span>$10$</span> using <a href="../private_api/#MatrixBandwidth.random_banded_matrix-Tuple{Integer, Integer}"><code>MatrixBandwidth.random_banded_matrix</code></a>. Del Corso–Manzini then finds a bandwidth-<span>$10$</span> ordering, which is (we claim) optimal up to symmetric permutation. (In some cases, <code>random_banded_matrix(n, k)</code> <em>does</em> generate matrices with minimum bandwidth <code>&lt; k</code>. Nevertheless, this example demonstrates that Del Corso–Manzini at the very least finds a quite good ordering, even though exact optimality—which <em>is</em> guaranteed by the original paper [DM99]—is not explicitly verified.)</p><pre><code class="language- hljs">using Random
Random.seed!(0201);
(n, k) = (40, 10);
A = MatrixBandwidth.random_banded_matrix(n, k);
perm = randperm(n);
A_shuffled = A[perm, perm];
bandwidth(A)
bandwidth(A_shuffled) # Much larger after shuffling
minimize_bandwidth(A_shuffled, Minimization.DelCorsoManzini())</code></pre><p><strong>Notes</strong></p><p>For readers of the original paper, what we call the Del Corso–Manzini minimization algorithm here is designated the &quot;MB-ID algorithm&quot; in [DM99, p. 191]. The so-called &quot;MB-PS algorithm,&quot; on the other hand, we implement in <a href="#MatrixBandwidth.Minimization.Exact.DelCorsoManziniWithPS"><code>DelCorsoManziniWithPS</code></a>.</p><p><strong>References</strong></p><ul><li>[<a href="#CS05">CS05</a>]: A. Caprara and J.-J. Salazar-González. <em>Laying Out Sparse Graphs with   Provably Minimum Bandwidth</em>. INFORMS Journal on Computing <strong>17</strong>, 356–73 (2005).   https://doi.org/10.1287/ijoc.1040.0083.</li><li>[<a href="#DM99">DM99</a>]: G. M. Del Corso and G. Manzini. <em>Finding Exact Solutions to the Bandwidth   Minimization Problem</em>. Computing <strong>62</strong>, 189–203 (1999).   https://doi.org/10.1007/s006070050002.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Minimization/Exact/solvers/del_corso_manzini.jl#L7-L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Minimization.Exact.DelCorsoManziniWithPS"><a class="docstring-binding" href="#MatrixBandwidth.Minimization.Exact.DelCorsoManziniWithPS"><code>MatrixBandwidth.Minimization.Exact.DelCorsoManziniWithPS</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DelCorsoManziniWithPS{D} &lt;: ExactSolver &lt;: AbstractSolver &lt;: AbstractAlgorithm</code></pre><p>The <em>Del Corso–Manzini minimization algorithm with perimeter search</em> is an exact method for minimizing the bandwidth of a structurally symmetric matrix <span>$A$</span>. The base Del Corso–Manzini algorithm performs a depth-first search of all partial orderings of the rows and columns of <span>$A$</span> for some fixed <span>$k ∈ ℕ$</span>, adding indices one at a time. Partial orderings are pruned not only by ensuring that adjacent pairs of currently placed indices are within <span>$k$</span> of each other but also by tracking the latest positions at which the remaining indices can be placed. This search is repeated with incrementing values of <span>$k$</span> until a bandwidth-<span>$k$</span> ordering is found [DM99], with <span>$k$</span> initialized to some lower bound on the minimum bandwidth of <span>$A$</span> up to symmetric permutation.</p><p>The incorporation of perimeter search to this approach entails precomputing a &quot;perimeter&quot; of <span>$d$</span>-permutations of row indices of <span>$A$</span>, where <span>$d$</span> is a positive integer passed as a parameter to the solver. Each permutation represents a way to select the last <span>$d$</span> entries of the ordering, and as the construction of the partial ordering progresses, potential endings are pruned to exclude those incompatible with already placed indices. In addition to pruning a potential ending if it contains indices already placed, compatibility is also checked via precomputed time stamps indicating, for each potential ending, a loose lower bound on the earliest position at which any given index can be placed should said ending be selected.</p><p>Like our implementation of the base Del Corso–Manzini algorithm (see <a href="#MatrixBandwidth.Minimization.Exact.DelCorsoManzini"><code>DelCorsoManzini</code></a>), this implementation uses the <span>$min(α(A), γ(A))$</span> lower bound from [CS05, pp. 359–60] as the initial value of <span>$k$</span>. (Further implementation details can be found in the source code for <a href="#MatrixBandwidth.bandwidth_lower_bound-Tuple{AbstractMatrix{&lt;:Number}}"><code>bandwidth_lower_bound</code></a>.) This improves upon the original algorithm, which used the maximum number of nonzero off-diagonal entries in a single row as a lower bound on the minimum bandwidth of <span>$A$</span> up to symmetric permutation [DM99, p. 194].</p><p>As noted above, the Del Corso–Manzini algorithm with perimeter search requires structurally symmetric input (that is, <span>$A[i, j]$</span> must be nonzero if and only if <span>$A[j, i]$</span> is nonzero for <span>$1 ≤ i, j ≤ n$</span>).</p><p><strong>Fields</strong></p><ul><li><code>depth::D&lt;:Union{Nothing,Int}</code>: the perimeter search depth. If this field is not set (and)   thus automatically initialized to <code>nothing</code>), a default depth is automatically computed   by <a href="../private_api/#MatrixBandwidth.Recognition.dcm_ps_optimal_depth-Tuple{AbstractMatrix{Bool}}"><code>Recognition.dcm_ps_optimal_depth</code></a> as a function of the input matrix every   time the solver is passed to <a href="#MatrixBandwidth.Minimization.minimize_bandwidth"><code>MatrixBandwidth.Minimization.minimize_bandwidth</code></a>.   Otherwise, it must be manually set to a positive integer.</li></ul><p><strong>Constructors</strong></p><ul><li><code>DelCorsoManziniWithPS()</code>: constructs a new <code>DelCorsoManziniWithPS</code> instance with the   default perimeter search depth initialized to <code>nothing</code>.</li><li><code>DelCorsoManziniWithPS(depth::Integer)</code>: constructs a new <code>DelCorsoManziniWithPS</code> instance   with the specified perimeter search depth. <code>depth</code> must be a positive integer.</li></ul><p><strong>Supertype Hierarchy</strong></p><p><code>DelCorsoManziniWithPS</code> &lt;: <a href="#MatrixBandwidth.Minimization.Exact.ExactSolver"><code>ExactSolver</code></a> &lt;: <a href="#MatrixBandwidth.Minimization.AbstractSolver"><code>AbstractSolver</code></a> &lt;: <a href="#MatrixBandwidth.AbstractAlgorithm"><code>MatrixBandwidth.AbstractAlgorithm</code></a></p><p><strong>Performance</strong></p><p>Given an <span>$n×n$</span> input matrix and perimeter search depth <span>$d$</span>, the Del Corso–Manzini algorithm with perimeter search runs in <span>$O(n! ⋅ nᴰ⁺¹)$</span> time, where <span>$Dᴰ = max(d, 2)$</span>:</p><ul><li>For each underlying &quot;bandwidth ≤ <span>$k$</span>&quot; check, we perform a depth-first search of   <span>$O(n!)$</span> partial orderings.</li><li>Checking plausibility of each partial ordering takes <span>$O(nk)$</span> time, and checking   compatibility with all size-<span>$d$</span> LPOs takes <span>$O(nᵈ)$</span> time. Thus, the overall time   complexity for each value of <span>$k$</span> is <span>$O(n! ⋅ (nᵈ + nk))$</span>.</li><li>The difference between the maximum possible bandwidth (<span>$n - 1$</span>) and our initial lower   bound grows linearly in <span>$n$</span>, so we run the underlying <span>$O(n! ⋅ (nᵈ + nk))$</span>   recognition algorithm <span>$O(n)$</span> times.</li><li>Finally, <span>$∑ₖ₌₀ⁿ⁻¹ (nᵈ + nk) = O(nᵈ⁺¹ + n³)$</span>, so the overall time complexity   is <span>$O(n! ⋅ nᴰ⁺¹)$</span>, where <span>$D = max(d, 2)$</span>.</li></ul><p>Of course, this is but an upper bound on the time complexity of Del Corso–Manzini with perimeter search, achieved only in the most pathological of cases. In practice, efficient pruning techniques and compatibility checks—along with [CS05, pp. 359–60]&#39;s relatively tight initial lower bound on the minimum bandwidth—result in approximately exponential growth in time complexity with respect to <span>$n$</span>.</p><p>Based on experimental results, the algorithm is feasible for <span>$n×n$</span> matrices up to <span>$n ≈ 100$</span> or so.</p><p><strong>Examples</strong></p><p>We verify the optimality of the ordering found by Del Corso–Manzini with perimeter search for a random <span>$9×9$</span> matrix via a brute-force search over all possible permutations up to reversal. The depth parameter is not explicitly set; instead, some near-optimal value is automatically computed upon the first <a href="#MatrixBandwidth.Minimization.minimize_bandwidth"><code>MatrixBandwidth.Minimization.minimize_bandwidth</code></a> function call.</p><pre><code class="language- hljs">using Random, SparseArrays
Random.seed!(548836);
(n, p) = (9, 0.2);
A = sprand(n, n, p);
A = A + A&#39; # Ensure structural symmetry;
res_bf = minimize_bandwidth(A, Minimization.BruteForceSearch())
res_dcm_ps = minimize_bandwidth(A, Minimization.DelCorsoManziniWithPS())</code></pre><p>We now generate (and shuffle) a random <span>$30×30$</span> matrix with minimum bandwidth <span>$8$</span> using <a href="../private_api/#MatrixBandwidth.random_banded_matrix-Tuple{Integer, Integer}"><code>MatrixBandwidth.random_banded_matrix</code></a>. Del Corso–Manzini with perimeter search then finds a bandwidth-<span>$8$</span> ordering, which is (we claim) optimal up to symmetric permutation. (In some cases, <code>random_banded_matrix(n, k)</code> <em>does</em> generate matrices with minimum bandwidth <code>&lt; k</code>. Nevertheless, this example demonstrates that Del Corso–Manzini at the very least finds a quite good ordering, even though exact optimality—which <em>is</em> guaranteed by the original paper [DM99]—is not explicitly verified.) In this case, we set the depth parameter to <span>$4$</span> beforehand instead of relying on <a href="../private_api/#MatrixBandwidth.Recognition.dcm_ps_optimal_depth-Tuple{AbstractMatrix{Bool}}"><code>Recognition.dcm_ps_optimal_depth</code></a>.</p><pre><code class="language- hljs">using Random
Random.seed!(78779);
(n, k, depth) = (30, 8, 4);
A = MatrixBandwidth.random_banded_matrix(n, k);
perm = randperm(n);
A_shuffled = A[perm, perm];
bandwidth(A)
bandwidth(A_shuffled) # Much larger after shuffling
minimize_bandwidth(A_shuffled, Minimization.DelCorsoManziniWithPS(depth))</code></pre><p><strong>Notes</strong></p><p>For readers of the original paper, what we call the Del Corso–Manzini minimization algorithm with perimeter search here is designated the &quot;MB-PS algorithm&quot; in [DM99. p. 193]. The so-called &quot;MB-ID algorithm,&quot; on the other hand, we implement in <a href="#MatrixBandwidth.Minimization.Exact.DelCorsoManzini"><code>DelCorsoManzini</code></a>.</p><p><strong>References</strong></p><ul><li>[<a href="#CS05">CS05</a>]: A. Caprara and J.-J. Salazar-González. <em>Laying Out Sparse Graphs with   Provably Minimum Bandwidth</em>. INFORMS Journal on Computing <strong>17</strong>, 356–73 (2005).   https://doi.org/10.1287/ijoc.1040.0083.</li><li>[<a href="#DM99">DM99</a>]: G. M. Del Corso and G. Manzini. <em>Finding Exact Solutions to the Bandwidth   Minimization Problem</em>. Computing <strong>62</strong>, 189–203 (1999).   https://doi.org/10.1007/s006070050002.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Minimization/Exact/solvers/del_corso_manzini.jl#L107-L230">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Minimization.Exact.ExactSolver"><a class="docstring-binding" href="#MatrixBandwidth.Minimization.Exact.ExactSolver"><code>MatrixBandwidth.Minimization.Exact.ExactSolver</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ExactSolver &lt;: AbstractSolver &lt;: AbstractAlgorithm</code></pre><p>Abstract type for all exact matrix bandwidth minimization solvers.</p><p>Exact methods are those which guarantee an optimal ordering producing the true minimum bandwidth of a matrix. Since bandwidth minimization is an NP-complete problem, existing exact algorithms are, at best, exponential in time complexity—much worse than many polynomial-time heuristic approaches (e.g., Gibbs–Poole–Stockmeyer). Such methods, therefore, are not feasible for large matrices, but they remain useful when precise solutions are required for small-to-medium-sized inputs (say, up to <span>$100×100$</span>).</p><p><strong>Supertype Hierarchy</strong></p><p><code>ExactSolver</code> &lt;: <a href="#MatrixBandwidth.Minimization.AbstractSolver"><code>AbstractSolver</code></a> &lt;: <a href="#MatrixBandwidth.AbstractAlgorithm"><code>MatrixBandwidth.AbstractAlgorithm</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Minimization/Exact/types.jl#L7-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Minimization.Exact.SaxeGurariSudborough"><a class="docstring-binding" href="#MatrixBandwidth.Minimization.Exact.SaxeGurariSudborough"><code>MatrixBandwidth.Minimization.Exact.SaxeGurariSudborough</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SaxeGurariSudborough &lt;: ExactSolver &lt;: AbstractSolver &lt;: AbstractAlgorithm</code></pre><p>The <em>Saxe–Gurari–Sudborough minimization algorithm</em> is an exact method for minimizing the bandwidth of a structurally symmetric matrix <span>$A$</span>. For a fixed <span>$k ∈ ℕ$</span>, the algorithm invokes a subroutine that determines whether <span>$A$</span> has bandwidth at most <span>$k$</span> up to symmetric permutation. This subroutine employs dynamic programming to search over equivalence classes of partial orderings, where two partial orderings of length <span>$l$</span> are equivalent if they share the same <em>active region</em>. (The active region of a partial ordering is defined as the sequence of the last <span>$min(k, l)$</span> vertices in the ordering taken together with all <em>dangling edges</em>—edges with one endpoint in the ordering and the other endpoint not yet in the ordering.) It extends these partial layouts one vertex at a time in a breadth-first manner, pruning implausible classes that violate bandwidth-<span>$k$</span> constraints such as degree bounds on active vertices and excessive numbers of dangling edges [GS84]. This search is repeated with incrementing values of <span>$k$</span> until a bandwidth-<span>$k$</span> ordering is found, with <span>$k$</span> initialized to some lower bound on the minimum bandwidth of <span>$A$</span> up to symmetric permutation.</p><p>Specifically, this implementation of the Saxe–Gurari–Sudborough algorithm uses the <span>$min(α(A), γ(A))$</span> lower bound from [CS05, pp. 359–60] as the initial value of <span>$k$</span>. (Further implementation details can be found in the source code for <a href="#MatrixBandwidth.bandwidth_lower_bound-Tuple{AbstractMatrix{&lt;:Number}}"><code>bandwidth_lower_bound</code></a>.)</p><p>As noted above, the Saxe–Gurari–Sudborough algorithm requires structurally symmetric input (that is, <span>$A[i, j]$</span> must be nonzero if and only if <span>$A[j, i]$</span> is nonzero for <span>$1 ≤ i, j ≤ n$</span>).</p><p><strong>Supertype Hierarchy</strong></p><p><code>SaxeGurariSudborough</code> &lt;: <a href="#MatrixBandwidth.Minimization.Exact.ExactSolver"><code>ExactSolver</code></a> &lt;: <a href="#MatrixBandwidth.Minimization.AbstractSolver"><code>AbstractSolver</code></a> &lt;: <a href="#MatrixBandwidth.AbstractAlgorithm"><code>MatrixBandwidth.AbstractAlgorithm</code></a></p><p><strong>Performance</strong></p><p>Given an <span>$n×n$</span> input matrix, the Saxe–Gurari–Sudborough algorithm runs in <span>$O(nⁿ⁻¹)$</span> time:</p><ul><li>For each underlying &quot;bandwidth ≤ k&quot; check, we call the Saxe–Gurari–Sudborough recognition algorithm, which runs in <span>$O(nᵏ)$</span> time [GS84, p. 531]. (This is an improvement upon the original <span>$O(nᵏ⁺¹)$</span> Saxe algorithm [Sax80, p. 363].)</li><li>The difference between the maximum possible bandwidth (<span>$n - 1$</span>) and our initial lower   bound grows linearly in <span>$n$</span>, so we run the underlying <span>$O(nᵏ)$</span> recognition algorithm   <span>$O(n)$</span> times.</li><li>Therefore, the overall time complexity is <span>$∑ₖ₌₀ⁿ⁻¹ nᵏ = O(nⁿ⁻¹)$</span>.</li></ul><p>Whereas most exact bandwidth minimization algorithms are technically factorial-time (with respect to <span>$n$</span>) in the worst case but practically always approximate exponential time complexity in real life, the <span>$O(nⁿ⁻¹)$</span> upper bound on Saxe–Gurari–Sudborough is typically a good representation of actual performance in most cases. Indeed, these other types of algorithms tend to outperform Saxe–Gurari–Sudborough for larger <span>$n$</span>, given that their aggressive pruning strategies keep their effective search space very small in practice and <span>$O(2ⁿ)$</span> ⊂ <span>$O(nⁿ⁻¹)$</span>.</p><p><strong>Examples</strong></p><p>We verify the optimality of the ordering found by Saxe–Gurari–Sudborough for a random <span>$9×9$</span> matrix via a brute-force search over all possible permutations up to reversal:</p><pre><code class="language- hljs">using Random, SparseArrays
Random.seed!(52452);
(n, p) = (9, 0.5);
A = sprand(n, n, p);
A = A + A&#39; # Ensure structural symmetry;
res_bf = minimize_bandwidth(A, Minimization.BruteForceSearch())
res_sgs = minimize_bandwidth(A, Minimization.SaxeGurariSudborough())</code></pre><p>We now generate (and shuffle) a random <span>$25×25$</span> matrix with minimum bandwidth <span>$5$</span> using <a href="../private_api/#MatrixBandwidth.random_banded_matrix-Tuple{Integer, Integer}"><code>MatrixBandwidth.random_banded_matrix</code></a>. Saxe–Gurari–Sudborough then finds a bandwidth-<span>$4$</span> ordering, which is (we claim) optimal up to symmetric permutation. (In some cases, <code>random_banded_matrix(n, k)</code> generates matrices with minimum bandwidth <code>&lt; k</code>—this appears to be one such case. Although we do not explicitly verify exact optimality—which <em>is</em> guaranteed by the original paper [GS84]—here via brute-force search, this example demonstrates that Saxe–Gurari–Sudborough at the very least finds a quite good ordering.)</p><pre><code class="language- hljs">using Random
Random.seed!(937497);
(n, k, p) = (25, 5, 0.25);
A = MatrixBandwidth.random_banded_matrix(n, k; p=p);
perm = randperm(n);
A_shuffled = A[perm, perm];
bandwidth(A)
bandwidth(A_shuffled) # Much larger after shuffling
minimize_bandwidth(A_shuffled, Minimization.SaxeGurariSudborough())</code></pre><p><strong>Notes</strong></p><p>The Saxe–Gurari–Sudborough algorithm was originally a bandwidth recognition algorithm, not a minimization one—as previously mentioned, we repurpose it here by repeatedly invoking the original procedure for incrementing values of <span>$k$</span> until a valid ordering is found. The general family of recognition algorithms to which Saxe–Gurari–Sudborough belongs was conceived as a response to a question posed by [GGJK78, p. 494]: is the &quot;bandwidth ≤ k?&quot; problem NP-complete for arbitrary <span>$k$</span>? [Sax80] answered this question in the negative by providing a <span>$O(nᵏ⁺¹)$</span> algorithm, constructively proving that the problem is class P. Later, [GS84] improved upon this algorithm by reducing time complexity to <span>$O(nᵏ)$</span>. Whereas the original Saxe algorithm considers extensions of partial orderings with any remaining unplaced vertex (of which there are <span>$O(n)$</span> at any point in the breadth-first search), the Gurari–Sudborough refinement only considers extensions with vertices reachable by paths beginning with a dangling edge that never again traverse a dangling edge [GS84, pp. 535–36].</p><p><strong>References</strong></p><ul><li>[<a href="#GGJK78">GGJK78</a>]: M. R. Garey, R. L. Graham, D. S. Johnson and D. E. Knuth. <em>Complexity   Results for Bandwidth Minimization</em>. SIAM Journal on Applied Mathematics <strong>34</strong>, 477–95   (1978). https://doi.org/10.1137/0134037.</li><li>[<a href="#GS84">GS84</a>]: E. M. Gurari and I. H. Sudborough. <em>Improved dynamic programming algorithms   for bandwidth minimization and the MinCut Linear Arrangement problem</em>. Journal of   Algorithms <strong>5</strong>, 531–46 (1984). https://doi.org/10.1016/0196-6774(84)90006-3.</li><li>[<a href="#Sax80">Sax80</a>]: J. B. Saxe. <em>Dynamic-Programming Algorithms for Recognizing   Small-Bandwidth Graphs in Polynomial Time</em>. SIAM Journal on Algebraic and Discrete   Methods <strong>1</strong>, 363–69 (1980). https://doi.org/10.1137/0601042.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Minimization/Exact/solvers/saxe_gurari_sudborough.jl#L7-L113">source</a></section></details></article><h2 id="MatrixBandwidth.Minimization.Heuristic-(Public)"><a class="docs-heading-anchor" href="#MatrixBandwidth.Minimization.Heuristic-(Public)"><code>MatrixBandwidth.Minimization.Heuristic</code> (Public)</a><a id="MatrixBandwidth.Minimization.Heuristic-(Public)-1"></a><a class="docs-heading-anchor-permalink" href="#MatrixBandwidth.Minimization.Heuristic-(Public)" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Minimization.Heuristic"><a class="docstring-binding" href="#MatrixBandwidth.Minimization.Heuristic"><code>MatrixBandwidth.Minimization.Heuristic</code></a> — <span class="docstring-category">Module</span></summary><section><div><pre><code class="language-julia hljs">MatrixBandwidth.Minimization.Heuristic</code></pre><p>Heuristic solvers for matrix bandwidth minimization.</p><p>Heuristic methods are those which aim to produce near-optimal solutions in a more performant manner than exact methods. While precise bandwidth minimization is NP-complete, many heuristic algorithms (such as Gibbs–Poole–Stockmeyer) run in polynomial time.</p><p>Heuristic algorithms differ from metaheuristic ones in that they do not employ higher-level iterative search frameworks (e.g., stochastic techniques) to survey the global search space and escape local minima; instead, they rely on straightforward deterministic procedures to find good solutions in a single pass.</p><p>The following heuristic matrix bandwidth minimization algorithms are currently available:</p><ul><li>Gibbs–Poole–Stockmeyer (<a href="#MatrixBandwidth.Minimization.Heuristic.GibbsPooleStockmeyer"><code>GibbsPooleStockmeyer</code></a>)</li><li>Cuthill–McKee (<a href="#MatrixBandwidth.Minimization.Heuristic.CuthillMcKee"><code>CuthillMcKee</code></a>)</li><li>Reverse Cuthill–McKee (<a href="#MatrixBandwidth.Minimization.Heuristic.ReverseCuthillMcKee"><code>ReverseCuthillMcKee</code></a>)</li></ul><p>This submodule is part of the <code>MatrixBandwidth.Minimization</code> submodule of the <a href="https://github.com/Luis-Varona/MatrixBandwidth.jl">MatrixBandwidth.jl</a> package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Minimization/Heuristic/Heuristic.jl#L7-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Minimization.Heuristic.CuthillMcKee"><a class="docstring-binding" href="#MatrixBandwidth.Minimization.Heuristic.CuthillMcKee"><code>MatrixBandwidth.Minimization.Heuristic.CuthillMcKee</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CuthillMcKee &lt;: HeuristicSolver &lt;: AbstractSolver &lt;: AbstractAlgorithm</code></pre><p>The <em>Cuthill–McKee algorithm</em> is a heuristic method for minimizing the bandwidth of a structurally symmetric matrix <span>$A$</span>. It considers the graph <span>$G(A)$</span> whose adjacency matrix is <span>$A$</span> (ignoring weights and self-loops) and performs a breadth-first search of each connected component of <span>$G(A)$</span>, starting from a low-degree node then visiting its neighbors in order of increasing degree. Particularly effective when <span>$A$</span> is sparse, this heuristic typically produces an ordering which induces a matrix bandwidth either equal to or very close to the true minimum [CM69, pp. 157–58].</p><p>As noted above, the Cuthill–McKee algorithm requires structurally symmetric input (that is, <span>$A[i, j]$</span> must be nonzero if and only if <span>$A[j, i]$</span> is nonzero for <span>$1 ≤ i, j ≤ n$</span>).</p><p><strong>Fields</strong></p><ul><li><code>node_finder::Function</code>: a function that selects a node from some connected component of   the input matrix from which to start the breadth-first search. If no custom heuristic is   specified, this field defaults to <a href="../private_api/#MatrixBandwidth.Minimization.Heuristic.bi_criteria_node_finder-Tuple{AbstractMatrix{Bool}}"><code>bi_criteria_node_finder</code></a>, which picks a node   &quot;farthest&quot; from the others in the component (not necessarily the lowest-degree node).</li></ul><p><strong>Supertype Hierarchy</strong></p><p><code>CuthillMcKee</code> &lt;: <a href="#MatrixBandwidth.Minimization.Heuristic.HeuristicSolver"><code>HeuristicSolver</code></a> &lt;: <a href="#MatrixBandwidth.Minimization.AbstractSolver"><code>AbstractSolver</code></a> &lt;: <a href="#MatrixBandwidth.AbstractAlgorithm"><code>MatrixBandwidth.AbstractAlgorithm</code></a></p><p><strong>Performance</strong></p><p>Given an <span>$n×n$</span> input matrix <span>$A$</span>, the Cuthill–McKee algorithm runs in <span>$O(n²)$</span> time.</p><p>[CG80] provide a linear-time implementation in the number of nonzero entries of <span>$A$</span>, which is still quadratic when <span>$A$</span> is dense but often much faster when dealing with sparse matrices. However, this would require that <span>$A$</span> be stored as a graph or a sparse matrix, which runs counter to our desire to provide a bandwidth minimization API for all <code>AbstractMatrix{&lt;:Number}</code> types, including dense matrices. (In the future, however, we may indeed consider supporting this more performant implementation for sparse matrices.)</p><p>It was found in [Geo71, pp. 114–15] that reversing the ordering produced by Cuthill–McKee tends to induce a more optimal <em>matrix profile</em> (a measure of how far, on average, nonzero entries are from the diagonal; see also <a href="#MatrixBandwidth.profile-Tuple{AbstractMatrix{&lt;:Number}}"><code>MatrixBandwidth.profile</code></a>). This so-called <em>reverse Cuthill–McKee</em> variant is preferred in almost all cases—see <a href="#MatrixBandwidth.Minimization.Heuristic.ReverseCuthillMcKee"><code>ReverseCuthillMcKee</code></a> and the associated method of <code>_minimize_bandwidth_impl</code> for our implementation.</p><p><strong>Examples</strong></p><p>In the following examples, <a href="../private_api/#MatrixBandwidth.random_banded_matrix-Tuple{Integer, Integer}"><code>MatrixBandwidth.random_banded_matrix</code></a> is used to generate random matrices with minimum bandwidth <em>close to</em> <span>$k$</span>. In some cases, however, the true minimum bandwidth up to symmetric permutation may be even less than <span>$k$</span>, making it hard to verify whether Cuthill–McKee finds a truly optimal ordering or simply a near-optimal one. Nevertheless, the results are still very good in practice.</p><p>Cuthill–McKee finds a good ordering for a <span>$30×30$</span> matrix:</p><pre><code class="language- hljs">using Random
Random.seed!(13);
(n, k) = (30, 5);
A = MatrixBandwidth.random_banded_matrix(n, k);
perm = randperm(n);
A_shuffled = A[perm, perm];
bandwidth(A)
bandwidth(A_shuffled) # Much larger after shuffling
minimize_bandwidth(A_shuffled, Minimization.CuthillMcKee())</code></pre><p>Cuthill–McKee finds a good ordering for a structurally symmetric <span>$183×183$</span> matrix with multiple (separate) connected components:</p><pre><code class="language- hljs">using Random, SparseArrays
Random.seed!(37452);
(max_cc_size, max_band, p, num_ccs) = (60, 9, 0.2, 7);
components = Vector{SparseMatrixCSC{Float64, Int64}}(undef, num_ccs);

for i in 1:num_ccs # Some components may themselves be disconnected
    cc_size = rand(1:max_cc_size);
    cc_band = rand(0:min(max_band, cc_size - 1));
    components[i] = sparse(
        MatrixBandwidth.random_banded_matrix(cc_size, cc_band; p=p)
    );
end

A = blockdiag(components...); # `A` has least 7 connected components
perm = randperm(sum(map(cc -&gt; size(cc, 1), components)));
A_shuffled = A[perm, perm];
res = minimize_bandwidth(A_shuffled, Minimization.CuthillMcKee());
A # The original matrix
A_shuffled # A far-from-optimal ordering of `A`
A_shuffled[res.ordering, res.ordering] # A near-optimal reordering of `A_shuffled`
bandwidth(A)
bandwidth(A_shuffled) # Much larger after shuffling
res # Even better than the original bandwidth (which was, clearly, not yet optimal)</code></pre><p><strong>Notes</strong></p><p>Note that the <code>node_finder</code> field must be of the form <code>(A::AbstractMatrix{Bool}) -&gt; Integer</code> (i.e., it must take in an boolean matrix and return an integer). If this is not the case, an <code>ArgumentError</code> is thrown upon construction.</p><p><strong>References</strong></p><ul><li>[<a href="#CG80">CG80</a>]: W. M. Chan and A. George. <em>A linear time implementation of the reverse   Cuthill–McKee algorithm</em>. BIT Numerical Mathematics <strong>20</strong>, 8–14 (1980).   https://doi.org/10.1007/BF01933580.</li><li>[<a href="#CM69">CM69</a>]: E. Cuthill and J. McKee. <em>Reducing the bandwidth of sparse symmetric   matrices</em>. In: <em>Proceedings of the 24th National Conference of the ACM</em> (Brandon Systems   Press, 1969); pp. 157–72. https://doi.org/10.1145/800195.805928.</li><li>[<a href="#Geo71">Geo71</a>]: J. A. George. <em>Computer Implementation of the Finite Element Method</em>.   Ph.D. Thesis, Department of Computer Science, Stanford University (1971).   https://apps.dtic.mil/sti/tr/pdf/AD0726171.pdf.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Minimization/Heuristic/solvers/cuthill_mckee.jl#L7-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Minimization.Heuristic.GibbsPooleStockmeyer"><a class="docstring-binding" href="#MatrixBandwidth.Minimization.Heuristic.GibbsPooleStockmeyer"><code>MatrixBandwidth.Minimization.Heuristic.GibbsPooleStockmeyer</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GibbsPooleStockmeyer &lt;: HeuristicSolver &lt;: AbstractSolver &lt;: AbstractAlgorithm</code></pre><p>The <em>Gibbs–Poole–Stockmeyer algorithm</em> is a heuristic method for minimizing the bandwidth of a structurally symmetric matrix <span>$A$</span>. It considers the graph <span>$G(A)$</span> whose adjacency matrix is <span>$A$</span> (ignoring weights and self-loops) and builds an ordering by identifying a pair of &quot;endpoints&quot; in the graph far from each other, constructing sets of levels from these endpoints, and merging these level structures in such a way that minimizes the size of the largest level in the final combined structure. Based on the classical reverse Cuthill–McKee algorithm [Geo71], this heuristic typically produces an ordering which induces a matrix bandwidth either equal to or very close to the true minimum, with improvements in bandwidths over reverse Cuthill–McKee more noticeable once input size exceeds <span>$400×400$</span> or so [GPS76, pp. 246–47].</p><p>Whereas the original paper outlined a strategy for conditionally reversing the orderings of individual &quot;connected components&quot; (treating the input matrix <span>$A$</span> as an undirected graph) [GPS76, p. 241], this implementation instead reverses the entire final ordering in every case, similarly to <a href="#MatrixBandwidth.Minimization.Heuristic.ReverseCuthillMcKee"><code>ReverseCuthillMcKee</code></a>. Conditional reversals are not only more complex to implement but also slightly more time-consuming, with the only benefit being a marginally smaller <em>matrix profile</em> (a measure of how far, on average, nonzero entries are from the diagonal; see also <a href="#MatrixBandwidth.profile-Tuple{AbstractMatrix{&lt;:Number}}"><code>MatrixBandwidth.profile</code></a>). Since such reversal strategies do not affect matrix bandwidth (the primary focus of this package), we opt instead for the simpler unconditional reversal.</p><p>As noted above, the Gibbs–Poole–Stockmeyer algorithm requires structurally symmetric input (that is, <span>$A[i, j]$</span> must be nonzero if and only if <span>$A[j, i]$</span> is nonzero for <span>$1 ≤ i, j ≤ n$</span>).</p><p><strong>Fields</strong></p><ul><li><code>node_finder::Function</code>: a function that selects a node from some connected component of   the input matrix from which to start the breadth-first search. If no custom heuristic is   specified, this field defaults to <a href="../private_api/#MatrixBandwidth.Minimization.Heuristic.bi_criteria_node_finder-Tuple{AbstractMatrix{Bool}}"><code>bi_criteria_node_finder</code></a>, which picks a node   &quot;farthest&quot; from the others in the component (not necessarily the lowest-degree node).</li></ul><p><strong>Supertype Hierarchy</strong></p><p><code>GibbsPooleStockmeyer</code> &lt;: <a href="#MatrixBandwidth.Minimization.Heuristic.HeuristicSolver"><code>HeuristicSolver</code></a> &lt;: <a href="#MatrixBandwidth.Minimization.AbstractSolver"><code>AbstractSolver</code></a> &lt;: <a href="#MatrixBandwidth.AbstractAlgorithm"><code>MatrixBandwidth.AbstractAlgorithm</code></a></p><p><strong>Performance</strong></p><p>Given an <span>$n×n$</span> input matrix, the Gibbs–Poole–Stockmeyer algorithm runs in <span>$O(n²)$</span> time.</p><p>[Lew82] provides a notably faster and more memory-efficient implementation, relying on sparse storage of the input matrix. However, this would run counter to our desire to provide a bandwidth minimization API for all <code>AbstractMatrix{&lt;:Number}</code> types, including dense matrices. (In the future, however, we may indeed consider supporting this more performant implementation for sparse matrices.)</p><p>On that note, Gibbs–Poole–Stockmeyer has been found to take considerably less time than reverse Cuthill–McKee when matrices are stored in sparse format [GPS76, pp. 246–47]. The dense-matrix implementations of both algorithms in this package, however, result in reverse Cuthill–McKee consistently outperforming Gibbs–Poole–Stockmeyer in terms of runtime (although Gibbs–Poole–Stockmeyer still typically produces lower-bandwidth orderings for larger matrices). This further motivates the desire to implement a sparse version of both algorithms in the future.</p><p><strong>Examples</strong></p><p>In the following examples, <a href="../private_api/#MatrixBandwidth.random_banded_matrix-Tuple{Integer, Integer}"><code>MatrixBandwidth.random_banded_matrix</code></a> is used to generate random matrices with minimum bandwidth <em>close to</em> <span>$k$</span>. In some cases, however, the true minimum bandwidth up to symmetric permutation may be even less than <span>$k$</span>, making it hard to verify whether Gibbs–Poole–Stockmeyer finds a truly optimal ordering or simply a near-optimal one. Nevertheless, the results are still very good in practice.</p><p>Gibbs–Poole–Stockmeyer finds a good ordering for a <span>$40×40$</span> matrix:</p><pre><code class="language- hljs">using Random
Random.seed!(561);
(n, k) = (40, 7);
A = MatrixBandwidth.random_banded_matrix(n, k);
perm = randperm(n);
A_shuffled = A[perm, perm];
bandwidth(A)
bandwidth(A_shuffled)
minimize_bandwidth(A_shuffled, Minimization.GibbsPooleStockmeyer())</code></pre><p>Gibbs–Poole–Stockmeyer finds a good ordering for a <span>$748×748$</span> matrix with multiple (separate) connected components:</p><pre><code class="language-julia hljs">using Random, SparseArrays
Random.seed!(271828);
(max_cc_size, max_band, p, num_ccs) = (120, 13, 0.3, 11);
components = Vector{SparseMatrixCSC{Float64, Int64}}(undef, num_ccs);

for i in 1:num_ccs # Some components may themselves be disconnected
    cc_size = rand(1:max_cc_size);
    cc_band = rand(0:min(max_band, cc_size - 1));
    components[i] = sparse(
        MatrixBandwidth.random_banded_matrix(cc_size, cc_band; p=p)
    );
end

A = blockdiag(components...); # `A` has least 8 connected components
perm = randperm(sum(map(cc -&gt; size(cc, 1), components)));
A_shuffled = A[perm, perm];
res = minimize_bandwidth(A_shuffled, Minimization.GibbsPooleStockmeyer());
A # The original matrix
A_shuffled # A far-from-optimal ordering of `A`
A_shuffled[res.ordering, res.ordering] # A near-optimal reordering of `A_shuffled`
bandwidth(A)
bandwidth(A_shuffled) # Much larger after shuffling
res # Gets very close to the original bandwidth</code></pre><p><strong>Notes</strong></p><p>Note that the <code>node_finder</code> field must be of the form <code>(A::AbstractMatrix{Bool}) -&gt; Integer</code> (i.e., it must take in an boolean matrix and return an integer). If this is not the case, an <code>ArgumentError</code> is thrown upon construction.</p><p><strong>References</strong></p><ul><li>[<a href="#Geo71">Geo71</a>]: J. A. George. <em>Computer Implementation of the Finite Element Method</em>.   Ph.D. Thesis, Department of Computer Science, Stanford University (1971).   https://apps.dtic.mil/sti/tr/pdf/AD0726171.pdf.</li><li>[<a href="#GPS76">GPS76</a>]: N. E. Gibbs, W. G. Poole Jr. and P. K. Stockmeyer. <em>An Algorithm for   Reducing the Bandwidth and Profile of a Sparse Matrix</em>. SIAM Journal on Numerical   Analysis <strong>13</strong>, 236–50 (1976). https://doi.org/10.1137/0713023.</li><li>[<a href="#Lew82">Lew82</a>]: J. G. Lewis. <em>Implementation of the Gibbs–Poole–Stockmeyer and Gibbs–King   Algorithms</em>. ACM Transactions on Mathematical Software <strong>8</strong>, 180–89 (1982).   https://doi.org/10.1145/355993.355998.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Minimization/Heuristic/solvers/gibbs_poole_stockmeyer.jl#L7-L124">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Minimization.Heuristic.HeuristicSolver"><a class="docstring-binding" href="#MatrixBandwidth.Minimization.Heuristic.HeuristicSolver"><code>MatrixBandwidth.Minimization.Heuristic.HeuristicSolver</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">HeuristicSolver &lt;: AbstractSolver &lt;: AbstractAlgorithm</code></pre><p>Abstract type for all heuristic matrix bandwidth minimization solvers.</p><p>Heuristic methods are those which aim to produce near-optimal solutions in a more performant manner than exact methods. While precise bandwidth minimization is NP-complete, many heuristic algorithms (such as Gibbs–Poole–Stockmeyer) run in polynomial time.</p><p>Heuristic algorithms differ from metaheuristic ones in that they do not employ higher-level iterative search frameworks (e.g., stochastic techniques) to survey the global search space and escape local minima; instead, they rely on straightforward deterministic procedures to find good solutions in a single pass.</p><p><strong>Supertype Hierarchy</strong></p><p><code>HeuristicSolver</code> &lt;: <a href="#MatrixBandwidth.Minimization.AbstractSolver"><code>AbstractSolver</code></a> &lt;: <a href="#MatrixBandwidth.AbstractAlgorithm"><code>MatrixBandwidth.AbstractAlgorithm</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Minimization/Heuristic/types.jl#L7-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Minimization.Heuristic.ReverseCuthillMcKee"><a class="docstring-binding" href="#MatrixBandwidth.Minimization.Heuristic.ReverseCuthillMcKee"><code>MatrixBandwidth.Minimization.Heuristic.ReverseCuthillMcKee</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ReverseCuthillMcKee &lt;: HeuristicSolver &lt;: AbstractSolver &lt;: AbstractAlgorithm</code></pre><p>The <em>reverse Cuthill–McKee algorithm</em> is a variant of the <em>Cuthill–McKee algorithm</em>—a heuristic method for minimizing the bandwidth of a structurally symmetric matrix <span>$A$</span>. Cuthill–McKee considers the graph <span>$G(A)$</span> whose adjacency matrix is <span>$A$</span> (ignoring weights and self-loops) and performs a breadth-first search of each connected component of <span>$G(A)$</span>, starting from a low-degree node then visiting its neighbors in order of increasing degree. Particularly effective when <span>$A$</span> is sparse, this heuristic typically produces an ordering which induces a matrix bandwidth either equal to or very close to the true minimum [CM69, pp. 157–58]. The reverse Cuthill–McKee algorithm simply reverses the ordering produced by application of Cuthill–McKee; it was found in [Geo71, pp. 114–15] that although the bandwidth remains the same, this tends to produce a more optimal <em>matrix profile</em> (a measure of how far, on average, nonzero entries are from the diagonal; see also <a href="#MatrixBandwidth.profile-Tuple{AbstractMatrix{&lt;:Number}}"><code>MatrixBandwidth.profile</code></a>).</p><p>As noted above, the reverse Cuthill–McKee algorithm requires structurally symmetric input (that is, <span>$A[i, j]$</span> must be nonzero if and only if <span>$A[j, i]$</span> is nonzero for <span>$1 ≤ i, j ≤ n$</span>).</p><p><strong>Performance</strong></p><p>Given an <span>$n×n$</span> input matrix <span>$A$</span>, the reverse Cuthill–McKee algorithm runs in <span>$O(n²)$</span> time.</p><p>[CG80] provide a linear-time implementation in the number of nonzero entries of <span>$A$</span>, which is still quadratic when <span>$A$</span> is dense but often much faster when dealing with sparse matrices. However, this would require that <span>$A$</span> be stored as a graph or a sparse matrix, which runs counter to our desire to provide a bandwidth minimization API for all <code>AbstractMatrix{&lt;:Number}</code> types, including dense matrices. (In the future, however, we may indeed consider supporting this more performant implementation for sparse matrices.)</p><p><strong>Fields</strong></p><ul><li><code>node_finder::Function</code>: a function that selects a node from some connected component of   the input matrix from which to start the breadth-first search. If no custom heuristic is   specified, this field defaults to <a href="../private_api/#MatrixBandwidth.Minimization.Heuristic.bi_criteria_node_finder-Tuple{AbstractMatrix{Bool}}"><code>bi_criteria_node_finder</code></a>, which picks a node   &quot;farthest&quot; from the others in the component (not necessarily the lowest-degree node).</li></ul><p><strong>Supertype Hierarchy</strong></p><p><code>ReverseCuthillMcKee</code> &lt;: <a href="#MatrixBandwidth.Minimization.Heuristic.HeuristicSolver"><code>HeuristicSolver</code></a> &lt;: <a href="#MatrixBandwidth.Minimization.AbstractSolver"><code>AbstractSolver</code></a> &lt;: <a href="#MatrixBandwidth.AbstractAlgorithm"><code>MatrixBandwidth.AbstractAlgorithm</code></a></p><p><strong>Examples</strong></p><p>In the following examples, <a href="../private_api/#MatrixBandwidth.random_banded_matrix-Tuple{Integer, Integer}"><code>MatrixBandwidth.random_banded_matrix</code></a> is used to generate random matrices with minimum bandwidth <em>close to</em> <span>$k$</span>. In some cases, however, the true minimum bandwidth up to symmetric permutation may be even less than <span>$k$</span>, making it hard to verify whether reverse Cuthill–McKee finds a truly optimal ordering or simply a near-optimal one. Nevertheless, the results are still very good in practice.</p><p>Reverse Cuthill–McKee finds a good ordering for a <span>$35×35$</span> matrix:</p><pre><code class="language- hljs">using Random
Random.seed!(87);
(n, k) = (35, 3);
A = MatrixBandwidth.random_banded_matrix(n, k);
perm = randperm(n);
A_shuffled = A[perm, perm];
bandwidth(A)
bandwidth(A_shuffled) # Much larger after shuffling
minimize_bandwidth(A_shuffled, Minimization.ReverseCuthillMcKee())</code></pre><p>Reverse Cuthill–McKee finds a good ordering for a <span>$235×235$</span> matrix with multiple (separate) connected components:</p><pre><code class="language- hljs">using Random, SparseArrays
Random.seed!(5747);
(max_cc_size, max_band, p, num_ccs) = (60, 9, 0.2, 8);
components = Vector{SparseMatrixCSC{Float64, Int64}}(undef, num_ccs);

for i in 1:num_ccs # Some components may themselves be disconnected
    cc_size = rand(1:max_cc_size);
    cc_band = rand(0:min(max_band, cc_size - 1));
    components[i] = sparse(
        MatrixBandwidth.random_banded_matrix(cc_size, cc_band; p=p)
    );
end

A = blockdiag(components...); # `A` has least 8 connected components
perm = randperm(sum(map(cc -&gt; size(cc, 1), components)));
A_shuffled = A[perm, perm];
res = minimize_bandwidth(A_shuffled, Minimization.ReverseCuthillMcKee());
A # The original matrix
A_shuffled # A far-from-optimal ordering of `A`
A_shuffled[res.ordering, res.ordering] # A near-optimal reordering of `A_shuffled`
bandwidth(A)
bandwidth(A_shuffled) # Much larger after shuffling
res # Gets very close to the original bandwidth</code></pre><p><strong>Notes</strong></p><p>Note that the <code>node_finder</code> field must be of the form <code>(A::AbstractMatrix{Bool}) -&gt; Integer</code> (i.e., it must take in an boolean matrix and return an integer). If this is not the case, an <code>ArgumentError</code> is thrown upon construction.</p><p>See also the documentation for <a href="#MatrixBandwidth.Minimization.Heuristic.CuthillMcKee"><code>CuthillMcKee</code></a>—the original (non-reversed) algorithm. (Indeed, the reverse Cuthill–McKee method of <code>_minimize_bandwidth_impl</code> is merely a wrapper around the Cuthill–McKee method.)</p><p><strong>References</strong></p><ul><li>[<a href="#CG80">CG80</a>]: W. M. Chan and A. George. <em>A linear time implementation of the reverse   Cuthill–McKee algorithm</em>. BIT Numerical Mathematics <strong>20</strong>, 8–14 (1980).   https://doi.org/10.1007/BF01933580.</li><li>[<a href="#CM69">CM69</a>]: E. Cuthill and J. McKee. <em>Reducing the bandwidth of sparse symmetric   matrices</em>. In: <em>Proceedings of the 24th National Conference of the ACM</em> (Brandon Systems   Press, 1969); pp. 157–72. https://doi.org/10.1145/800195.805928.</li><li>[<a href="#Geo71">Geo71</a>]: J. A. George. <em>Computer Implementation of the Finite Element Method</em>.   Ph.D. Thesis, Department of Computer Science, Stanford University (1971).   https://apps.dtic.mil/sti/tr/pdf/AD0726171.pdf.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Minimization/Heuristic/solvers/cuthill_mckee.jl#L126-L233">source</a></section></details></article><h2 id="MatrixBandwidth.Minimization.Metaheuristic-(Public)"><a class="docs-heading-anchor" href="#MatrixBandwidth.Minimization.Metaheuristic-(Public)"><code>MatrixBandwidth.Minimization.Metaheuristic</code> (Public)</a><a id="MatrixBandwidth.Minimization.Metaheuristic-(Public)-1"></a><a class="docs-heading-anchor-permalink" href="#MatrixBandwidth.Minimization.Metaheuristic-(Public)" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Minimization.Metaheuristic"><a class="docstring-binding" href="#MatrixBandwidth.Minimization.Metaheuristic"><code>MatrixBandwidth.Minimization.Metaheuristic</code></a> — <span class="docstring-category">Module</span></summary><section><div><pre><code class="language-julia hljs">MatrixBandwidth.Minimization.Metaheuristic</code></pre><p>Metaheuristic solvers for matrix bandwidth minimization.</p><p>Metaheuristic methods are those which employ higher-level iterative search frameworks such as stochastic techniques or nature-inspired processes to survey the global search space and escape local minima. Unlike heuristic methods—which follow fixed deterministic procedures—metaheuristics adaptively refine candidate solutions over multiple iterations. Although metaheuristic approaches are often slower than heuristic ones (but certainly still faster than exact ones), they shine in complex cases where the latter may get trapped in poor-quality local minima.</p><p>No metaheuristic matrix bandwidth minimization algorithms are already implemented, but several (e.g., simulated annealing) are currently under development.</p><p>This submodule is part of the <code>MatrixBandwidth.Minimization</code> submodule of the <a href="https://github.com/Luis-Varona/MatrixBandwidth.jl">MatrixBandwidth.jl</a> package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Minimization/Metaheuristic/Metaheuristic.jl#L7-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Minimization.Metaheuristic.AntColony"><a class="docstring-binding" href="#MatrixBandwidth.Minimization.Metaheuristic.AntColony"><code>MatrixBandwidth.Minimization.Metaheuristic.AntColony</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AntColony &lt;: MetaheuristicSolver &lt;: AbstractSolver &lt;: AbstractAlgorithm</code></pre><p>[TODO: Write here]</p><p><strong>Supertype Hierarchy</strong></p><p><code>AntColony</code> &lt;: <a href="#MatrixBandwidth.Minimization.Metaheuristic.MetaheuristicSolver"><code>MetaheuristicSolver</code></a> &lt;: <a href="#MatrixBandwidth.Minimization.AbstractSolver"><code>AbstractSolver</code></a> &lt;: <a href="#MatrixBandwidth.AbstractAlgorithm"><code>MatrixBandwidth.AbstractAlgorithm</code></a></p><p>[TODO: Write here]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Minimization/Metaheuristic/solvers/ant_colony.jl#L7-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Minimization.Metaheuristic.GRASP"><a class="docstring-binding" href="#MatrixBandwidth.Minimization.Metaheuristic.GRASP"><code>MatrixBandwidth.Minimization.Metaheuristic.GRASP</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GRASP &lt;: MetaheuristicSolver &lt;: AbstractSolver &lt;: AbstractAlgorithm</code></pre><p>[TODO: Write here]</p><p><strong>Supertype Hierarchy</strong></p><p><code>GRASP</code> &lt;: <a href="#MatrixBandwidth.Minimization.Metaheuristic.MetaheuristicSolver"><code>MetaheuristicSolver</code></a> &lt;: <a href="#MatrixBandwidth.Minimization.AbstractSolver"><code>AbstractSolver</code></a> &lt;: <a href="#MatrixBandwidth.AbstractAlgorithm"><code>MatrixBandwidth.AbstractAlgorithm</code></a></p><p>[TODO: Write here]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Minimization/Metaheuristic/solvers/grasp.jl#L7-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Minimization.Metaheuristic.GeneticAlgorithm"><a class="docstring-binding" href="#MatrixBandwidth.Minimization.Metaheuristic.GeneticAlgorithm"><code>MatrixBandwidth.Minimization.Metaheuristic.GeneticAlgorithm</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GeneticAlgorithm &lt;: MetaheuristicSolver &lt;: AbstractSolver &lt;: AbstractAlgorithm</code></pre><p>[TODO: Write here]</p><p><strong>Supertype Hierarchy</strong></p><p><code>GeneticAlgorithm</code> &lt;: <a href="#MatrixBandwidth.Minimization.Metaheuristic.MetaheuristicSolver"><code>MetaheuristicSolver</code></a> &lt;: <a href="#MatrixBandwidth.Minimization.AbstractSolver"><code>AbstractSolver</code></a> &lt;: <a href="#MatrixBandwidth.AbstractAlgorithm"><code>MatrixBandwidth.AbstractAlgorithm</code></a></p><p>[TODO: Write here]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Minimization/Metaheuristic/solvers/genetic_algorithm.jl#L7-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Minimization.Metaheuristic.MetaheuristicSolver"><a class="docstring-binding" href="#MatrixBandwidth.Minimization.Metaheuristic.MetaheuristicSolver"><code>MatrixBandwidth.Minimization.Metaheuristic.MetaheuristicSolver</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MetaheuristicSolver &lt;: AbstractSolver &lt;: AbstractAlgorithm</code></pre><p>Abstract type for all metaheuristic matrix bandwidth minimization solvers.</p><p>Metaheuristic methods are those which employ higher-level iterative search frameworks such as stochastic techniques or nature-inspired processes to survey the global search space and escape local minima. Unlike heuristic methods—which follow fixed deterministic procedures—metaheuristics adaptively refine candidate solutions over multiple iterations. Although metaheuristic approaches are often slower than heuristic ones (but certainly still faster than exact ones), they shine in complex cases where the latter may get trapped in poor-quality local minima.</p><p><strong>Supertype Hierarchy</strong></p><p><code>MetaheuristicSolver</code> &lt;: <a href="#MatrixBandwidth.Minimization.AbstractSolver"><code>AbstractSolver</code></a> &lt;: <a href="#MatrixBandwidth.AbstractAlgorithm"><code>MatrixBandwidth.AbstractAlgorithm</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Minimization/Metaheuristic/types.jl#L7-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Minimization.Metaheuristic.PSOHC"><a class="docstring-binding" href="#MatrixBandwidth.Minimization.Metaheuristic.PSOHC"><code>MatrixBandwidth.Minimization.Metaheuristic.PSOHC</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PSOHC &lt;: MetaheuristicSolver &lt;: AbstractSolver &lt;: AbstractAlgorithm</code></pre><p>[TODO: Write here]</p><p><strong>Supertype Hierarchy</strong></p><p><code>PSOHC</code> &lt;: <a href="#MatrixBandwidth.Minimization.Metaheuristic.MetaheuristicSolver"><code>MetaheuristicSolver</code></a> &lt;: <a href="#MatrixBandwidth.Minimization.AbstractSolver"><code>AbstractSolver</code></a> &lt;: <a href="#MatrixBandwidth.AbstractAlgorithm"><code>MatrixBandwidth.AbstractAlgorithm</code></a></p><p>[TODO: Write here]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Minimization/Metaheuristic/solvers/psohc.jl#L7-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Minimization.Metaheuristic.SimulatedAnnealing"><a class="docstring-binding" href="#MatrixBandwidth.Minimization.Metaheuristic.SimulatedAnnealing"><code>MatrixBandwidth.Minimization.Metaheuristic.SimulatedAnnealing</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SimulatedAnnealing &lt;: MetaheuristicSolver &lt;: AbstractSolver &lt;: AbstractAlgorithm</code></pre><p>[TODO: Write here]</p><p><strong>Supertype Hierarchy</strong></p><p><code>SimulatedAnnealing</code> &lt;: <a href="#MatrixBandwidth.Minimization.Metaheuristic.MetaheuristicSolver"><code>MetaheuristicSolver</code></a> &lt;: <a href="#MatrixBandwidth.Minimization.AbstractSolver"><code>AbstractSolver</code></a> &lt;: <a href="#MatrixBandwidth.AbstractAlgorithm"><code>MatrixBandwidth.AbstractAlgorithm</code></a></p><p>[TODO: Write here]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Minimization/Metaheuristic/solvers/simulated_annealing.jl#L7-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Minimization.Metaheuristic.TabuSearch"><a class="docstring-binding" href="#MatrixBandwidth.Minimization.Metaheuristic.TabuSearch"><code>MatrixBandwidth.Minimization.Metaheuristic.TabuSearch</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TabuSearch &lt;: MetaheuristicSolver &lt;: AbstractSolver &lt;: AbstractAlgorithm</code></pre><p>[TODO: Write here]</p><p><strong>Supertype Hierarchy</strong></p><p><code>TabuSearch</code> &lt;: <a href="#MatrixBandwidth.Minimization.Metaheuristic.MetaheuristicSolver"><code>MetaheuristicSolver</code></a> &lt;: <a href="#MatrixBandwidth.Minimization.AbstractSolver"><code>AbstractSolver</code></a> &lt;: <a href="#MatrixBandwidth.AbstractAlgorithm"><code>MatrixBandwidth.AbstractAlgorithm</code></a></p><p>[TODO: Write here]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Minimization/Metaheuristic/solvers/tabu_search.jl#L7-L16">source</a></section></details></article><h2 id="MatrixBandwidth.Recognition-(Public)"><a class="docs-heading-anchor" href="#MatrixBandwidth.Recognition-(Public)"><code>MatrixBandwidth.Recognition</code> (Public)</a><a id="MatrixBandwidth.Recognition-(Public)-1"></a><a class="docs-heading-anchor-permalink" href="#MatrixBandwidth.Recognition-(Public)" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Recognition"><a class="docstring-binding" href="#MatrixBandwidth.Recognition"><code>MatrixBandwidth.Recognition</code></a> — <span class="docstring-category">Module</span></summary><section><div><pre><code class="language-julia hljs">MatrixBandwidth.Recognition</code></pre><p>Algorithms for matrix bandwidth recognition in Julia.</p><p>The <em>bandwidth</em> of an <span>$n×n$</span> matrix <span>$A$</span> is the minimum non-negative integer <span>$k ∈ \{0, 1, …, n - 1\}$</span> such that <span>$A[i, j] = 0$</span> whenever <span>$|i - j| &gt; k$</span>. The <em>matrix bandwidth recognition problem</em> entails determining whether there exists a permutation matrix <span>$P$</span> such that the bandwidth of <span>$PAPᵀ$</span> is at most some fixed non-negative integer (an optimal permutation that fully minimizes the bandwidth of <span>$A$</span> is not required).</p><p>The following matrix bandwidth recognition algorithms are currently available:</p><ul><li>Del Corso–Manzini (<a href="#MatrixBandwidth.Recognition.DelCorsoManzini"><code>DelCorsoManzini</code></a>)</li><li>Del Corso–Manzini with perimeter search (<a href="#MatrixBandwidth.Recognition.DelCorsoManziniWithPS"><code>DelCorsoManziniWithPS</code></a>)</li><li>Caprara–Salazar-González (<a href="#MatrixBandwidth.Recognition.CapraraSalazarGonzalez"><code>CapraraSalazarGonzalez</code></a>)</li><li>Saxe–Gurari–Sudborough (<a href="#MatrixBandwidth.Recognition.SaxeGurariSudborough"><code>SaxeGurariSudborough</code></a>)</li><li>Brute-force search (<a href="#MatrixBandwidth.Recognition.BruteForceSearch"><code>BruteForceSearch</code></a>)</li></ul><p>This submodule is part of the <a href="https://github.com/Luis-Varona/MatrixBandwidth.jl">MatrixBandwidth.jl</a> package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Recognition/Recognition.jl#L7-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Recognition.AbstractDecider"><a class="docstring-binding" href="#MatrixBandwidth.Recognition.AbstractDecider"><code>MatrixBandwidth.Recognition.AbstractDecider</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractDecider &lt;: AbstractAlgorithm</code></pre><p>Abstract base type for all matrix bandwidth recognition deciders.</p><p><strong>Interface</strong></p><p>As per the interface of supertype <a href="#MatrixBandwidth.AbstractAlgorithm"><code>AbstractAlgorithm</code></a>, concrete subtypes of <code>AbstractDecider</code> must implement the following methods:</p><ul><li><code>Base.summary(::T) where {T&lt;:AbstractDecider}</code>: returns a <code>String</code> indicating the name   of the decider (e.g., <code>&quot;Caprara–Salazar-González&quot;</code>).</li><li><code>_requires_structural_symmetry(::T) where {T&lt;:AbstractDecider}</code>: returns a <code>Bool</code>   indicating whether the decider requires the input matrix to be structurally symmetric.</li></ul><p><strong>Supertype Hierarchy</strong></p><p><code>AbstractDecider</code> &lt;: <a href="#MatrixBandwidth.AbstractAlgorithm"><code>AbstractAlgorithm</code></a></p><p><strong>Notes</strong></p><p>To implement a new matrix bandwidth recognition algorithm, define a new concrete subtype of <code>AbstractDecider</code> then implement a corresponding <code>_has_bandwidth_k_ordering_impl(::AbstractMatrix{Bool}, ::Integer, ::NewDeciderType)</code> method. Do <em>not</em> attempt to directly implement a new <a href="#MatrixBandwidth.Recognition.has_bandwidth_k_ordering"><code>has_bandwidth_k_ordering</code></a> method, as the function contains common preprocessing logic independent of the specific algorithm used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Recognition/types.jl#L7-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Recognition.BruteForceSearch"><a class="docstring-binding" href="#MatrixBandwidth.Recognition.BruteForceSearch"><code>MatrixBandwidth.Recognition.BruteForceSearch</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BruteForceSearch &lt;: AbstractDecider &lt;: AbstractAlgorithm</code></pre><p>The simplest method for determining, given some fixed <span>$k ∈ ℕ$</span>, whether a matrix has bandwidth at most <span>$k$</span> up to symmetric permutation is to iterate over all orderings and compute the bandwidth induced by each.</p><p>Since <span>$i₁, i₂, … iₙ$</span> induces the same bandwidth as <span>$iₙ, iₙ₋₁, … i₁$</span>, we restrict our search to orderings such that <span>$i₁ ≤ iₙ$</span> (with equality checked just in case <span>$n = 1$</span>).</p><p>If a bandwidth-<span>$k$</span> ordering is found, the algorithm breaks early instead of continuing to check subsequent permutations.</p><p><strong>Supertype Hierarchy</strong></p><p><code>BruteForceSearch</code> &lt;: <a href="#MatrixBandwidth.Recognition.AbstractDecider"><code>AbstractDecider</code></a> &lt;: <a href="#MatrixBandwidth.AbstractAlgorithm"><code>AbstractAlgorithm</code></a></p><p><strong>Performance</strong></p><p>Given an <span>$n×n$</span> input matrix, this brute-force algorithm runs in <span>$O(n! ⋅ n²)$</span> time:</p><ul><li>Up to <span>$n!/2$</span> permutations may be checked (except when <span>$n = 1$</span>, in which case   <span>$1! = 1$</span> permutation is checked). This is, clearly, <span>$O(n!)$</span>.</li><li>For each permutation, the <a href="#MatrixBandwidth.bandwidth-Tuple{AbstractMatrix{&lt;:Number}}"><code>bandwidth</code></a> function is called on <code>view(A, perm, perm)</code>,   which takes <span>$O(n²)$</span> time.</li><li>Therefore, the overall time complexity is <span>$O(n! ⋅ n²)$</span>.</li></ul><p><strong>Examples</strong></p><p>In many cases, the algorithm iterates over all (if <span>$k$</span> is smaller than the true minimu bandwidth) or almost all (if <span>$k$</span> is equally to or only slightly larger than the true minimum) possible permutations—in these cases, it is infeasible to go above <span>$9×9$</span> or <span>$10×10$</span> without incurring multiple-hour runtimes. (Even when <span>$k$</span> is considerably larger than the true minimum, it is unlikely that a bandwidth-<span>$k$</span> ordering will be found in a reasonable time frame.) Nevertheless, we see that it is quite effective for, say, <span>$8×8$</span>:</p><pre><code class="language- hljs">using Random, SparseArrays
Random.seed!(314159);
(n, p) = (8, 0.5);
A = sprand(n, n, p);
A = A + A&#39; # Ensure structural symmetry;
(k_false, k_true) = (3, 5);
has_bandwidth_k_ordering(A, k_false, Recognition.BruteForceSearch())
has_bandwidth_k_ordering(A, k_true, Recognition.BruteForceSearch())</code></pre><p><strong>Notes</strong></p><p>Brute force is by far the slowest approach to matrix bandwidth minimization and should only be used in very niche cases (like verifying the correctness of other algorithms in unit tests). For <span>$10×10$</span> matrices, the algorithm already takes several minutes to run for difficult values of <span>$k$</span> (namely, values below or only slightly above the true minimum) and allocates several gigabytes of memory. Given the <span>$O(n! ⋅ n²)$</span> time complexity, checking &quot;bandwidth ≤ k&quot; would take over an hour for many <span>$11×11$</span> matrices.</p><p>This holds true even when <span>$k$</span> is considerably larger than the true minimum bandwidth—as long as it remains below the bandwidth induced by the original ordering, it is unlikely that a bandwidth-<span>$k$</span> ordering will be found early simply by random chance. Additionally, time complexity will remain on the order of <span>$n! ⋅ n²$</span> in the average case.</p><p>See also <a href="#MatrixBandwidth.Minimization.Exact.BruteForceSearch"><code>MatrixBandwidth.Minimization.Exact.BruteForceSearch</code></a> for the minimization variant of this algorithm (which simply never breaks early, instead iterating over all permutations up to reversal to ensure that the minimum bandwidth is found).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Recognition/deciders/brute_force_search.jl#L7-L65">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Recognition.CapraraSalazarGonzalez"><a class="docstring-binding" href="#MatrixBandwidth.Recognition.CapraraSalazarGonzalez"><code>MatrixBandwidth.Recognition.CapraraSalazarGonzalez</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CapraraSalazarGonzalez &lt;: AbstractDecider &lt;: AbstractAlgorithm</code></pre><p>The <em>Caprara–Salazar-González recognition algorithm</em> is a method for determining, given some fixed <span>$k ∈ ℕ$</span>, whether a structurally symmetric matrix <span>$A$</span> has a bandwidth at most <span>$k$</span> up to symmetric permutation. The algorithm performs a depth-first search of all partial orderings of the rows and columns of <span>$A$</span>, adding indices one at a time. Partial orderings are pruned not only by ensuring that adjacent pairs of currently placed indices are within <span>$k$</span> of each other but also by employing a branch-and-bound framework with lower bounds on bandwidth compatibility computed via integer linear programming relaxations. This search is repeated with incrementing values of <span>$k$</span> until a bandwidth-<span>$k$</span> ordering is found [CS05], with <span>$k$</span> initialized to some lower bound on the minimum bandwidth of <span>$A$</span> up to symmetric permutation.</p><p>As noted above, the Caprara–Salazar-González algorithm requires structurally symmetric input (that is, <span>$A[i, j]$</span> must be nonzero if and only if <span>$A[j, i]$</span> is nonzero for <span>$1 ≤ i, j ≤ n$</span>).</p><p><strong>Supertype Hierarchy</strong></p><p><code>CapraraSalazarGonzalez</code> &lt;: <a href="#MatrixBandwidth.Recognition.AbstractDecider"><code>AbstractDecider</code></a> &lt;: <a href="#MatrixBandwidth.AbstractAlgorithm"><code>AbstractAlgorithm</code></a></p><p><strong>Performance</strong></p><p>Given an <span>$n×n$</span> input matrix and threshold bandwidth <span>$k$</span>, the Caprara–Salazar-González algorithm runs in <span>$O(n! ⋅ Tᵢₗₚ(n, n²))$</span> time, where <span>$Tᵢₗₚ(n, m)$</span> is the time taken to solve an integer linear programming (ILP) problem with <span>$O(n)$</span> variables and <span>$O(m)$</span> constraints:</p><ul><li>We perform a depth-first search of <span>$O(n!)$</span> partial orderings.</li><li>At each search node, we solve ILP relaxations with <span>$n$</span> variables and <span>$O(n²)$</span>   constraints (given by the number of nonzero entries in the computed distance matrix),   taking <span>$Tᵢₗₚ(n, n²)$</span> time. (This dominates the <span>$O(n²)$</span> auxiliary computations needed   to set up the ILP.)</li><li>Therefore, the overall time complexity is <span>$O(n! ⋅ Tᵢₗₚ(n, n²))$</span>.</li></ul><p>Note that <span>$Tᵢₗₚ(n, n²)$</span> has worst-case complexity <span>$O(2ⁿ)$</span>, although this ultimately depends on the ILP solver used. (Here, we use the HiGHS solver from the <code>HiGHS.jl</code> package.)</p><p>Of course, this is all but an upper bound on the time complexity of Caprara–Salazar-González, achieved only in the most pathological of cases. In practice, efficient pruning techniques and compatibility checks result in approximately exponential growth in time complexity with respect to <span>$n$</span>.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using Random, SparseArrays
Random.seed!(17);
(n, p) = (10, 0.17);
A = sprand(n, n, p);
A = A + A&#39; # Ensure structural symmetry;
(k_false, k_true) = (3, 6);
has_bandwidth_k_ordering(A, k_false, Recognition.CapraraSalazarGonzalez())
has_bandwidth_k_ordering(A, k_true, Recognition.CapraraSalazarGonzalez())</code></pre><p><strong>Notes</strong></p><p>For readers of the original paper, what we call the Caprara–Salazar-González algorithm here is designated the <code>LAYOUT_LEFT_TO_RIGHT</code> algorithm in [CS05]. The paper also describes a <code>LAYOUT_BOTH_WAYS</code> algorithm that performs a bidirectional search by adding indices to both the left and right ends of the current partial ordering. However, this version is considerably more complex to implement, and we ran into problems enforcing ILP constraints on node pairs added to opposite ends of the ordering. In any case, computational results demonstrate that neither <code>LAYOUT_LEFT_TO_RIGHT</code> nor <code>LAYOUT_BOTH_WAYS</code> is consistently faster, and the paper states that there is no known heuristic for determining which version will be more performant for a given input [CS05, pp. 368–69]. Therefore, we opt to implement only <code>LAYOUT_LEFT_TO_RIGHT</code> as a matter of practicality, although future developers may wish to extend the interface with <code>LAYOUT_BOTH_WAYS</code> as well.</p><p>Do also note that this algorithm is not the main <code>LAYOUT_LEFT_TO_RIGHT</code> procedure described in the original paper, which actually never explicitly tackles matrix bandwidth recognition [CS05]. However, the <code>LAYOUT_LEFT_TO_RIGHT</code> algorithm presented therein for bandwidth <em>minimization</em> does repeatedly call a recognition subroutine—this is precisely the logic we implement here. (We do, however, also implement said minimization algorithm in <a href="#MatrixBandwidth.Minimization.Exact.CapraraSalazarGonzalez"><code>MatrixBandwidth.Minimization.Exact.CapraraSalazarGonzalez</code></a>.)</p><p>A final implementation detail worth noting is that we use HiGHS as our solver; it is one of the fastest open-source solvers available for mixed-integer linear programming.</p><p><strong>References</strong></p><ul><li>[<a href="#CS05">CS05</a>]: A. Caprara and J.-J. Salazar-González. <em>Laying Out Sparse Graphs with   Provably Minimum Bandwidth</em>. INFORMS Journal on Computing <strong>17</strong>, 356–73 (2005).   https://doi.org/10.1287/ijoc.1040.0083.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Recognition/deciders/caprara_salazar_gonzalez.jl#L7-L88">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Recognition.DelCorsoManzini"><a class="docstring-binding" href="#MatrixBandwidth.Recognition.DelCorsoManzini"><code>MatrixBandwidth.Recognition.DelCorsoManzini</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DelCorsoManzini &lt;: AbstractDecider &lt;: AbstractAlgorithm</code></pre><p>The <em>Del Corso–Manzini recognition algorithm</em> is a method for determining, given some fixed <span>$k ∈ ℕ$</span>, whether a structurally symmetric matrix <span>$A$</span> has bandwidth at most <span>$k$</span> up to symmetric permutation. The algorithm performs a depth-first search of all partial orderings of the rows and columns of <span>$A$</span>, adding indices one at a time. Partial orderings are pruned not only by ensuring that adjacent pairs of currently placed indices are within <span>$k$</span> of each other but also by tracking the latest positions at which the remaining indices can be placed [DM99].</p><p>As noted above, the Del Corso–Manzini algorithm requires structurally symmetric input (that is, <span>$A[i, j]$</span> must be nonzero if and only if <span>$A[j, i]$</span> is nonzero for <span>$1 ≤ i, j ≤ n$</span>).</p><p><strong>Supertype Hierarchy</strong></p><p><code>DelCorsoManzini</code> &lt;: <a href="#MatrixBandwidth.Recognition.AbstractDecider"><code>AbstractDecider</code></a> &lt;: <a href="#MatrixBandwidth.AbstractAlgorithm"><code>AbstractAlgorithm</code></a></p><p><strong>Performance</strong></p><p>Given an <span>$n×n$</span> input matrix and threshold bandwidth <span>$k$</span>, the Del Corso–Manzini algorithm runs in <span>$O(n! ⋅ nk)$</span> time:</p><ul><li>We perform a depth-first search of <span>$O(n!)$</span> partial orderings.</li><li>Checking plausibility of each partial ordering takes <span>$O(nk)$</span> time.</li><li>Therefore, the overall time complexity is <span>$O(n! ⋅ nk)$</span>.</li></ul><p>Of course, this is but an upper bound on the time complexity of Del Corso–Manzini, achieved only in the most pathological of cases. In practice, efficient pruning techniques and compatibility checks result in approximately exponential growth in time complexity with respect to <span>$n$</span>.</p><p>Based on experimental results, the algorithm is feasible for <span>$n×n$</span> matrices up to <span>$n ≈ 100$</span> or so.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using Random, SparseArrays
Random.seed!(7878);
(n, p) = (40, 0.1);
A = sprand(n, n, p);
A = A + A&#39; # Ensure structural symmetry;
(k_false, k_true) = (13, 26);
has_bandwidth_k_ordering(A, k_false, Recognition.DelCorsoManzini())
has_bandwidth_k_ordering(A, k_true, Recognition.DelCorsoManzini())</code></pre><p><strong>Notes</strong></p><p>For readers of the original paper, what we call the Del Corso–Manzini recognition algorithm here is essentially a wrapper around the underlying <code>AddNode</code> subroutine in what [DM99, p. 191] term the &quot;MB-ID algorithm&quot; for bandwidth minimization (not mere recognition). MB-ID (which we also implement in <a href="#MatrixBandwidth.Minimization.Exact.DelCorsoManzini"><code>MatrixBandwidth.Minimization.Exact.DelCorsoManzini</code></a>) calls this recognition procedure with incrementing values of <span>$k$</span> until a bandwidth-<span>$k$</span> ordering is found, with <span>$k$</span> initialized to some lower bound on the minimum bandwidth of <span>$A$</span> up to symmetric permutation.</p><p>[DM99, p. 193] also describe an &quot;MB-PS algorithm&quot; for bandwidth minimization, which we implement in <a href="#MatrixBandwidth.Minimization.Exact.DelCorsoManziniWithPS"><code>MatrixBandwidth.Minimization.Exact.DelCorsoManziniWithPS</code></a>. Similarly, the underlying recognition subroutine for MB-PS is implemented in <a href="#MatrixBandwidth.Recognition.DelCorsoManziniWithPS"><code>DelCorsoManziniWithPS</code></a>.</p><p><strong>References</strong></p><ul><li>[<a href="#DM99">DM99</a>]: G. M. Del Corso and G. Manzini. <em>Finding Exact Solutions to the Bandwidth   Minimization Problem</em>. Computing <strong>62</strong>, 189–203 (1999).   https://doi.org/10.1007/s006070050002.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Recognition/deciders/del_corso_manzini.jl#L7-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Recognition.DelCorsoManziniWithPS"><a class="docstring-binding" href="#MatrixBandwidth.Recognition.DelCorsoManziniWithPS"><code>MatrixBandwidth.Recognition.DelCorsoManziniWithPS</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DelCorsoManziniWithPS{D} &lt;: AbstractDecider &lt;: AbstractAlgorithm</code></pre><p>The <em>Del Corso–Manzini recognition algorithm with perimeter search</em> is a method for determining, given some fixed <span>$k ∈ ℕ$</span>, whether a structurally symmetric matrix <span>$A$</span> has bandwidth at most <span>$k$</span> up to symmetric permutation. The base Del Corso–Manzini algorithm performs a depth-first search of all partial orderings of the rows and columns of <span>$A$</span>, adding indices one at a time. Partial orderings are pruned not only by ensuring that adjacent pairs of currently placed indices are within <span>$k$</span> of each other but also by tracking the latest positions at which the remaining indices can be placed [DM99].</p><p>The incorporation of perimeter search to this approach entails precomputing a &quot;perimeter&quot; of <span>$d$</span>-permutations of row indices of <span>$A$</span>, where <span>$d$</span> is a positive integer passed as a parameter to the decider. Each permutation represents a way to select the last <span>$d$</span> entries of the ordering, and as the construction of the partial ordering progresses, potential endings are pruned to exclude those incompatible with already placed indices. In addition to pruning a potential ending if it contains indices already placed, compatibility is also checked via precomputed time stamps indicating, for each potential ending, a loose lower bound on the earliest position at which any given index can be placed should said ending be selected.</p><p>As noted above, the Del Corso–Manzini algorithm with perimeter search requires structurally symmetric input (that is, <span>$A[i, j]$</span> must be nonzero if and only if <span>$A[j, i]$</span> is nonzero for <span>$1 ≤ i, j ≤ n$</span>).</p><p><strong>Fields</strong></p><ul><li><code>depth::D&lt;:Union{Nothing,Integer}</code>: the perimeter search depth. If this field is not set   (and thus automatically initialized to <code>nothing</code>), a default depth is computed by   <a href="../private_api/#MatrixBandwidth.Recognition.dcm_ps_optimal_depth-Tuple{AbstractMatrix{Bool}}"><code>dcm_ps_optimal_depth</code></a> as a function of the input matrix every time the decider   is passed to <a href="#MatrixBandwidth.Recognition.has_bandwidth_k_ordering"><code>has_bandwidth_k_ordering</code></a> as a function of the input matrix.   Otherwise, it must be manually set to a positive integer.</li></ul><p><strong>Constructors</strong></p><ul><li><code>DelCorsoManziniWithPS()</code>: constructs a new <code>DelCorsoManziniWithPS</code> instance with the   default perimeter search depth initialized to <code>nothing</code>.</li><li><code>DelCorsoManziniWithPS(depth::Integer)</code>: constructs a new <code>DelCorsoManziniWithPS</code> instance   with the specified perimeter search depth. <code>depth</code> must be a positive integer.</li></ul><p><strong>Supertype Hierarchy</strong></p><p><code>DelCorsoManziniWithPS</code> &lt;: <a href="#MatrixBandwidth.Recognition.AbstractDecider"><code>AbstractDecider</code></a> &lt;: <a href="#MatrixBandwidth.AbstractAlgorithm"><code>AbstractAlgorithm</code></a></p><p><strong>Performance</strong></p><p>Given an <span>$n×n$</span> input matrix, perimeter search depth <span>$d$</span>, and threshold bandwidth <span>$k$</span>, the Del Corso–Manzini algorithm with perimeter search runs in <span>$O(n! ⋅ max(nᵈ, nk))$</span> time:</p><ul><li>We perform a depth-first search of <span>$O(n!)$</span> partial orderings.</li><li>Checking plausibility of each partial ordering takes <span>$O(nk)$</span> time, and checking   compatibility with all size-<span>$d$</span> LPOs takes <span>$O(nᵈ)$</span> time. Thus, the overall time   complexity for each value of <span>$k$</span> is <span>$O(n! ⋅ (nᵈ + nk))$</span>.</li><li>Therefore, the overall time complexity is <span>$O(n! ⋅ max(nᵈ, nk))$</span>.</li></ul><p>Of course, this is but an upper bound on the time complexity of Del Corso–Manzini with perimeter search, achieved only in the most pathological of cases. In practice, efficient pruning techniques and compatibility checks result in approximately exponential growth in time complexity with respect to <span>$n$</span>.</p><p>Based on experimental results, the algorithm is feasible for <span>$n×n$</span> matrices up to <span>$n ≈ 100$</span> or so.</p><p><strong>Examples</strong></p><p>Here, Del Corso–Manzini with perimeter search ascertains that A random <span>$30×30$</span> matrix has a minimum bandwidth greater than <span>$9$</span>. The depth parameter is not explicitly set; instead, some near-optimal value is automatically computed upon the first <a href="#MatrixBandwidth.Recognition.has_bandwidth_k_ordering"><code>has_bandwidth_k_ordering</code></a> function call.</p><pre><code class="language- hljs">using Random, SparseArrays
Random.seed!(5847);
(n, p) = (30, 0.05);
A = sprand(n, n, p);
A = A + A&#39; # Ensure structural symmetry;
k = 6;
has_bandwidth_k_ordering(A, k, Recognition.DelCorsoManziniWithPS())</code></pre><p>Now, Del Corso–Manzini with perimeter search recognizes that a random <span>$35×35$</span> matrix has a minimum bandwidth at most <span>$8$</span>. In this case, we explicitly set the depth parameter to <span>$4$</span> beforehand instead of relying on <a href="../private_api/#MatrixBandwidth.Recognition.dcm_ps_optimal_depth-Tuple{AbstractMatrix{Bool}}"><code>Recognition.dcm_ps_optimal_depth</code></a>.</p><pre><code class="language- hljs">using Random, SparseArrays
Random.seed!(23552);
(n, p, depth) = (35, 0.02, 4);
A = sprand(n, n, p);
A = A + A&#39; # Ensure structural symmetry;
k = 8;
has_bandwidth_k_ordering(A, k, Recognition.DelCorsoManziniWithPS(depth))</code></pre><p><strong>Notes</strong></p><p>For readers of the original paper, what we call the Del Corso–Manzini recognition algorithm with perimeter search here is essentially a wrapper around the underlying <code>AddNode1</code> and <code>Prune</code> subroutines in what [DM99, p. 193] term the &quot;MB-PS algorithm&quot; for bandwidth minimization (not mere recognition). MB-PS (which we also implement in <a href="#MatrixBandwidth.Minimization.Exact.DelCorsoManziniWithPS"><code>MatrixBandwidth.Minimization.Exact.DelCorsoManziniWithPS</code></a>) calls this recognition procedure with incrementing values of <span>$k$</span> until a bandwidth-<span>$k$</span> ordering is found, with <span>$k$</span> initialized to some lower bound on the minimum bandwidth of <span>$A$</span> up to symmetric permutation.</p><p>[DM99, p. 191] also describe an &quot;MB-ID algorithm&quot; for bandwidth minimization, which we implement in <a href="#MatrixBandwidth.Minimization.Exact.DelCorsoManzini"><code>MatrixBandwidth.Minimization.Exact.DelCorsoManzini</code></a>. Similarly, the underlying recognition subroutine for MB-ID is implemented in <a href="#MatrixBandwidth.Recognition.DelCorsoManzini"><code>DelCorsoManzini</code></a>.</p><p><strong>References</strong></p><ul><li>[<a href="#DM99">DM99</a>]: G. M. Del Corso and G. Manzini. <em>Finding Exact Solutions to the Bandwidth   Minimization Problem</em>. Computing <strong>62</strong>, 189–203 (1999).   https://doi.org/10.1007/s006070050002.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Recognition/deciders/del_corso_manzini.jl#L79-L183">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Recognition.RecognitionResult"><a class="docstring-binding" href="#MatrixBandwidth.Recognition.RecognitionResult"><code>MatrixBandwidth.Recognition.RecognitionResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RecognitionResult{A,M,O} &lt;: AbstractResult</code></pre><p>Output struct for matrix bandwidth recognition results.</p><p><strong>Fields</strong></p><ul><li><code>algorithm::A&lt;:AbstractDecider</code>: the decider used to test the bandwidth.</li><li><code>matrix::M&lt;:AbstractMatrix{&lt;:Number}</code>: the original matrix whose bandwidth is tested.</li><li><code>ordering::O&lt;:Union{Nothing,Vector{Int}}</code>: an ordering of the rows and columns of <code>matrix</code>   inducing a bandwidth at most <code>k</code>, if such an ordering exists; otherwise, <code>nothing</code>.</li><li><code>k::Integer</code>: the threshold bandwidth against which to test.</li><li><code>has_ordering::Bool</code>: whether the matrix has an ordering inducing a bandwidth at most <code>k</code>.   (This is <code>true</code> if and only if <code>ordering</code> is not <code>nothing</code>.)</li></ul><p><strong>Constructors</strong></p><ul><li><code>RecognitionResult(decider, matrix, ordering, k)</code>: constructs a new <code>RecognitionResult</code>   instance with the given fields. The <code>has_ordering</code> field is automatically determined   based on whether <code>ordering</code> is <code>nothing</code> or a <code>Vector{Int}</code>.</li></ul><p><strong>Supertype Hierarchy</strong></p><p><code>RecognitionResult</code> &lt;: <a href="#MatrixBandwidth.AbstractResult"><code>AbstractResult</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Recognition/types.jl#L35-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Recognition.SaxeGurariSudborough"><a class="docstring-binding" href="#MatrixBandwidth.Recognition.SaxeGurariSudborough"><code>MatrixBandwidth.Recognition.SaxeGurariSudborough</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SaxeGurariSudborough &lt;: AbstractDecider &lt;: AbstractAlgorithm</code></pre><p>The <em>Saxe–Gurari–Sudborough recognition algorithm</em> is a method for determining, given some fixed <span>$k ∈ ℕ$</span>, whether a structurally symmetric matrix <span>$A$</span> has bandwidth at most <span>$k$</span> up to symmetric permutation. The algorithm employs dynamic programming to search over equivalence classes of partial orderings, where two partial orderings of length <span>$l$</span> are equivalent if they share the same <em>active region</em>. (The active region of a partial ordering is defined as the sequence of the last <span>$min(k, l)$</span> vertices in the ordering taken together with all <em>dangling edges</em>—edges with one endpoint in the ordering and the other endpoint not yet in the ordering.) It extends these partial layouts one vertex at a time in a breadth-first manner, pruning implausible classes that violate bandwidth-<span>$k$</span> constraints such as degree bounds on active vertices and excessive numbers of dangling edges [GS84].</p><p>As noted above, the Saxe–Gurari–Sudborough algorithm requires structurally symmetric input (that is, <span>$A[i, j]$</span> must be nonzero if and only if <span>$A[j, i]$</span> is nonzero for <span>$1 ≤ i, j ≤ n$</span>).</p><p><strong>Supertype Hierarchy</strong></p><p><code>SaxeGurariSudborough</code> &lt;: <a href="#MatrixBandwidth.Recognition.AbstractDecider"><code>AbstractDecider</code></a> &lt;: <a href="#MatrixBandwidth.AbstractAlgorithm"><code>AbstractAlgorithm</code></a></p><p><strong>Performance</strong></p><p>Given an <span>$n×n$</span> input matrix and threshold bandwidth <span>$k$</span>, the Saxe–Gurari–Sudborough algorithm runs in <span>$O(nᵏ)$</span> time [GS84, p. 531]. This is an improvement upon the original <span>$O(nᵏ⁺¹)$</span> Saxe algorithm [Sax80, p. 363]. (Of course, when <span>$k &lt; 3$</span>, then the initial <span>$O(n³)$</span> bandwidth lower bound computation performed in all <a href="#MatrixBandwidth.Recognition.has_bandwidth_k_ordering"><code>has_bandwidth_k_ordering</code></a> calls dominates the overall complexity, although the constant scaling factor of that subroutine is generally much smaller than that of the algorithm proper).</p><p>Whereas most bandwidth recognition algorithms are technically factorial-time (with respect to <span>$n$</span>) in the worst case but practically always approximate exponential time complexity in real life (see: <a href="#MatrixBandwidth.Recognition.DelCorsoManzini"><code>DelCorsoManzini</code></a>), the <span>$O(nᵏ)$</span> upper bound on Saxe–Gurari–Sudborough is typically a good representation of actual performance in most cases. Indeed, these other types of algorithms tend to outperform Saxe–Gurari–Sudborough for larger <span>$k$</span>, given that their aggressive pruning strategies keep their effective search space very small in practice.</p><p><strong>Examples</strong></p><pre><code class="language- hljs">using Random, SparseArrays
Random.seed!(274);
(n, p) = (20, 0.08);
A = sprand(n, n, p);
A = A + A&#39; # Ensure structural symmetry;
(k_false, k_true) = (3, 5);
has_bandwidth_k_ordering(A, k_false, Recognition.SaxeGurariSudborough())
has_bandwidth_k_ordering(A, k_true, Recognition.SaxeGurariSudborough())</code></pre><p><strong>Notes</strong></p><p>This general family of bandwidth recognition algorithms was conceived as a response to a question posed by [GGJK78, p. 494]: is the &quot;bandwidth ≤ k?&quot; problem NP-complete for arbitrary <span>$k$</span>? [Sax80] answered this question in the negative by providing a <span>$O(nᵏ⁺¹)$</span> algorithm, constructively proving that the problem is class P. Later, [GS84] improved upon this algorithm by reducing time complexity to <span>$O(nᵏ)$</span>. Whereas the original Saxe algorithm considers extensions of partial orderings with any remaining unplaced vertex (of which there are <span>$O(n)$</span> at any point in the breadth-first search), the Gurari–Sudborough refinement only considers extensions with vertices reachable by paths beginning with a dangling edge that never again traverse a dangling edge [GS84, pp. 535–36].</p><p><strong>References</strong></p><ul><li>[<a href="#GGJK78">GGJK78</a>]: M. R. Garey, R. L. Graham, D. S. Johnson and D. E. Knuth. <em>Complexity   Results for Bandwidth Minimization</em>. SIAM Journal on Applied Mathematics <strong>34</strong>, 477–95   (1978). https://doi.org/10.1137/0134037.</li><li>[<a href="#GS84">GS84</a>]: E. M. Gurari and I. H. Sudborough. <em>Improved dynamic programming algorithms   for bandwidth minimization and the MinCut Linear Arrangement problem</em>. Journal of   Algorithms <strong>5</strong>, 531–46 (1984). https://doi.org/10.1016/0196-6774(84)90006-3.</li><li>[<a href="#Sax80">Sax80</a>]: J. B. Saxe. <em>Dynamic-Programming Algorithms for Recognizing   Small-Bandwidth Graphs in Polynomial Time</em>. SIAM Journal on Algebraic and Discrete   Methods <strong>1</strong>, 363–69 (1980). https://doi.org/10.1137/0601042.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Recognition/deciders/saxe_gurari_sudborough.jl#L7-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MatrixBandwidth.Recognition.has_bandwidth_k_ordering"><a class="docstring-binding" href="#MatrixBandwidth.Recognition.has_bandwidth_k_ordering"><code>MatrixBandwidth.Recognition.has_bandwidth_k_ordering</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_bandwidth_k_ordering(A, k, decider=CapraraSalazarGonzalez()) -&gt; RecognitionResult</code></pre><p>Determine whether <code>A</code> has bandwidth at most <code>k</code> using the algorithm defined by <code>decider</code>.</p><p>The <em>bandwidth</em> of an <span>$n×n$</span> matrix <span>$A$</span> is the minimum non-negative integer <span>$k ∈ \{0, 1, …, n - 1\}$</span> such that <span>$A[i, j] = 0$</span> whenever <span>$|i - j| &gt; k$</span>.</p><p>Given some fixed non-negative integer <code>k</code>, this function determines (with 100% certainty) whether there exists some ordering <span>$π$</span> of the rows and columns of <span>$A$</span> such that the bandwidth of <span>$PAPᵀ$</span> is at most <code>k</code>, where <span>$P$</span> is the permutation matrix corresponding to <span>$π$</span>. This is known to be decidable in <span>$O(nᵏ)$</span> time, although some deciders (e.g., <a href="#MatrixBandwidth.Recognition.CapraraSalazarGonzalez"><code>CapraraSalazarGonzalez</code></a>) run in exponential time instead to produce even quicker runtimes in practice.</p><p>If <span>$k ≥ n - 1$</span>, then this function immediately answers in the affirmative, since the maximum possible bandwidth of an <span>$n×n$</span> matrix is <span>$n - 1$</span>. After this initial check, a preliminary lower bound on the bandwidth is computed in <span>$O(n³)$</span> time using results from Caprara and Salazar-González (2005). If this lower bound is greater than <span>$k$</span>`</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractMatrix{&lt;:Number}</code>: the (square) matrix whose bandwidth is tested.</li><li><code>k::Integer</code>: the threshold bandwidth against which to test.</li><li><code>decider::AbstractDecider</code>: the matrix bandwidth recognition algorithm to use; defaults to   <a href="#MatrixBandwidth.Recognition.CapraraSalazarGonzalez"><code>CapraraSalazarGonzalez</code></a>. (See the <a href="#MatrixBandwidth.Recognition"><code>Recognition</code></a> module documentation   for a full list of supported deciders.)</li></ul><p><strong>Returns</strong></p><ul><li><code>::RecognitionResult</code>: a struct containing the algorithm used, the original matrix <code>A</code>,   the identified ordering of the rows and columns (if one exists), the threshold bandwidth   <code>k</code>, and a boolean indicating whether the ordering exists.</li></ul><p><strong>Examples</strong></p><p>Multiple algorithms to decide whether a given matrix has bandwidth at most <code>k</code> are available. Naturally, they will always agree, but the final orderings produced (in the case of an affirmative) may differ:</p><pre><code class="language- hljs">using Random, SparseArrays
Random.seed!(52);
(n, p) = (8, 0.2);
A = sprand(Bool, n, n, p);
A = A .|| A&#39; # Ensure structural symmetry
k = 3;
res_csg = has_bandwidth_k_ordering(A, k, Recognition.CapraraSalazarGonzalez())
A[res_csg.ordering, res_csg.ordering]
res_sgs = has_bandwidth_k_ordering(A, k, Recognition.SaxeGurariSudborough())
A[res_sgs.ordering, res_sgs.ordering]</code></pre><p>If no decider is specified, then the Del Corso–Manzini algorithm is used by default:</p><pre><code class="language- hljs">using Random, SparseArrays
Random.seed!(174);
(n, p, k) = (20, 0.1, 4);
A = sprand(n, n, p);
A = A .+ A&#39; # Ensure structural symmetry;
has_bandwidth_k_ordering(A, k)</code></pre><p><strong>Notes</strong></p><p>To implement a new matrix bandwidth recognition algorithm, define a new concrete subtype of <a href="#MatrixBandwidth.Recognition.AbstractDecider"><code>AbstractDecider</code></a> then implement a corresponding <code>_has_bandwidth_k_ordering_impl(::AbstractMatrix{Bool}, ::Integer, ::NewDeciderType)</code> method. Do <em>not</em> attempt to directly implement a new <code>has_bandwidth_k_ordering</code> method, as the function contains common preprocessing logic independent of the specific algorithm used.</p><p>Note also that some texts define matrix bandwidth to be the minimum non-negative integer <span>$k$</span> such that <span>$A[i, j] = 0$</span> whenever <span>$|i - j| ≥ k$</span> instead, particularly in more mathematically-minded communities. Effectively, this definition treats diagonal matrices as bandwidth <span>$1$</span>, tridiagonal matrices as bandwidth <span>$2$</span>, and so on. Our definition, on the other hand, is more common in computer science contexts, treating diagonal matrices as bandwidth <span>$0$</span> and tridiagonal matrices as bandwidth <span>$1$</span>. (Both definitions, however, agree that the bandwidth of an empty matrix is simply <span>$0$</span>.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/ad5ba65f26aa4d2a06b9741c1768cbff91bd72f4/src/Recognition/core.jl#L7-L82">source</a></section></details></article><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><div class="citation canonical"><dl><dt>[CS05]</dt><dd><div id="CS05">A. Caprara and J.-J. Salazar-González. <a href="https://doi.org/10.1287/ijoc.1040.0083"><em>Laying Out Sparse Graphs with Provably Minimum Bandwidth</em></a>. INFORMS Journal on Computing <strong>17</strong>, 356–73 (2005).</div></dd><dt>[CG80]</dt><dd><div id="CG80">W. M. Chan and A. George. <a href="https://doi.org/10.1007/BF01933580"><em>A linear time implementation of the reverse Cuthill–McKee algorithm</em></a>. BIT Numerical Mathematics <strong>20</strong>, 8–14 (1980).</div></dd><dt>[CM69]</dt><dd><div id="CM69">E. Cuthill and J. McKee. <a href="https://doi.org/10.1145/800195.805928"><em>Reducing the bandwidth of sparse symmetric matrices</em></a>. In: <em>Proceedings of the 24th National Conference of the ACM</em> (Brandon Systems Press, 1969); pp. 157–72.</div></dd><dt>[DM99]</dt><dd><div id="DM99">G. M. Del Corso and G. Manzini. <a href="https://doi.org/10.1007/s006070050002"><em>Finding Exact Solutions to the Bandwidth Minimization Problem</em></a>. Computing <strong>62</strong>, 189–203 (1999).</div></dd><dt>[GGJK78]</dt><dd><div id="GGJK78">M. R. Garey, R. L. Graham, D. S. Johnson and D. E. Knuth. <a href="https://doi.org/10.1137/0134037"><em>Complexity Results for Bandwidth Minimization</em></a>. SIAM Journal on Applied Mathematics <strong>34</strong>, 477–95 (1978).</div></dd><dt>[Geo71]</dt><dd><div id="Geo71">J. A. George. <a href="https://apps.dtic.mil/sti/tr/pdf/AD0726171.pdf"><em>Computer Implementation of the Finite Element Method</em></a>. Ph.D. Thesis, Department of Computer Science, Stanford University (1971).</div></dd><dt>[GPS76]</dt><dd><div id="GPS76">N. E. Gibbs, W. G. Poole Jr. and P. K. Stockmeyer. <a href="https://doi.org/10.1137/0713023"><em>An Algorithm for Reducing the Bandwidth and Profile of a Sparse Matrix</em></a>. SIAM Journal on Numerical Analysis <strong>13</strong>, 236–50 (1976).</div></dd><dt>[GS84]</dt><dd><div id="GS84">E. M. Gurari and I. H. Sudborough. <a href="https://doi.org/10.1016/0196-6774(84)90006-3"><em>Improved dynamic programming algorithms for bandwidth minimization and the   MinCut Linear Arrangement problem</em></a>. <a href="https://doi.org/10.1016/0196-6774(84)90006-3">Journal of Algorithms <strong>5</strong>, 531–46</a> (1984).</div></dd><dt>[Lew82]</dt><dd><div id="Lew82">J. G. Lewis. <a href="https://doi.org/10.1145/355993.355998"><em>Implementation of the Gibbs–Poole–Stockmeyer and Gibbs–King Algorithms</em></a>. ACM Transactions on Mathematical Software <strong>8</strong>, 180–89 (1982).</div></dd><dt>[Maf14]</dt><dd><div id="Maf14">L. O. Mafteiu-Scai. <a href="https://doi.org/10.2478/awutm-2014-0019"><em>The Bandwidths of a Matrix. A Survey of Algorithms</em></a>. Annals of West University of Timisoara - Mathematics and Computer Science <strong>52</strong>, 183–223 (2014).</div></dd><dt>[Sax80]</dt><dd><div id="Sax80">J. B. Saxe. <a href="https://doi.org/10.1137/0601042"><em>Dynamic-Programming Algorithms for Recognizing Small-Bandwidth Graphs in   Polynomial Time</em></a>. SIAM Journal on Algebraic and Discrete Methods <strong>1</strong>, 363–69 (1980).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><a class="docs-footer-nextpage" href="../private_api/">Private API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 8 December 2025 07:22">Monday 8 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
