<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API · MatrixBandwidth.jl</title><meta name="title" content="Public API · MatrixBandwidth.jl"/><meta property="og:title" content="Public API · MatrixBandwidth.jl"/><meta property="twitter:title" content="Public API · MatrixBandwidth.jl"/><meta name="description" content="Documentation for MatrixBandwidth.jl."/><meta property="og:description" content="Documentation for MatrixBandwidth.jl."/><meta property="twitter:description" content="Documentation for MatrixBandwidth.jl."/><meta property="og:url" content="https://Luis-Varona.github.io/MatrixBandwidth.jl/public_api/"/><meta property="twitter:url" content="https://Luis-Varona.github.io/MatrixBandwidth.jl/public_api/"/><link rel="canonical" href="https://Luis-Varona.github.io/MatrixBandwidth.jl/public_api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/styles.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MatrixBandwidth.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Public API</a><ul class="internal"><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../private_api/">Private API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Public API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Luis-Varona/MatrixBandwidth.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/main/docs/src/public_api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="MatrixBandwidth.jl-–-Public-API"><a class="docs-heading-anchor" href="#MatrixBandwidth.jl-–-Public-API">MatrixBandwidth.jl – Public API</a><a id="MatrixBandwidth.jl-–-Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#MatrixBandwidth.jl-–-Public-API" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/Luis-Varona/MatrixBandwidth.jl">MatrixBandwidth</a>&#39;s public API.</p><div class="admonition is-info" id="Note-d315dd05c58bb28f"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d315dd05c58bb28f" title="Permalink"></a></header><div class="admonition-body"><p>The following documentation covers only the public API of the package. For internal details, see the <a href="../private_api/">private API documentation</a>.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.MatrixBandwidth" href="#MatrixBandwidth.MatrixBandwidth"><code>MatrixBandwidth.MatrixBandwidth</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MatrixBandwidth</code></pre><p>[TODO: Update to reflect recognition algorithms too]</p><p>Fast algorithms for matrix bandwidth minimization and matrix bandwidth recognition in Julia.</p><p>The <em>bandwidth</em> of a square matrix <span>$A$</span> is the minimum non-negative integer <span>$k ∈ ℕ$</span> such that <span>$A[i, j] = 0$</span> whenever <span>$|i - j| &gt; k$</span>. Equivalently, <span>$A$</span> has bandwidth <em>at most</em> <span>$k$</span> if all entries above the <span>$k$</span>-th superdiagonal and below the <span>$k$</span>-th subdiagonal are zero, and <span>$A$</span> has bandwidth <em>at least</em> <span>$k$</span> if there exists any nonzero entry in the <span>$k$</span>-th superdiagonal or subdiagonal.</p><p>The <em>matrix bandwidth minimization problem</em> involves finding a permutation matrix <span>$P$</span> such that the bandwidth of <span>$PAPᵀ$</span> is minimized; this is known to be NP-complete. Several heuristic algorithms (such as reverse Cuthill–McKee) run in polynomial time while still producing near-optimal orderings in practice, but exact methods (like Caprara–Salazar-González) are exponential in time complexity and thus are only feasible for relatively small matrices.</p><p>On the other hand, the <em>matrix bandwidth recognition problem</em> entails determining whether there exists a permutation matrix <span>$P$</span> such that the bandwidth of <span>$PAPᵀ$</span> is at most some fixed non-negative integer <span>$k ∈ ℕ$</span>—an optimal permutation that fully minimizes the bandwidth of <span>$A$</span> is not required. Unlike the NP-hard minimization problem, this is decidable in <span>$O(nᵏ)$</span> time, where <span>$n$</span> is the order of <span>$A$</span>.</p><p>The following algorithms are currently supported:</p><ul><li><strong>Minimization</strong><ul><li><em>Exact</em><ul><li>Caprara–Salazar-González algorithm (<a href="#MatrixBandwidth.Minimization.Exact.CapraraSalazarGonzalez"><code>Minimization.CapraraSalazarGonzalez</code></a>)</li><li>Del Corso–Manzini algorithm (<a href="#MatrixBandwidth.Minimization.Exact.DelCorsoManzini"><code>Minimization.DelCorsoManzini</code></a>)</li><li>Del Corso–Manzini algorithm with perimeter search (<a href="#MatrixBandwidth.Minimization.Exact.DelCorsoManziniWithPS"><code>Minimization.DelCorsoManziniWithPS</code></a>)</li><li>Saxe–Gurari–Sudborough algorithm (<a href="#MatrixBandwidth.Minimization.Exact.SaxeGurariSudborough"><code>Minimization.SaxeGurariSudborough</code></a>)</li></ul></li><li><em>Heuristic</em><ul><li>Gibbs–Poole–Stockmeyer algorithm (<a href="#MatrixBandwidth.Minimization.Heuristic.GibbsPooleStockmeyer"><code>Minimization.GibbsPooleStockmeyer</code></a>)</li><li>Cuthill–McKee algorithm (<a href="#MatrixBandwidth.Minimization.Heuristic.CuthillMcKee"><code>Minimization.CuthillMcKee</code></a>)</li><li>Reverse Cuthill–McKee algorithm (<a href="#MatrixBandwidth.Minimization.Heuristic.ReverseCuthillMcKee"><code>Minimization.ReverseCuthillMcKee</code></a>)</li></ul></li><li><em>Metaheuristic</em><ul><li>Greedy randomized adaptive search procedure (GRASP) (<a href="#MatrixBandwidth.Minimization.Metaheuristic.GRASP"><code>Minimization.GRASP</code></a>)</li><li>Simulated annealing (<a href="#MatrixBandwidth.Minimization.Metaheuristic.SimulatedAnnealing"><code>Minimization.SimulatedAnnealing</code></a>)</li><li>Genetic algorithm (<a href="#MatrixBandwidth.Minimization.Metaheuristic.GeneticAlgorithm"><code>Minimization.GeneticAlgorithm</code></a>)</li></ul></li></ul></li><li><strong>Recognition</strong><ul><li>Caprara–Salazar-González algorithm (<a href="#MatrixBandwidth.Recognition.CapraraSalazarGonzalez"><code>Recognition.CapraraSalazarGonzalez</code></a>)</li><li>Del Corso–Manzini algorith (<a href="#MatrixBandwidth.Recognition.DelCorsoManzini"><code>Recognition.DelCorsoManzini</code></a>)</li><li>Del Corso–Manzini algorithm with perimeter search (<a href="#MatrixBandwidth.Recognition.DelCorsoManziniWithPS"><code>Recognition.DelCorsoManziniWithPS</code></a>)</li><li>Saxe–Gurari–Sudborough algorithm (<a href="#MatrixBandwidth.Recognition.SaxeGurariSudborough"><code>Recognition.SaxeGurariSudborough</code></a>)</li></ul></li></ul><p><a href="https://Luis-Varona.github.io/MatrixBandwidth.jl/dev/">Full documentation</a> is available for the latest development version of this package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/MatrixBandwidth.jl#L7-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.bandwidth-Tuple{AbstractMatrix{&lt;:Number}}" href="#MatrixBandwidth.bandwidth-Tuple{AbstractMatrix{&lt;:Number}}"><code>MatrixBandwidth.bandwidth</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bandwidth(A) -&gt; Int</code></pre><p>Compute the bandwidth of <code>A</code> before any permutation of its rows and columns.</p><p>The <em>bandwidth</em> of a square matrix <span>$A$</span> is the minimum non-negative integer <span>$k ∈ ℕ$</span> such that <span>$A[i, j] = 0$</span> whenever <span>$|i - j| &gt; k$</span>. Equivalently, <span>$A$</span> has bandwidth <em>at most</em> <span>$k$</span> if all entries above the <span>$k$</span>-th superdiagonal and below the <span>$k$</span>-th subdiagonal are zero, and <span>$A$</span> has bandwidth <em>at least</em> <span>$k$</span> if there exists any nonzero entry in the <span>$k$</span>-th superdiagonal or subdiagonal.</p><p>In contrast to <a href="#MatrixBandwidth.Minimization.minimize_bandwidth"><code>minimize_bandwidth</code></a>, this function does not attempt to minimize the bandwidth of <code>A</code> by permuting its rows and columns—it simply computes its bandwidth as is.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractMatrix{&lt;:Number}</code>: the (square) matrix whose bandwidth is computed.</li></ul><p><strong>Returns</strong></p><ul><li><code>::Int</code>: the bandwidth of <code>A</code>.</li></ul><p><strong>Performance</strong></p><p>Given an <span>$n×n$</span> input matrix <span>$A$</span>, this relatively simple algorithm runs in <span>$O(n²)$</span> time.</p><p><strong>Examples</strong></p><p><code>bandwidth</code> correctly identifies the bandwidth of a pentadiagonal matrix as <span>$2$</span> and does not attempt to find a minimizing permutation upon shuffling of its rows and columns:</p><pre><code class="language-julia-repl hljs">julia&gt; using Random

julia&gt; Random.seed!(242622);

julia&gt; (n, k) = (8, 2);

julia&gt; perm = randperm(n);

julia&gt; A = (!iszero).(random_banded_matrix(8, 2))
8×8 BitMatrix:
 1  0  0  0  0  0  0  0
 0  1  0  1  0  0  0  0
 0  0  0  1  1  0  0  0
 0  1  1  1  0  1  0  0
 0  0  1  0  0  0  0  0
 0  0  0  1  0  0  0  0
 0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0

julia&gt; bandwidth(A)
2

julia&gt; A_shuffled = A[perm, perm]
8×8 BitMatrix:
 0  0  0  0  0  0  1  0
 0  0  0  0  0  0  0  0
 0  0  0  1  0  0  0  0
 0  0  1  0  0  0  1  0
 0  0  0  0  1  0  0  0
 0  0  0  0  0  1  1  0
 1  0  0  1  0  1  1  0
 0  0  0  0  0  0  0  0

julia&gt; bandwidth(A_shuffled)
6</code></pre><p><strong>Notes</strong></p><p>Some texts define matrix bandwidth to be the minimum non-negative integer <span>$k$</span> such that <span>$A[i, j] = 0$</span> whenever <span>$|i - j| ≥ k$</span> instead, particularly in more mathematically-minded communities. Effectively, this definition treats diagonal matrices as bandwidth <span>$1$</span>, tridiagonal matrices as bandwidth <span>$2$</span>, and so on. Our definition, on the other hand, is more common in computer science contexts, treating diagonal matrices as bandwidth <span>$0$</span> and tridiagonal matrices as bandwidth <span>$1$</span>. (Both definitions, however, agree that the bandwidth of an empty matrix is simply <span>$0$</span>.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/core.jl#L7-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.bandwidth_lower_bound-Tuple{AbstractMatrix{&lt;:Number}}" href="#MatrixBandwidth.bandwidth_lower_bound-Tuple{AbstractMatrix{&lt;:Number}}"><code>MatrixBandwidth.bandwidth_lower_bound</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">bandwidth_lower_bound(A) -&gt; Int</code></pre><p>Compute a lower bound on the bandwidth of <code>A</code> using [<a href="#CSG05">CS05</a>]&#39;s results.</p><p>The nonzero support of <code>A</code> is assumed to be symmetric, since [<a href="#CSG05">CS05</a>]&#39;s bound was discovered in the context of undirected graphs (whose adjacency matrices are symmetric).</p><p>The <em>bandwidth</em> of a square matrix <span>$A$</span> is the minimum non-negative integer <span>$k ∈ ℕ$</span> such that <span>$A[i, j] = 0$</span> whenever <span>$|i - j| &gt; k$</span>. Equivalently, <span>$A$</span> has bandwidth <em>at most</em> <span>$k$</span> if all entries above the <span>$k$</span>-th superdiagonal and below the <span>$k$</span>-th subdiagonal are zero, and <span>$A$</span> has bandwidth <em>at least</em> <span>$k$</span> if there exists any nonzero entry in the <span>$k$</span>-th superdiagonal or subdiagonal.</p><p>In contrast to <a href="#MatrixBandwidth.Minimization.minimize_bandwidth"><code>minimize_bandwidth</code></a>, this function does not attempt to truly minimize the bandwidth of <code>A</code>—it simply returns a lower bound on its bandwidth up to symmetric permutation of its rows and columns. This bound is not tight, but it is easily computable in <code>O(n³)</code> time, dominated by the Floyd–Warshall algorithm call. (The core logic here runs in <code>O(n²)</code> time.)</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractMatrix{&lt;:Number}</code>: the (square) matrix on whose bandwidth a lower bound is to   be computed. <code>A</code> must have a symmetric nonzero support (i.e., <code>A[i, j]</code> is nonzero if   and only if <code>A[j, i]</code> is nonzero).</li></ul><p><strong>Returns</strong></p><ul><li><code>::Int</code>: a lower bound on the bandwidth of <code>A</code>. (This bound is not tight.)</li></ul><p><strong>Examples</strong></p><p>TODO: Write here</p><p><strong>Notes</strong></p><p>Some texts define matrix bandwidth to be the minimum non-negative integer <span>$k$</span> such that <span>$A[i, j] = 0$</span> whenever <span>$|i - j| ≥ k$</span> instead, particularly in more mathematically-minded communities. Effectively, this definition treats diagonal matrices as bandwidth <span>$1$</span>, tridiagonal matrices as bandwidth <span>$2$</span>, and so on. Our definition, on the other hand, is more common in computer science contexts, treating diagonal matrices as bandwidth <span>$0$</span> and tridiagonal matrices as bandwidth <span>$1$</span>. (Both definitions, however, agree that the bandwidth of an empty matrix is simply <span>$0$</span>.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/core.jl#L101-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.random_banded_matrix-Tuple{Int64, Int64}" href="#MatrixBandwidth.random_banded_matrix-Tuple{Int64, Int64}"><code>MatrixBandwidth.random_banded_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">random_banded_matrix(n, k; p=0.5, rng=default_rng()) -&gt; Matrix{Float64}</code></pre><p>Generate a random <code>n×n</code> structurally symmetric <code>k</code>-banded matrix with band density <code>≈ p</code>.</p><p>By definition of structural symmetry, the <span>$(i, j)$</span>-th entry of the matrix is nonzero if and only if the <span>$(j, i)$</span>-th entry is nonzero as well. All entries from this matrix are from the interval <code>[0, 1]</code>. Entries up to the <code>k</code>-th superdiagonal and down to the <code>k</code>-th subdiagonal are nonzero with probability <code>p</code>.</p><p>It is also guaranteed that each of these bands (besides the main diagonal) has at least one nonzero entry (even when <code>p</code> is very small), thus ensuring that th matrix has bandwidth precisely <code>k</code> before any reordering. (There may, however, still exist a symmetric permutation inducing a minimum bandwidth less than <code>k</code>, especially for small values of <code>p</code>.)</p><p><strong>Arguments</strong></p><ul><li><code>n::Int</code>: the order of the matrix to generate. Must be positive.</li><li><code>k::Int</code>: the desired matrix bandwidth. Must satisfy <code>0 ≤ k &lt; n</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>p::Real=0.5</code>: the band density. Must satisfy <code>0 &lt; p ≤ 1</code>. Defaults to <code>0.5</code>.</li><li><code>rng::AbstractRNG=Random.default_rng()</code>: the random number generator to use. Defaults to   <code>Random.default_rng()</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>::Matrix{Float64}</code>: a random <code>n×n</code> matrix with bandwidth exactly <code>k</code> and sparse bands   with density <code>p</code>.</li></ul><p><strong>Examples</strong></p><p>Generate a <span>$6×6$</span> matrix with bandwidth <span>$1$</span> and the maximum number of nonzero entries:</p><pre><code class="language-julia-repl hljs">julia&gt; using Random

julia&gt; A = random_banded_matrix(6, 1; p=1, rng=MersenneTwister(1228))
6×6 Matrix{Float64}:
 0.310239  0.346413  0.0       0.0        0.0       0.0
 0.509981  0.917073  0.390771  0.0        0.0       0.0
 0.0       0.760045  0.808396  0.0195686  0.0       0.0
 0.0       0.0       0.222338  0.853164   0.806888  0.0
 0.0       0.0       0.0       0.421603   0.132165  0.805813
 0.0       0.0       0.0       0.0        0.305339  0.0799183

julia&gt; bandwidth(A)
1</code></pre><p>Generate a <span>$7×7$</span> matrix with bandwidth <span>$3$</span> and band density <span>$0.3$</span>:</p><pre><code class="language-julia-repl hljs">julia&gt; using Random

julia&gt; A = random_banded_matrix(7, 3; p=0.3, rng=MersenneTwister(0402))
7×7 Matrix{Float64}:
 0.0       0.132699  0.0       0.0       0.0  0.0       0.0
 0.869352  0.0       0.324319  0.926496  0.0  0.0       0.0
 0.0       0.891878  0.0       0.658102  0.0  0.0       0.0
 0.0       0.88859   0.399559  0.0       0.0  0.284285  0.703377
 0.0       0.0       0.0       0.0       0.0  0.0       0.0
 0.0       0.0       0.0       0.489594  0.0  0.0       0.393573
 0.0       0.0       0.0       0.412412  0.0  0.47063   0.0

julia&gt; bandwidth(A)
3</code></pre><p>Generate an <span>$8×8$</span> diagonal (bandwidth <span>$0$</span>) matrix with default band density (<span>$0.5$</span>):</p><pre><code class="language-julia-repl hljs">julia&gt; using Random

julia&gt; A = random_banded_matrix(8, 0; rng=MersenneTwister(0102))
8×8 Matrix{Float64}:
 0.0  0.0        0.0       0.0       0.0  0.0      0.0  0.0
 0.0  0.0762399  0.0       0.0       0.0  0.0      0.0  0.0
 0.0  0.0        0.373113  0.0       0.0  0.0      0.0  0.0
 0.0  0.0        0.0       0.726309  0.0  0.0      0.0  0.0
 0.0  0.0        0.0       0.0       0.0  0.0      0.0  0.0
 0.0  0.0        0.0       0.0       0.0  0.41974  0.0  0.0
 0.0  0.0        0.0       0.0       0.0  0.0      0.0  0.0
 0.0  0.0        0.0       0.0       0.0  0.0      0.0  0.293132

julia&gt; bandwidth(A)
0</code></pre><p><strong>Notes</strong></p><p>Users of the <a href="#MatrixBandwidth.MatrixBandwidth"><code>MatrixBandwidth</code></a> package may find this function useful when generating random test data for whatever frameworks, algorithms, etc. they are implementing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/utils.jl#L7-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.Minimization" href="#MatrixBandwidth.Minimization"><code>MatrixBandwidth.Minimization</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MatrixBandwidth.Minimization</code></pre><p>Exact, heuristic, and metaheuristic algorithms for matrix bandwidth minimization in Julia.</p><p>The <em>bandwidth</em> of a square matrix <span>$A$</span> is the minimum non-negative integer <span>$k ∈ ℕ$</span> such that <span>$A[i, j] = 0$</span> whenever <span>$|i - j| &gt; k$</span>. Equivalently, <span>$A$</span> has bandwidth <em>at most</em> <span>$k$</span> if all entries above the <span>$k$</span>-th superdiagonal and below the <span>$k$</span>-th subdiagonal are zero, and <span>$A$</span> has bandwidth <em>at least</em> <span>$k$</span> if there exists any nonzero entry in the <span>$k$</span>-th superdiagonal or subdiagonal.</p><p>The <em>matrix bandwidth minimization problem</em> involves finding a permutation matrix <span>$P$</span> such that the bandwidth of <span>$PAPᵀ$</span> is minimized; this is known to be NP-complete. Several heuristic algorithms (such as reverse Cuthill–McKee) run in polynomial time while still producing near-optimal orderings in practice, but exact methods (like Caprara–Salazar-González) are exponential in time complexity and thus are only feasible for relatively small matrices.</p><p>The following algorithms are currently supported:</p><ul><li><em>Exact</em><ul><li>Caprara–Salazar-González algorithm (<a href="#MatrixBandwidth.Minimization.Exact.CapraraSalazarGonzalez"><code>CapraraSalazarGonzalez</code></a>)</li><li>Del Corso–Manzini algorithm (<a href="#MatrixBandwidth.Minimization.Exact.DelCorsoManzini"><code>DelCorsoManzini</code></a>)</li><li>Del Corso–Manzini algorithm with perimeter search (<a href="#MatrixBandwidth.Minimization.Exact.DelCorsoManziniWithPS"><code>DelCorsoManziniWithPS</code></a>)</li><li>Saxe–Gurari–Sudborough algorithm (<a href="#MatrixBandwidth.Minimization.Exact.SaxeGurariSudborough"><code>SaxeGurariSudborough</code></a>)</li></ul></li><li><em>Heuristic</em><ul><li>Gibbs–Poole–Stockmeyer algorithm (<a href="#MatrixBandwidth.Minimization.Heuristic.GibbsPooleStockmeyer"><code>GibbsPooleStockmeyer</code></a>)</li><li>Cuthill–McKee algorithm (<a href="#MatrixBandwidth.Minimization.Heuristic.CuthillMcKee"><code>CuthillMcKee</code></a>)</li><li>Reverse Cuthill–McKee algorithm (<a href="#MatrixBandwidth.Minimization.Heuristic.ReverseCuthillMcKee"><code>ReverseCuthillMcKee</code></a>)</li></ul></li><li><em>Metaheuristic</em><ul><li>Greedy randomized adaptive search procedure (GRASP) (<a href="#MatrixBandwidth.Minimization.Metaheuristic.GRASP"><code>GRASP</code></a>)</li><li>Simulated annealing (<a href="#MatrixBandwidth.Minimization.Metaheuristic.SimulatedAnnealing"><code>SimulatedAnnealing</code></a>)</li><li>Genetic algorithm (<a href="#MatrixBandwidth.Minimization.Metaheuristic.GeneticAlgorithm"><code>GeneticAlgorithm</code></a>)</li></ul></li></ul><p>This submodule is part of the <a href="https://github.com/Luis-Varona/MatrixBandwidth.jl">MatrixBandwidth.jl</a> package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/Minimization/Minimization.jl#L7-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.Minimization.MinimizationResult" href="#MatrixBandwidth.Minimization.MinimizationResult"><code>MatrixBandwidth.Minimization.MinimizationResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MinimizationResult{A,M,O} &lt;: AbstractResult</code></pre><p>Output struct for matrix bandwidth minimization results.</p><p><strong>Fields</strong></p><ul><li><code>algorithm::A&lt;:AbstractSolver</code>: the solver used to minimize the bandwidth.</li><li><code>matrix::M&lt;:AbstractMatrix{&lt;:Number}</code>: the original matrix whose bandwidth is minimized.</li><li><code>ordering::O&lt;:Vector{Int}</code>: the (near-)optimal ordering of the rows and columns.</li><li><code>bandwidth::Int</code>: the minimized bandwidth of the matrix.</li><li><code>approach::Symbol</code>: the approach used by the solver. (Should be one of <code>:exact</code>,   <code>:heuristic</code>, and <code>:metaheuristic</code>.)</li></ul><p><strong>Constructors</strong></p><ul><li><code>MinimizationResult(algorithm, matrix, ordering, bandwidth)</code>: constructs a new   <code>MinimizationResult</code> instance with the given fields. The <code>approach</code> field is   automatically determined based on the algorithm type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/Minimization/types.jl#L35-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.Minimization.minimize_bandwidth" href="#MatrixBandwidth.Minimization.minimize_bandwidth"><code>MatrixBandwidth.Minimization.minimize_bandwidth</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">minimize_bandwidth(A, solver=ReverseCuthillMcKee()) -&gt; MinimizationResult</code></pre><p>Minimize the bandwidth of <code>A</code> using the algorithm defined by <code>solver</code>.</p><p>The <em>bandwidth</em> of a square matrix <span>$A$</span> is the minimum non-negative integer <span>$k ∈ ℕ$</span> such that <span>$A[i, j] = 0$</span> whenever <span>$|i - j| &gt; k$</span>. Equivalently, <span>$A$</span> has bandwidth <em>at most</em> <span>$k$</span> if all entries above the <span>$k$</span>-th superdiagonal and below the <span>$k$</span>-th subdiagonal are zero, and <span>$A$</span> has bandwidth <em>at least</em> <span>$k$</span> if there exists any nonzero entry in the <span>$k$</span>-th superdiagonal or subdiagonal.</p><p>This function computes a (near-)optimal ordering <span>$π$</span> of the rows and columns of <span>$A$</span> so that the bandwidth of <span>$PAPᵀ$</span> is minimized, where <span>$P$</span> is the permutation matrix corresponding to <span>$π$</span>. This is known to be an NP-complete problem; however, several heuristic algorithms such as <a href="#MatrixBandwidth.Minimization.Heuristic.ReverseCuthillMcKee"><code>ReverseCuthillMcKee</code></a> run in polynomial time while still producing near-optimal orderings in practice. Exact methods like <a href="#MatrixBandwidth.Minimization.Exact.CapraraSalazarGonzalez"><code>CapraraSalazarGonzalez</code></a> are also available, but they are exponential in time complexity and thus only feasible for relatively small matrices.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractMatrix{&lt;:Number}</code>: the (square) matrix whose bandwidth is minimized.</li><li><code>solver::AbstractSolver</code>: the matrix bandwidth minimization algorithm to use; defaults to   <a href="#MatrixBandwidth.Minimization.Heuristic.ReverseCuthillMcKee"><code>ReverseCuthillMcKee</code></a>. (See the <a href="#MatrixBandwidth.Minimization"><code>Minimization</code></a> module documentation for   a full list of supported solvers.)</li></ul><p><strong>Returns</strong></p><ul><li><code>::MinimizationResult</code>: a struct containing the original matrix <code>A</code>, the minimized   bandwidth, the (near-)optimal ordering of the rows and columns, and the algorithm used.</li></ul><p><strong>Examples</strong></p><p>[TODO: Add here once more solvers are implemented]</p><p><strong>Notes</strong></p><p>Some texts define matrix bandwidth to be the minimum non-negative integer <span>$k$</span> such that <span>$A[i, j] = 0$</span> whenever <span>$|i - j| ≥ k$</span> instead, particularly in more mathematically-minded communities. Effectively, this definition treats diagonal matrices as bandwidth <span>$1$</span>, tridiagonal matrices as bandwidth <span>$2$</span>, and so on. Our definition, on the other hand, is more common in computer science contexts, treating diagonal matrices as bandwidth <span>$0$</span> and tridiagonal matrices as bandwidth <span>$1$</span>. (Both definitions, however, agree that the bandwidth of an empty matrix is simply <span>$0$</span>.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/Minimization/core.jl#L7-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.Minimization.Exact" href="#MatrixBandwidth.Minimization.Exact"><code>MatrixBandwidth.Minimization.Exact</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MatrixBandwidth.Minimization.Exact</code></pre><p>Exact solvers for matrix bandwidth minimization.</p><p>Exact methods are those which guarantee an optimal ordering producing the true minimum bandwidth of a matrix. Since bandwidth minimization is an NP-complete problem, existing exact algorithms are, at best, exponential in time complexity—much worse than many polynomial-time heuristic approaches (e.g., reverse Cuthill–McKee). Such methods, therefore, are not feasible for large matrices, but they remain useful when precise solutions are required for small-to-medium-sized inputs (say, up to <span>$100×100$</span>).</p><p>The following exact algorithms are currently supported:</p><ul><li>Caprara–Salazar-González algorithm (<a href="#MatrixBandwidth.Minimization.Exact.CapraraSalazarGonzalez"><code>CapraraSalazarGonzalez</code></a>)</li><li>Del Corso–Manzini algorithm (<a href="#MatrixBandwidth.Minimization.Exact.DelCorsoManzini"><code>DelCorsoManzini</code></a>)</li><li>Del Corso–Manzini algorithm with perimeter search (<a href="#MatrixBandwidth.Minimization.Exact.DelCorsoManziniWithPS"><code>DelCorsoManziniWithPS</code></a>)</li><li>Saxe–Gurari–Sudborough algorithm (<a href="#MatrixBandwidth.Minimization.Exact.SaxeGurariSudborough"><code>SaxeGurariSudborough</code></a>)</li></ul><p>This submodule is part of the <code>MatrixBandwidth.Minimization</code> submodule of the <a href="https://github.com/Luis-Varona/MatrixBandwidth.jl">MatrixBandwidth.jl</a> package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/Minimization/Exact/Exact.jl#L7-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.Minimization.Exact.CapraraSalazarGonzalez" href="#MatrixBandwidth.Minimization.Exact.CapraraSalazarGonzalez"><code>MatrixBandwidth.Minimization.Exact.CapraraSalazarGonzalez</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CapraraSalazarGonzalez &lt;: ExactSolver &lt;: AbstractSolver</code></pre><p>TODO: Write here</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/Minimization/Exact/solvers/caprara_salazar_gonzalez.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.Minimization.Exact.DelCorsoManzini" href="#MatrixBandwidth.Minimization.Exact.DelCorsoManzini"><code>MatrixBandwidth.Minimization.Exact.DelCorsoManzini</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DelCorsoManzini &lt;: ExactSolver &lt;: AbstractSolver</code></pre><p>TODO: Write here</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/Minimization/Exact/solvers/del_corso_manzini.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.Minimization.Exact.DelCorsoManziniWithPS" href="#MatrixBandwidth.Minimization.Exact.DelCorsoManziniWithPS"><code>MatrixBandwidth.Minimization.Exact.DelCorsoManziniWithPS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DelCorsoManziniWithPS &lt;: ExactSolver &lt;: AbstractSolver</code></pre><p>TODO: Write here</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/Minimization/Exact/solvers/del_corso_manzini_with_ps.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.Minimization.Exact.SaxeGurariSudborough" href="#MatrixBandwidth.Minimization.Exact.SaxeGurariSudborough"><code>MatrixBandwidth.Minimization.Exact.SaxeGurariSudborough</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SaxeGurariSudborough &lt;: ExactSolver &lt;: AbstractSolver</code></pre><p>TODO: Write here</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/Minimization/Exact/solvers/saxe_gurari_sudborough.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.Minimization.Heuristic" href="#MatrixBandwidth.Minimization.Heuristic"><code>MatrixBandwidth.Minimization.Heuristic</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MatrixBandwidth.Minimization.Heuristic</code></pre><p>Heuristic solvers for matrix bandwidth minimization.</p><p>Heuristic methods are those which aim to produce near-optimal solutions in a more performant manner than exact methods. While precise bandwidth minimization is NP-complete, many heuristic algorithms (such as reverse Cuthill–McKee) run in polynomial time.</p><p>Heuristic algorithms differ from metaheuristic ones in that they do not employ higher-level iterative search frameworks (e.g., stochastic techniques) to survey the global search space and escape local minima; instead, they rely on straightforward deterministic procedures to find good solutions in a single pass.</p><p>The following heuristic algorithms are currently supported:</p><ul><li>Gibbs–Poole–Stockmeyer algorithm (<a href="#MatrixBandwidth.Minimization.Heuristic.GibbsPooleStockmeyer"><code>GibbsPooleStockmeyer</code></a>)</li><li>Cuthill–McKee algorithm (<a href="#MatrixBandwidth.Minimization.Heuristic.CuthillMcKee"><code>CuthillMcKee</code></a>)</li><li>Reverse Cuthill–McKee algorithm (<a href="#MatrixBandwidth.Minimization.Heuristic.ReverseCuthillMcKee"><code>ReverseCuthillMcKee</code></a>)</li></ul><p>This submodule is part of the <code>MatrixBandwidth.Minimization</code> submodule of the <a href="https://github.com/Luis-Varona/MatrixBandwidth.jl">MatrixBandwidth.jl</a> package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/Minimization/Heuristic/Heuristic.jl#L7-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.Minimization.Heuristic.CuthillMcKee" href="#MatrixBandwidth.Minimization.Heuristic.CuthillMcKee"><code>MatrixBandwidth.Minimization.Heuristic.CuthillMcKee</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CuthillMcKee &lt;: HeuristicSolver &lt;: AbstractSolver</code></pre><p>The <em>Cuthill–McKee algorithm</em> is a heuristic method for minimizing the bandwidth of a symmetric matrix <span>$A$</span>. It considers the graph <span>$G(A)$</span> whose adjacency matrix is <span>$A$</span> (ignoring self-loops) and performs a breadth-first search of each connected component of <span>$G(A)$</span>, starting from a low-degree node then visiting its neighbors in order of increasing degree. Particularly effective when <span>$A$</span> is sparse, this heuristic typically produces an ordering which induces a matrix bandwidth either equal to or very close to the true minimum [<a href="#CM69">CM69</a>, pp. 157–58].</p><p>As noted above, the input matrix must be symmetric for Cuthill–McKee to work.</p><p><strong>Fields</strong></p><ul><li><code>node_selector::Function</code>: a function that selects a node from some connected component of   the input matrix from which to start the breadth-first search. If no custom heuristic is   specified, this field defaults to <a href="../private_api/#MatrixBandwidth.Minimization.Heuristic.pseudo_peripheral_node-Tuple{AbstractMatrix{Bool}}"><code>pseudo_peripheral_node</code></a>, which picks a node   &quot;farthest&quot; from the others in the component (not necessarily the lowest-degree node).</li></ul><p><strong>Performance</strong></p><p>Given an <span>$n×n$</span> input matrix <span>$A$</span>, the Cuthill–McKee algorithm runs in <span>$O(n²)$</span> time.</p><p>[<a href="#CG80">CG80</a>] provide a linear-time implementation in the number of nonzero entries of <span>$A$</span>, which is still quadratic when <span>$A$</span> is dense but often much faster when dealing with sparse matrices. However, this would require that <span>$A$</span> be stored as a graph or a sparse matrix, which runs counter to our desire to provide a bandwidth minimization API for all <code>AbstractMatrix{&lt;:Number}</code> types, including dense matrices. (In the future, however, we may indeed consider supporting this more performant implementation for sparse matrices.)</p><p>It was found in [<a href="#Geo71">Geo71</a>, pp. 114–15] that reversing the ordering produced by Cuthill–McKee tends to induce a more optimal <em>matrix profile</em> (a measure of how far, on average, nonzero entries are from the diagonal). This so-called <em>reverse Cuthill–McKee</em> variant is preferred in almost all cases—see <a href="#MatrixBandwidth.Minimization.Heuristic.ReverseCuthillMcKee"><code>ReverseCuthillMcKee</code></a> and the associated method of <code>_bool_minimal_band_ordering</code> for our implementation.</p><p><strong>Examples</strong></p><p>In the following examples, <a href="#MatrixBandwidth.random_banded_matrix-Tuple{Int64, Int64}"><code>MatrixBandwidth.random_banded_matrix</code></a> is used to generate random matrices with minimum bandwidth <em>close to</em> <span>$k$</span>. In some cases, however, the true minimum bandwidth up to symmetric permutation may be even less than <span>$k$</span>, making it hard to verify whether Cuthill–McKee finds a truly optimal ordering or simply a near-optimal one. Nevertheless, the results are still very good in practice.</p><p>Cuthill–McKee finds a good ordering for a <span>$30×30$</span> matrix whose rows and columns have been shuffled:</p><pre><code class="language-julia-repl hljs">julia&gt; using Random

julia&gt; Random.seed!(13);

julia&gt; (n, k) = (30, 5);

julia&gt; A = random_banded_matrix(n, k);

julia&gt; perm = randperm(n);

julia&gt; A_shuffled = A[perm, perm];

julia&gt; bandwidth(A)
5

julia&gt; bandwidth(A_shuffled) # Much larger after shuffling
25

julia&gt; res = minimize_bandwidth(A_shuffled, Minimization.CuthillMcKee())
Results of Bandwidth Minimization Algorithm
 * Algorithm: Cuthill–McKee
 * Approach: heuristic
 * Minimum Bandwidth: 5
 * Original Bandwidth: 25
 * Matrix Size: 30×30</code></pre><p>Cuthill–McKee finds a good ordering for a structurally symmetric <span>$183×183$</span> matrix with multiple (separate) connected components whose rows and columns have been shuffled:</p><pre><code class="language-julia-repl hljs">julia&gt; using Random, SparseArrays

julia&gt; Random.seed!(37452);

julia&gt; (max_cc_size, max_band, p, num_ccs) = (60, 9, 0.2, 7);

julia&gt; components = Vector{SparseMatrixCSC{Float64, Int64}}(undef, num_ccs);

julia&gt; for i in 1:num_ccs # Some components may themselves be disconnected
           cc_size = rand(1:max_cc_size);
           cc_band = rand(0:min(max_band, cc_size - 1));
           components[i] = sparse(random_banded_matrix(cc_size, cc_band; p=p));
       end

julia&gt; A = blockdiag(components...); # `A` has least 7 connected components

julia&gt; perm = randperm(sum(map(cc -&gt; size(cc, 1), components)));

julia&gt; A_shuffled = A[perm, perm];

julia&gt; res = minimize_bandwidth(A_shuffled, Minimization.CuthillMcKee());

julia&gt; A # The original matrix
276×276 SparseMatrixCSC{Float64, Int64} with 464 stored entries:
⎡⢾⡷⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎤
⎢⠀⠘⢻⣲⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠘⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠈⠿⡧⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠉⢯⡷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠚⣤⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⢻⣶⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠯⡧⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣤⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠛⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠱⣢⡀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⡢⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢴⣷⡀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠿⣧⡀⠀⎥
⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⡷⎦

julia&gt; A_shuffled # A far-from-optimal ordering of `A`
276×276 SparseMatrixCSC{Float64, Int64} with 464 stored entries:
⎡⠁⢄⠀⢀⠀⠀⠀⢀⠠⠀⠀⠐⠀⠀⠀⠐⢀⡐⠀⠀⠀⢀⠀⠀⠀⠀⠐⠀⢠⠀⠀⠀⡄⠀⠀⠐⠀⠀⠂⠄⎤
⎢⠀⢀⠱⠂⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⢨⠀⠀⠀⠀⠀⡀⠁⠠⠀⠘⠀⠀⠡⢀⠈⠀⠀⠀⠀⠀⠀⠄⠀⠁⠁⎥
⎢⠀⠀⠀⠀⠑⢀⠀⠂⠀⠀⠀⠀⢐⠀⠀⠠⠈⠠⠀⠀⠀⠐⠀⠐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⢢⢀⢀⠀⎥
⎢⠀⢀⡀⠀⠠⠀⠁⠄⠀⠠⠀⠄⠀⠀⠀⠄⠀⠀⠀⠀⢀⠀⠀⢀⠀⠑⠀⠀⠐⠠⠀⠀⠠⠨⠂⠀⠀⠀⠀⠀⎥
⎢⠀⠂⠀⠀⠀⠀⠀⡀⠱⢆⡀⠂⠀⠀⠀⠀⠀⠀⢀⢊⠀⠐⠐⠈⠀⠈⠀⢀⠄⠀⡀⠀⢁⢀⠠⠀⠃⠀⠊⠀⎥
⎢⢀⠀⠀⠀⠀⠀⠀⠄⠠⠈⠑⠀⢀⠐⠀⠌⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⢀⠉⢀⠀⠠⠈⠀⠀⣁⠁⎥
⎢⠀⠀⠀⠀⠐⠐⠀⠀⠀⠀⢀⠐⠁⠄⠈⠀⢌⠀⠆⠠⢀⠀⠄⠐⠰⠀⠀⠀⠁⠰⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⢀⠀⠂⠒⠀⡀⠀⠄⠀⠀⡀⠄⠂⠀⠐⢄⠁⢀⠀⠀⠀⡀⠀⠀⠀⠀⡠⠀⠀⠀⠀⠀⠀⠀⠀⢈⠀⠀⠀⠁⎥
⎢⢀⠰⠀⠀⠂⡀⠀⠀⠀⠀⠀⠈⠂⠑⠁⢀⠐⠄⠄⠂⠂⠜⠄⠀⠀⠀⡄⠀⠀⢀⠀⠠⠀⢀⠄⠀⢀⠀⠂⡂⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⡠⢐⠀⠀⠈⡁⠀⠀⠠⠁⠀⢀⠀⠀⠀⠀⡀⠀⠀⢀⠀⠈⠃⠀⠸⠈⠠⠀⠀⠀⢄⠂⎥
⎢⠀⢀⠄⠈⢀⠀⠀⠐⢀⠀⠀⠀⠀⠐⠀⠠⣈⠄⠀⠀⠐⢀⠀⡀⠀⠀⠀⠀⠀⠀⠐⠀⠀⠊⠀⠠⠀⠐⠀⠀⎥
⎢⠀⠀⠀⠂⢀⠀⠀⢀⡐⠀⠀⠀⢀⠁⠀⠀⠀⠁⠀⠀⠀⠠⠄⣥⠉⠈⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⡀⠀⠀⠀⎥
⎢⠀⠀⠒⠀⠀⠀⢄⠀⡀⠀⠀⠀⠐⠂⠀⠀⠀⠀⠀⠈⠀⠀⡃⠀⠁⢀⠀⠀⢀⡀⢈⠈⠀⠀⠀⠂⠀⠠⠂⠂⎥
⎢⠐⠀⠄⡀⠀⠀⠀⠀⠀⢀⠀⠈⠀⠀⠀⠊⠀⠉⠀⢀⠀⠀⠀⠀⠀⠀⠑⠀⠀⠀⠀⠀⢀⠀⠈⠀⠛⠃⢄⠀⎥
⎢⠀⠒⡀⠐⠀⠀⠐⡀⠀⠁⠀⠀⢁⡀⠀⠀⠀⢀⡀⠀⠀⠀⠀⠀⠀⠰⠀⠀⠀⢄⠀⠰⠀⠠⠠⢀⠀⠀⢂⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⡄⠐⠂⠀⠀⠀⠀⡀⠉⠀⠐⠀⠀⠈⡂⠐⠀⠀⢀⡀⠀⣠⠀⠄⠠⠀⠀⡀⠀⠀⎥
⎢⠀⠉⠀⠀⠀⠀⡀⡂⠁⢐⠀⠐⠀⠀⠀⠀⠀⢀⡒⠂⡠⠀⠀⠀⠀⠀⠀⠐⠀⡀⠀⠄⠑⠄⠀⠀⠀⠀⠀⠀⎥
⎢⢀⠀⠀⠀⠀⡀⠈⠀⠀⠂⡀⠂⠀⠀⡀⢀⠀⠁⠀⠂⠀⡀⠀⠀⠠⠀⠂⠀⠀⢂⠀⠂⠀⠀⠁⢀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠁⠈⢒⠀⠀⠉⠀⠀⠀⠀⠀⠀⠀⠀⠐⠀⠀⢀⠀⠀⠈⠀⡀⠿⠀⠀⠀⠀⠠⠀⠀⠀⠀⠱⠆⠀⠀⎥
⎣⠈⠄⠅⠀⠀⠐⠀⠀⠊⠀⠅⠘⠀⠀⠄⠀⠨⠠⠠⠑⠀⠀⠀⠀⠨⠀⠀⠑⠈⠐⠀⠀⠀⠀⠀⠀⠀⠀⠔⢅⎦

julia&gt; A_shuffled[res.ordering, res.ordering] # A near-optimal reordering of `A_shuffled`
276×276 SparseMatrixCSC{Float64, Int64} with 464 stored entries:
⎡⠱⣦⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎤
⎢⠀⠉⠻⣦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠘⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⡦⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⡦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠺⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠚⣤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⣤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⢄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⢀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⢄⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢄⠀⠀⎥
⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⎦

julia&gt; bandwidth(A)
7

julia&gt; bandwidth(A_shuffled) # Much larger after shuffling
266

julia&gt; res # Even better than the original bandwidth (which was not optimal)
Results of Bandwidth Minimization Algorithm
 * Algorithm: Cuthill–McKee
 * Approach: heuristic
 * Minimum Bandwidth: 5
 * Original Bandwidth: 266
 * Matrix Size: 276×276</code></pre><p><strong>Notes</strong></p><p>Note that the <code>node_selector</code> field must be of the form <code>(A::AbstractMatrix{Bool}) -&gt; Integer</code> (i.e., it must take in an boolean matrix and return an integer). If this is not the case, an <code>ArgumentError</code> is thrown upon construction.</p><p>See also the documentation for supertypes <a href="../private_api/#MatrixBandwidth.Minimization.Heuristic.HeuristicSolver"><code>HeuristicSolver</code></a> and <a href="../private_api/#MatrixBandwidth.Minimization.AbstractSolver"><code>AbstractSolver</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/Minimization/Heuristic/solvers/cuthill_mckee.jl#L7-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.Minimization.Heuristic.GibbsPooleStockmeyer" href="#MatrixBandwidth.Minimization.Heuristic.GibbsPooleStockmeyer"><code>MatrixBandwidth.Minimization.Heuristic.GibbsPooleStockmeyer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GibbsPooleStockmeyer &lt;: HeuristicSolver &lt;: AbstractSolver</code></pre><p>TODO: Write here. Do we need a node selector?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/Minimization/Heuristic/solvers/gibbs_poole_stockmeyer.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.Minimization.Heuristic.ReverseCuthillMcKee" href="#MatrixBandwidth.Minimization.Heuristic.ReverseCuthillMcKee"><code>MatrixBandwidth.Minimization.Heuristic.ReverseCuthillMcKee</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ReverseCuthillMcKee &lt;: HeuristicSolver &lt;: AbstractSolver</code></pre><p>The <em>reverse Cuthill–McKee algorithm</em> is a variant of the <em>Cuthill–McKee algorithm</em>—a heuristic method for minimizing the bandwidth of a symmetric matrix <span>$A$</span>. Cuthill–McKee considers the graph <span>$G(A)$</span> whose adjacency matrix is <span>$A$</span> (ignoring self-loops) and performs a breadth-first search of each connected component of <span>$G(A)$</span>, starting from a low-degree node then visiting its neighbors in order of increasing degree. Particularly effective when <span>$A$</span> is sparse, this heuristic typically produces an ordering which induces a matrix bandwidth either equal to or very close to the true minimum [<a href="#CM69">CM69</a>, pp. 157–58]. The reverse Cuthill–McKee algorithm simply reverses the ordering produced by application of Cuthill–McKee; it was found in [<a href="#Geo71">Geo71</a>, pp. 114–15] that although the bandwidth remains the same, this tends to produce a more optimal <em>matrix profile</em> (a measure of how far, on average, nonzero entries are from the diagonal).</p><p>As noted above, the input matrix must be symmetric for reverse Cuthill–McKee to work.</p><p><strong>Performance</strong></p><p>Given an <span>$n×n$</span> input matrix <span>$A$</span>, the reverse Cuthill–McKee algorithm runs in <span>$O(n²)$</span> time.</p><p>[<a href="#CG80">CG80</a>] provide a linear-time implementation in the number of nonzero entries of <span>$A$</span>, which is still quadratic when <span>$A$</span> is dense but often much faster when dealing with sparse matrices. However, this would require that <span>$A$</span> be stored as a graph or a sparse matrix, which runs counter to our desire to provide a bandwidth minimization API for all <code>AbstractMatrix{&lt;:Number}</code> types, including dense matrices. (In the future, however, we may indeed consider supporting this more performant implementation for sparse matrices.)</p><p><strong>Fields</strong></p><ul><li><code>node_selector::Function</code>: a function that selects a node from some connected component of   the input matrix from which to start the breadth-first search. If no custom heuristic is   specified, this field defaults to <a href="../private_api/#MatrixBandwidth.Minimization.Heuristic.pseudo_peripheral_node-Tuple{AbstractMatrix{Bool}}"><code>pseudo_peripheral_node</code></a>, which picks a node   &quot;farthest&quot; from the others in the component (not necessarily the lowest-degree node).</li></ul><p><strong>Examples</strong></p><p>In the following examples, <a href="#MatrixBandwidth.random_banded_matrix-Tuple{Int64, Int64}"><code>MatrixBandwidth.random_banded_matrix</code></a> is used to generate random matrices with minimum bandwidth <em>close to</em> <span>$k$</span>. In some cases, however, the true minimum bandwidth up to symmetric permutation may be even less than <span>$k$</span>, making it hard to verify whether reverse Cuthill–McKee finds a truly optimal ordering or simply a near-optimal one. Nevertheless, the results are still very good in practice.</p><p>Reverse Cuthill–McKee finds a good ordering for a <span>$35×35$</span> matrix whose rows and columns have been shuffled:</p><pre><code class="language-julia-repl hljs">julia&gt; using Random

julia&gt; Random.seed!(87);

julia&gt; (n, k) = (35, 3);

julia&gt; A = random_banded_matrix(n, k);

julia&gt; perm = randperm(n);

julia&gt; A_shuffled = A[perm, perm];

julia&gt; bandwidth(A)
3

julia&gt; bandwidth(A_shuffled) # Much larger after shuffling
30

julia&gt; res = minimize_bandwidth(A_shuffled, Minimization.ReverseCuthillMcKee())
Results of Bandwidth Minimization Algorithm
 * Algorithm: Reverse Cuthill–McKee
 * Approach: heuristic
 * Minimum Bandwidth: 3
 * Original Bandwidth: 30
 * Matrix Size: 35×35</code></pre><p>Reverse Cuthill–McKee finds a good ordering for a <span>$235×235$</span> matrix with multiple (separate) connected components whose rows and columns have been shuffled:</p><pre><code class="language-julia-repl hljs">julia&gt; using Random, SparseArrays

julia&gt; Random.seed!(5747);

julia&gt; (max_cc_size, max_band, p, num_ccs) = (60, 9, 0.2, 8);

julia&gt; components = Vector{SparseMatrixCSC{Float64, Int64}}(undef, num_ccs);

julia&gt; for i in 1:num_ccs # Some components may themselves be disconnected
           cc_size = rand(0:max_cc_size);
           cc_band = rand(1:min(max_band, cc_size - 1));
           components[i] = sparse(random_banded_matrix(cc_size, cc_band; p=p));
       end

julia&gt; A = blockdiag(components...); # `A` has least 8 connected components

julia&gt; perm = randperm(sum(map(cc -&gt; size(cc, 1), components)));

julia&gt; A_shuffled = A[perm, perm];

julia&gt; res = minimize_bandwidth(A_shuffled, Minimization.ReverseCuthillMcKee());

julia&gt; A # The original matrix
235×235 SparseMatrixCSC{Float64, Int64} with 445 stored entries:
⎡⢾⣳⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎤
⎢⠀⠘⢿⡷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠈⠏⣥⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠉⢴⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠙⠻⢂⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣮⣿⣢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠚⢿⡳⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⢰⣶⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠾⡧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⣢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⡠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⠖⣀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢏⡱⣄⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢮⣷⣄⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢻⣲⣄⠀⎥
⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢻⢖⎦

julia&gt; A_shuffled # A far-from-optimal ordering of `A`
235×235 SparseMatrixCSC{Float64, Int64} with 445 stored entries:
⎡⠑⠄⠀⠀⠀⠀⠀⢀⢀⠀⠄⠀⠀⠀⠀⠀⠀⠀⠀⠄⠀⡐⠀⠐⠀⠂⠀⠀⠀⠀⠀⠀⡂⠀⢀⠄⠁⠠⠐⠀⎤
⎢⠀⠀⠀⢄⡀⠀⢁⠀⠀⠈⠀⠁⠀⠀⠀⢀⠁⠄⠈⠀⠀⠀⠀⠐⠀⠀⠀⠀⠀⠈⠀⠂⠠⠀⠀⠀⠀⠀⡀⠐⎥
⎢⠀⠀⠀⠈⠁⢀⠀⠑⠀⢀⠁⢀⠀⠈⠀⠘⠌⠀⢀⠀⠄⠀⠂⡄⠄⠁⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⣂⠀⠀⠀⎥
⎢⠀⢀⠁⠐⢄⠀⠠⢆⠀⠀⠀⠀⠀⠀⠀⢀⠠⡀⠀⠀⠠⠀⠀⠀⠐⠀⠀⡀⠀⢀⠀⠀⠀⠈⠀⡀⠀⠀⠘⠀⎥
⎢⠀⠐⡀⠀⠀⢀⠀⠀⢀⢔⠈⢀⠀⠀⣐⠀⠀⠀⢀⠀⠀⠀⠀⠀⠐⠀⠄⢠⠀⠀⠀⠀⠀⠀⠀⡀⠀⠈⠣⡀⎥
⎢⠀⠁⠄⠀⠁⢀⠀⠀⠂⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⠀⡀⠀⠀⡐⠐⠀⡀⠀⠀⠂⠀⠀⠀⢀⠀⠀⠄⠀⎥
⎢⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠑⠀⠀⠀⠀⠀⠀⠀⡠⠀⡀⠀⠀⠄⠀⠀⠠⠀⠀⠠⠀⠀⠀⠀⡠⠄⠀⠄⎥
⎢⠀⠀⠀⢀⣀⠀⠀⢀⠐⠘⠀⠀⠀⠀⠕⢅⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⢀⠐⡀⠀⠈⠀⠂⠀⠀⢀⠀⠃⠀⠄⎥
⎢⠀⠀⠁⠄⠂⠁⠀⠢⠀⠀⠀⠀⠀⠀⠀⠀⠛⢄⢸⠘⠀⠀⠀⠀⠄⠈⠁⠀⠀⠨⠀⠀⢀⠀⠀⠨⠀⠀⠈⠀⎥
⎢⠀⠄⠂⠀⠀⠐⠀⠀⠀⠐⠀⠀⠀⠀⠀⠀⣒⠒⠁⠀⢠⠀⠀⠀⠐⠀⠀⠀⢁⠀⠐⠈⠀⠀⠂⠀⠂⡀⠀⠀⎥
⎢⢀⠠⠀⠀⠀⠁⠀⠂⠀⠀⠀⠂⠀⠊⠀⠀⠀⠀⠀⠒⠑⠀⠀⠀⠀⠂⢀⠁⡂⠀⠀⢀⠀⠀⠀⠀⠁⠂⡊⠂⎥
⎢⢀⠀⢀⠀⠈⠤⠀⠀⠀⠀⠀⠈⠀⠈⠀⠠⠀⠀⠀⠀⠀⠀⠁⢀⠅⠀⢀⠀⠀⠀⢀⠀⡁⠀⠀⠀⠀⠠⠀⠀⎥
⎢⠠⠀⠀⠀⠄⠁⠐⠀⠐⠀⢀⠠⠀⠄⠀⠀⡀⠁⠐⠀⠠⠀⠁⠁⠁⠀⢀⠄⠀⠉⠀⠃⠀⠀⠀⠀⠠⢠⠂⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠠⠀⣁⠐⠀⠀⠀⢀⠐⠁⠀⠀⠀⠄⠐⠀⠐⠀⠔⡑⠌⠀⠀⠀⠀⠢⢉⠀⠀⠄⠀⠀⠄⎥
⎢⠀⠀⡀⠀⠂⠀⠀⢀⠀⠀⠀⠈⠀⠂⠀⠈⡀⡀⠁⠐⠈⠈⠀⠀⡄⠀⠀⠀⠄⠅⠀⡀⠀⠀⠀⠠⠀⠰⠀⠂⎥
⎢⠀⠀⠠⠀⠀⠀⠀⠀⠀⠀⠠⠀⠀⡀⠂⠀⠀⠀⡐⠀⠀⢀⠀⠐⠤⠀⠀⠀⠀⠠⠀⢀⠀⠀⠀⠀⠀⠀⠒⢀⎥
⎢⠈⠈⠀⠂⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠐⠀⠀⠀⠀⠁⠈⠀⠀⡌⢂⠀⠀⠀⠀⠀⠄⠈⠀⠀⡀⠀⠀⎥
⎢⠀⠔⠀⠀⠀⠀⠀⠠⠀⠠⠀⢀⠀⠀⠀⢀⡀⡀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠂⠀⠡⠂⠀⠀⡠⠀⎥
⎢⠁⡀⠀⠀⠈⠘⠀⠀⡀⠀⠀⠀⠀⠎⠤⠀⠀⠀⠈⠠⠡⠀⠀⡀⠀⣂⠀⠁⢀⡀⠀⠀⠀⠠⠀⠀⠰⠆⠌⠀⎥
⎣⠐⠀⢀⠈⠀⠀⠒⠀⠉⠢⠀⠁⠀⠄⠀⠄⠂⠀⠀⠀⠪⠈⠀⠀⠈⠀⠀⠄⠠⠀⠘⢀⠀⠀⠀⠊⠂⠁⠐⢀⎦

julia&gt; A_shuffled[res.ordering, res.ordering] # A near-optimal reordering of `A_shuffled`
235×235 SparseMatrixCSC{Float64, Int64} with 445 stored entries:
⎡⠁⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎤
⎢⠀⠀⠁⢄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠈⠀⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠁⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠑⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢛⢔⢤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠳⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠚⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠡⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠫⣦⣤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⢿⣷⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠯⣧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠯⣧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠺⢆⡄⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⢻⣲⣄⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢻⣶⡀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣢⡀⠀⎥
⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠱⣦⎦

julia&gt; bandwidth(A)
9

julia&gt; bandwidth(A_shuffled) # Much larger after shuffling
226

julia&gt; res # Gets very close to the original bandwidth
Results of Bandwidth Minimization Algorithm
 * Algorithm: Reverse Cuthill–McKee
 * Approach: heuristic
 * Minimum Bandwidth: 9
 * Original Bandwidth: 226
 * Matrix Size: 235×235</code></pre><p><strong>Notes</strong></p><p>Note that the <code>node_selector</code> field must be of the form <code>(A::AbstractMatrix{Bool}) -&gt; Integer</code> (i.e., it must take in an boolean matrix and return an integer). If this is not the case, an <code>ArgumentError</code> is thrown upon construction.</p><p>See also the documentation for supertypes <a href="../private_api/#MatrixBandwidth.Minimization.Heuristic.HeuristicSolver"><code>HeuristicSolver</code></a> and <a href="../private_api/#MatrixBandwidth.Minimization.AbstractSolver"><code>AbstractSolver</code></a>, as well as <a href="#MatrixBandwidth.Minimization.Heuristic.CuthillMcKee"><code>CuthillMcKee</code></a> for the original non-reversed algorithm. (Indeed, the reverse Cuthill–McKee method of <code>_bool_minimal_band_ordering</code> is merely a wrapper around the Cuthill–McKee method.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/Minimization/Heuristic/solvers/reverse_cuthill_mckee.jl#L7-L196">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.Minimization.Metaheuristic" href="#MatrixBandwidth.Minimization.Metaheuristic"><code>MatrixBandwidth.Minimization.Metaheuristic</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MatrixBandwidth.Minimization.Metaheuristic</code></pre><p>Metaheuristic solvers for matrix bandwidth minimization.</p><p>Metaheuristic methods are those which [TODO: Write here]</p><p>The following metaheuristic algorithms are currently supported:</p><ul><li>Greedy randomized adaptive search procedure (GRASP) (<a href="#MatrixBandwidth.Minimization.Metaheuristic.GRASP"><code>GRASP</code></a>)</li><li>Simulated annealing (<a href="#MatrixBandwidth.Minimization.Metaheuristic.SimulatedAnnealing"><code>SimulatedAnnealing</code></a>)</li><li>Genetic algorithm (<a href="#MatrixBandwidth.Minimization.Metaheuristic.GeneticAlgorithm"><code>GeneticAlgorithm</code></a>)</li></ul><p>This submodule is part of the <code>MatrixBandwidth.Minimization</code> submodule of the <a href="https://github.com/Luis-Varona/MatrixBandwidth.jl">MatrixBandwidth.jl</a> package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/Minimization/Metaheuristic/Metaheuristic.jl#L7-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.Minimization.Metaheuristic.GRASP" href="#MatrixBandwidth.Minimization.Metaheuristic.GRASP"><code>MatrixBandwidth.Minimization.Metaheuristic.GRASP</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GRASP &lt;: MetaheuristicSolver &lt;: AbstractSolver</code></pre><p>TODO: Write here</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/Minimization/Metaheuristic/solvers/grasp.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.Minimization.Metaheuristic.GeneticAlgorithm" href="#MatrixBandwidth.Minimization.Metaheuristic.GeneticAlgorithm"><code>MatrixBandwidth.Minimization.Metaheuristic.GeneticAlgorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeneticAlgorithm &lt;: MetaheuristicSolver &lt;: AbstractSolver</code></pre><p>TODO: Write here</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/Minimization/Metaheuristic/solvers/genetic_algorithm.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.Minimization.Metaheuristic.SimulatedAnnealing" href="#MatrixBandwidth.Minimization.Metaheuristic.SimulatedAnnealing"><code>MatrixBandwidth.Minimization.Metaheuristic.SimulatedAnnealing</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SimulatedAnnealing &lt;: MetaheuristicSolver &lt;: AbstractSolver</code></pre><p>TODO: Write here</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/Minimization/Metaheuristic/solvers/simulated_annealing.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.Recognition" href="#MatrixBandwidth.Recognition"><code>MatrixBandwidth.Recognition</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MatrixBandwidth.Recognition</code></pre><p>Algorithms for matrix bandwidth recognition in Julia.</p><p>The <em>bandwidth</em> of a square matrix <span>$A$</span> is the minimum non-negative integer <span>$k ∈ ℕ$</span> such that <span>$A[i, j] = 0$</span> whenever <span>$|i - j| &gt; k$</span>. Equivalently, <span>$A$</span> has bandwidth <em>at most</em> <span>$k$</span> if all entries above the <span>$k$</span>-th superdiagonal and below the <span>$k$</span>-th subdiagonal are zero, and <span>$A$</span> has bandwidth <em>at least</em> <span>$k$</span> if there exists any nonzero entry in the <span>$k$</span>-th superdiagonal or subdiagonal.</p><p>The <em>matrix bandwidth recognition problem</em> entails determining whether there exists a permutation matrix <span>$P$</span> such that the bandwidth of <span>$PAPᵀ$</span> is at most some fixed non-negative integer <span>$k ∈ ℕ$</span>—an optimal permutation that fully minimizes the bandwidth of <span>$A$</span> is not required. Unlike the NP-hard minimization problem, this is decidable in <span>$O(nᵏ)$</span> time, where <span>$n$</span> is the order of <span>$A$</span>.</p><p>The following algorithms are currently supported:</p><ul><li>Caprara–Salazar-González algorithm (<a href="#MatrixBandwidth.Recognition.CapraraSalazarGonzalez"><code>CapraraSalazarGonzalez</code></a>)</li><li>Del Corso–Manzini algorithm (<a href="#MatrixBandwidth.Recognition.DelCorsoManzini"><code>DelCorsoManzini</code></a>)</li><li>Del Corso–Manzini algorithm with perimeter search (<a href="#MatrixBandwidth.Recognition.DelCorsoManziniWithPS"><code>DelCorsoManziniWithPS</code></a>)</li><li>Saxe–Gurari–Sudborough algorithm (<a href="#MatrixBandwidth.Recognition.SaxeGurariSudborough"><code>SaxeGurariSudborough</code></a>)</li></ul><p>This submodule is part of the <a href="https://github.com/Luis-Varona/MatrixBandwidth.jl">MatrixBandwidth.jl</a> package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/Recognition/Recognition.jl#L7-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.Recognition.CapraraSalazarGonzalez" href="#MatrixBandwidth.Recognition.CapraraSalazarGonzalez"><code>MatrixBandwidth.Recognition.CapraraSalazarGonzalez</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CapraraSalazarGonzalez &lt;: AbstractDecider</code></pre><p>TODO: Write here</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/Recognition/deciders/caprara_salazar_gonzalez.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.Recognition.DelCorsoManzini" href="#MatrixBandwidth.Recognition.DelCorsoManzini"><code>MatrixBandwidth.Recognition.DelCorsoManzini</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DelCorsoManzini &lt;: AbstractDecider</code></pre><p>TODO: Write here</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/Recognition/deciders/del_corso_manzini.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.Recognition.DelCorsoManziniWithPS" href="#MatrixBandwidth.Recognition.DelCorsoManziniWithPS"><code>MatrixBandwidth.Recognition.DelCorsoManziniWithPS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DelCorsoManziniWithPS &lt;: AbstractDecider</code></pre><p>TODO: Write here</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/Recognition/deciders/del_corso_manzini_with_ps.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.Recognition.RecognitionResult" href="#MatrixBandwidth.Recognition.RecognitionResult"><code>MatrixBandwidth.Recognition.RecognitionResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RecognitionResult{A,M,O} &lt;: AbstractResult</code></pre><p>Output struct for matrix bandwidth recognition results.</p><p><strong>Fields</strong></p><ul><li><code>algorithm::A&lt;:AbstractDecider</code>: the decider used to test the bandwidth.</li><li><code>matrix::M&lt;:AbstractMatrix{&lt;:Number}</code>: the original matrix whose bandwidth is tested.</li><li><code>ordering::O&lt;:Union{Nothing,Vector{Int}}</code>: an ordering of the rows and columns of <code>matrix</code>   inducing a bandwidth at most <code>k</code>, if such an ordering exists; otherwise, <code>nothing</code>.</li><li><code>k::Int</code>: the threshold bandwidth against which to test.</li><li><code>has_bandwidth_k_ordering::Bool</code>: whether the matrix has an ordering inducing a bandwidth   at most <code>k</code>. (This is <code>true</code> if and only if <code>ordering</code> is not <code>nothing</code>.)</li></ul><p><strong>Constructors</strong></p><ul><li><code>RecognitionResult(decider, matrix, ordering, k)</code>: constructs a new <code>RecognitionResult</code>   instance with the given fields. The <code>has_bandwidth_k_ordering</code> field is automatically   determined based on whether <code>ordering</code> is <code>nothing</code> or a <code>Vector{Int}</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/Recognition/types.jl#L24-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.Recognition.SaxeGurariSudborough" href="#MatrixBandwidth.Recognition.SaxeGurariSudborough"><code>MatrixBandwidth.Recognition.SaxeGurariSudborough</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SaxeGurariSudborough &lt;: AbstractDecider</code></pre><p>TODO: Write here</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/Recognition/deciders/saxe_gurari_sudborough.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixBandwidth.Recognition.has_bandwidth_k_ordering" href="#MatrixBandwidth.Recognition.has_bandwidth_k_ordering"><code>MatrixBandwidth.Recognition.has_bandwidth_k_ordering</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_bandwidth_k_ordering(A, k, decider=CapraraSalazarGonzalez()) -&gt; RecognitionResult</code></pre><p>Determine whether <code>A</code> has bandwidth at most <code>k</code> using the algorithm defined by <code>decider</code>.</p><p>The <em>bandwidth</em> of a square matrix <span>$A$</span> is the minimum non-negative integer <span>$k ∈ ℕ$</span> such that <span>$A[i, j] = 0$</span> whenever <span>$|i - j| &gt; k$</span>. Equivalently, <span>$A$</span> has bandwidth <em>at most</em> <span>$k$</span> if all entries above the <span>$k$</span>-th superdiagonal and below the <span>$k$</span>-th subdiagonal are zero, and <span>$A$</span> has bandwidth <em>at least</em> <span>$k$</span> if there exists any nonzero entry in the <span>$k$</span>-th superdiagonal or subdiagonal.</p><p>This function [TODO: Write here]</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractMatrix{&lt;:Number}</code>: the (square) matrix whose bandwidth is tested.</li><li><code>k::Int</code>: the threshold bandwidth against which to test.</li><li><code>decider::AbstractDecider</code>: the matrix bandwidth recognition algorithm to use; defaults to   <a href="#MatrixBandwidth.Recognition.CapraraSalazarGonzalez"><code>CapraraSalazarGonzalez</code></a>. (See the <a href="#MatrixBandwidth.Recognition"><code>Recognition</code></a> module documentation   for a full list of supported deciders.)</li></ul><p><strong>Returns</strong></p><ul><li><code>::RecognitionResult</code>: TODO: Write here</li></ul><p><strong>Examples</strong></p><p>[TODO: Add here once more deciders are implemented]</p><p><strong>Notes</strong></p><p>Some texts define matrix bandwidth to be the minimum non-negative integer <span>$k$</span> such that <span>$A[i, j] = 0$</span> whenever <span>$|i - j| ≥ k$</span> instead, particularly in more mathematically-minded communities. Effectively, this definition treats diagonal matrices as bandwidth <span>$1$</span>, tridiagonal matrices as bandwidth <span>$2$</span>, and so on. Our definition, on the other hand, is more common in computer science contexts, treating diagonal matrices as bandwidth <span>$0$</span> and tridiagonal matrices as bandwidth <span>$1$</span>. (Both definitions, however, agree that the bandwidth of an empty matrix is simply <span>$0$</span>.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Luis-Varona/MatrixBandwidth.jl/blob/3f44f280cb2de0b6ae3689fe84329ccb2d04a12b/src/Recognition/core.jl#L7-L41">source</a></section></article><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><div class="citation canonical"><dl><dt>[CS05]</dt><dd><div id="CSG05">A. Caprara and J.-J. Salazar-González. <a href="https://doi.org/10.1287/ijoc.1040.0083"><em>Laying Out Sparse Graphs with Provably Minimum Bandwidth</em></a>. <em>INFORMS Journal on Computing</em> <strong>17</strong>, 356–73 (2005).</div></dd><dt>[CG80]</dt><dd><div id="CG80">W. M. Chan and A. George. <a href="https://doi.org/10.1007/BF01933580"><em>A linear time implementation of the reverse Cuthill-McKee algorithm</em></a>. <em>BIT Numerical Mathematics</em> <strong>20</strong>, 8–14 (1980).</div></dd><dt>[CM69]</dt><dd><div id="CM69">E. Cuthill and J. McKee. <a href="https://doi.org/10.1145/800195.805928"><em>Reducing the bandwidth of sparse symmetric matrices</em></a>. In: <em>Proceedings of the 24th National Conference of the ACM</em> (Brandon Systems Press, 1969); pp. 157–72.</div></dd><dt>[Geo71]</dt><dd><div id="Geo71">J. A. George. <a href="https://apps.dtic.mil/sti/tr/pdf/AD0726171.pdf"><em>Computer Implementation of the Finite Element Method</em></a>. Ph.D. Thesis, Department of Computer Science, Stanford University (1971).</div></dd></dl></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../private_api/">Private API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.0 on <span class="colophon-date" title="Wednesday 9 July 2025 14:31">Wednesday 9 July 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
