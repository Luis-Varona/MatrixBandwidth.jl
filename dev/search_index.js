var documenterSearchIndex = {"docs":
[{"location":"public_api/#MatrixBandwidth.jl-–-Public-API","page":"Public API","title":"MatrixBandwidth.jl – Public API","text":"","category":"section"},{"location":"public_api/","page":"Public API","title":"Public API","text":"Documentation for MatrixBandwidth's public API.","category":"page"},{"location":"public_api/","page":"Public API","title":"Public API","text":"note: Note\nThe following documentation covers only the public API of the package. For internal details, see the private API documentation.","category":"page"},{"location":"public_api/#MatrixBandwidth.MatrixBandwidth","page":"Public API","title":"MatrixBandwidth.MatrixBandwidth","text":"MatrixBandwidth\n\nExact, heuristic, and metaheuristic algorithms for matrix bandwidth minimization in Julia.\n\nThe following algorithms are currently supported:\n\nExact\nMBID: Minimum bandwidth by iterative deepening (MB-ID)\nMBPS: Minimum bandwidth by perimeter search (MB-PS)\nHeuristic\nCuthillMcKee: Cuthill–McKee algorithm\nReverseCuthillMcKee: Reverse Cuthill–McKee algorithm\nMetaheuristic\nSimulatedAnnealing: Simulated annealing\nGeneticAlgorithm: Genetic algorithm\nGRASP: Greedy randomized adaptive search procedure (GRASP)\n\nFull documentation is available for the latest development version of this package.\n\n\n\n\n\n","category":"module"},{"location":"public_api/#MatrixBandwidth.BandwidthResult","page":"Public API","title":"MatrixBandwidth.BandwidthResult","text":"BandwidthResult\n\nTODO: Write here\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.bandwidth_unpermuted-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Number","page":"Public API","title":"MatrixBandwidth.bandwidth_unpermuted","text":"bandwidth_unpermuted(A) -> Int\n\nTODO: Write here\n\n\n\n\n\n","category":"method"},{"location":"public_api/#MatrixBandwidth.minimize_bandwidth-Union{Tuple{AbstractMatrix{T}}, Tuple{T}, Tuple{AbstractMatrix{T}, MatrixBandwidth.AbstractSolver}} where T<:Number","page":"Public API","title":"MatrixBandwidth.minimize_bandwidth","text":"minimize_bandwidth(A, solver=ReverseCuthillMcKee()) -> BandwidthResult\n\nTODO: Write here\n\n\n\n\n\n","category":"method"},{"location":"public_api/#MatrixBandwidth.Exact","page":"Public API","title":"MatrixBandwidth.Exact","text":"MatrixBandwidth.Exact\n\nExact solvers for matrix bandwidth minimization.\n\nThis submodule is part of the MatrixBandwidth.jl package.\n\n\n\n\n\n","category":"module"},{"location":"public_api/#MatrixBandwidth.Exact.MBID","page":"Public API","title":"MatrixBandwidth.Exact.MBID","text":"MBID <: ExactSolver <: AbstractSolver\n\nTODO: Write here\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Exact.MBPS","page":"Public API","title":"MatrixBandwidth.Exact.MBPS","text":"MBPS <: ExactSolver <: AbstractSolver\n\nTODO: Write here\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Heuristic","page":"Public API","title":"MatrixBandwidth.Heuristic","text":"MatrixBandwidth.Heuristic\n\nHeuristic solvers for matrix bandwidth minimization.\n\nThe following heuristic algorithms are currently supported:\n\nCuthillMcKee: Cuthill–McKee algorithm\nReverseCuthillMcKee: Reverse Cuthill–McKee algorithm\n\nThis submodule is part of the MatrixBandwidth.jl package.\n\n\n\n\n\n","category":"module"},{"location":"public_api/#MatrixBandwidth.Heuristic.CuthillMcKee","page":"Public API","title":"MatrixBandwidth.Heuristic.CuthillMcKee","text":"CuthillMcKee <: HeuristicSolver <: AbstractSolver\n\nThe Cuthill–McKee algorithm is a heuristic method for minimizing the bandwidth of a symmetric matrix A. It considers the graph G(A) whose adjacency matrix is A (ignoring self-loops) and performs a breadth-first search of each connected component of G(A), starting from a low-degree node then visiting its neighbors in order of increasing degree. Particularly effective when A is sparse, this heuristic typically produces an ordering which induces a matrix bandwidth either equal to or very close to the true minimum [CM69, pp. 157–58].\n\nWe also extend the algorithm to work more generally when A is not symmetric by applying it to A + Aᵀ instead, as suggested in [RS06, p. 808]. This approach still tends to produce a fairly good ordering, but it is not guaranteed to be as optimal as directly applying Cuthill–McKee to a symmetric input.\n\nFields\n\nnode_selector::Function: a function that selects a node from some connected component of   the input matrix from which to start the breadth-first search. If no custom heuristic is   specified, this field defaults to pseudo_peripheral_node, which picks a node   \"farthest\" from the others in the component (not necessarily the lowest-degree node).\n\nExamples\n\nCuthill–McKee finds an optimal ordering for an asymmetric 3535 matrix with bandwidth 3 whose rows and columns have been shuffled:\n\njulia> using Random\n\njulia> Random.seed!(13);\n\njulia> (n, k) = (35, 3);\n\njulia> perm = randperm(n);\n\njulia> A = MatrixBandwidth.random_sparse_banded_matrix(n, k);\n\njulia> A_shuffled = A[perm, perm];\n\njulia> res = minimize_bandwidth(A_shuffled, CuthillMcKee());\n\njulia> iszero.(A_shuffled) == iszero.(A_shuffled') # Works even for asymmetric matrices\nfalse\n\njulia> bandwidth_unpermuted(A)\n3\n\njulia> bandwidth_unpermuted(A_shuffled)\n33\n\njulia> res.bandwidth # The true minimum bandwidth\n3\n\nCuthill–McKee finds a near-optimal ordering for an asymmetric 200200 matrix with bandwidth 10 whose rows and columns have been shuffled:\n\njulia> using Random\n\njulia> Random.seed!(37452);\n\njulia> (n, k) = (200, 10);\n\njulia> perm = randperm(n);\n\njulia> A = MatrixBandwidth.random_sparse_banded_matrix(n, k);\n\njulia> A_shuffled = A[perm, perm];\n\njulia> res = minimize_bandwidth(A_shuffled, CuthillMcKee());\n\njulia> iszero.(A_shuffled) == iszero.(A_shuffled') # Works even for asymmetric matrices\nfalse\n\njulia> bandwidth_unpermuted(A)\n10\n\njulia> bandwidth_unpermuted(A_shuffled)\n194\n\njulia> res.bandwidth # Close to the true minimum\n14\n\nNotes\n\nIt was found in [Geo71, pp. 114–15] that reversing the ordering produced by Cuthill–McKee tends to produce a better ordering; this variant is known as the reverse Cuthill–McKee algorithm. See ReverseCuthillMcKee and the associated method of _bool_minimal_band_ordering for our implementation of this algorithm.\n\nNote also that the node_selector field must be of the form (A::AbstractMatrix{Bool}) -> Integer (i.e., it must take in an boolean matrix and return an integer). If this is not the case, an ArgumentError is thrown upon construction.\n\nSee also the documentation for supertypes HeuristicSolver and AbstractSolver.\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Heuristic.ReverseCuthillMcKee","page":"Public API","title":"MatrixBandwidth.Heuristic.ReverseCuthillMcKee","text":"ReverseCuthillMcKee <: HeuristicSolver <: AbstractSolver\n\nThe reverse Cuthill–McKee algorithm is a variant of the Cuthill–McKee algorithm—a heuristic method for minimizing the bandwidth of a symmetric matrix A. Cuthill–McKee considers the graph G(A) whose adjacency matrix is A (ignoring self-loops) and performs a breadth-first search of each connected component of G(A), starting from a low-degree node then visiting its neighbors in order of increasing degree. Particularly effective when A is sparse, this heuristic typically produces an ordering which induces a matrix bandwidth either equal to or very close to the true minimum [CM69, pp. 157–58]. The reverse Cuthill–McKee algorithm simply reverses the ordering produced by application of Cuthill–McKee; [Geo71, pp. 114–15] found that this tends to produce an even better ordering.\n\nWe also extend the algorithm to work more generally when A is not symmetric by applying it to A + Aᵀ instead, as suggested in [RS06, p. 808]. This approach still tends to produce a fairly good ordering, but it is not guaranteed to be as optimal as directly applying reverse Cuthill–McKee to a symmetric input.\n\nFields\n\nnode_selector::Function: a function that selects a node from some connected component of   the input matrix from which to start the breadth-first search. If no custom heuristic is   specified, this field defaults to pseudo_peripheral_node, which picks a node   \"farthest\" from the others in the component (not necessarily the lowest-degree node).\n\nExamples\n\nReverse Cuthill–McKee finds an optimal ordering for an asymmetric 4545 matrix with bandwidth 4 whose rows and columns have been shuffled:\n\njulia> using Random\n\njulia> Random.seed!(87);\n\njulia> (n, k) = (45, 4);\n\njulia> perm = randperm(n);\n\njulia> A = MatrixBandwidth.random_sparse_banded_matrix(n, k);\n\njulia> A_shuffled = A[perm, perm];\n\njulia> res = minimize_bandwidth(A_shuffled, ReverseCuthillMcKee());\n\njulia> iszero.(A_shuffled) == iszero.(A_shuffled') # Works even for asymmetric matrices\nfalse\n\njulia> bandwidth_unpermuted(A)\n4\n\njulia> bandwidth_unpermuted(A_shuffled)\n43\n\njulia> res.bandwidth # The true minimum bandwidth\n4\n\nReverse Cuthill–McKee finds a near-optimal ordering for an asymmetric 250250 matrix with bandwidth 14 whose rows and columns have been shuffled:\n\njulia> using Random\n\njulia> Random.seed!(5747);\n\njulia> (n, k) = (250, 14);\n\njulia> perm = randperm(n);\n\njulia> A = MatrixBandwidth.random_sparse_banded_matrix(n, k);\n\njulia> A_shuffled = A[perm, perm];\n\njulia> res = minimize_bandwidth(A_shuffled, ReverseCuthillMcKee());\n\njulia> iszero.(A_shuffled) == iszero.(A_shuffled') # Works even for asymmetric matrices\nfalse\n\njulia> bandwidth_unpermuted(A)\n14\n\njulia> bandwidth_unpermuted(A_shuffled)\n245\n\njulia> res.bandwidth # Close to the true minimum\n17\n\nNotes\n\nSee CuthillMcKee and the associated method of _bool_minimal_band_ordering for our implementation of the original Cuthill–McKee algorithm. (Indeed, the reverse Cuthill–McKee method of _bool_minimal_band_ordering is merely a wrapper around the Cuthill–McKee method.)\n\nNote also that the node_selector field must be of the form (A::AbstractMatrix{Bool}) -> Integer (i.e., it must take in an boolean matrix and return an integer). If this is not the case, an ArgumentError is thrown upon construction.\n\nSee also the documentation for supertypes HeuristicSolver and AbstractSolver.\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Metaheuristic","page":"Public API","title":"MatrixBandwidth.Metaheuristic","text":"MatrixBandwidth.Metaheuristic\n\nMetaheuristic solvers for matrix bandwidth minimization.\n\nThis submodule is part of the MatrixBandwidth.jl package.\n\n\n\n\n\n","category":"module"},{"location":"public_api/#MatrixBandwidth.Metaheuristic.GRASP","page":"Public API","title":"MatrixBandwidth.Metaheuristic.GRASP","text":"GRASP <: MetaheuristicSolver <: AbstractSolver\n\nTODO: Write here\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Metaheuristic.GeneticAlgorithm","page":"Public API","title":"MatrixBandwidth.Metaheuristic.GeneticAlgorithm","text":"GeneticAlgorithm <: MetaheuristicSolver <: AbstractSolver\n\nTODO: Write here\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Metaheuristic.SimulatedAnnealing","page":"Public API","title":"MatrixBandwidth.Metaheuristic.SimulatedAnnealing","text":"SimulatedAnnealing <: MetaheuristicSolver <: AbstractSolver\n\nTODO: Write here\n\n\n\n\n\n","category":"type"},{"location":"public_api/#References","page":"Public API","title":"References","text":"","category":"section"},{"location":"public_api/","page":"Public API","title":"Public API","text":"E. Cuthill and J. McKee. Reducing the bandwidth of sparse symmetric matrices. In: Proceedings of the 24th National Conference of the ACM (Brandon Systems Press, 1969); pp. 157–72.\n\n\n\nJ. A. George. Computer Implementation of the Finite Element Method. Ph.D. Thesis, Department of Computer Science, Stanford University (1971).\n\n\n\nJ. K. Reid and J. A. Scott. Reducing the Total Bandwidth of a Sparse Unsymmetric Matrix. SIAM Journal on Matrix Analysis and Applications 28, 805–21 (2006).\n\n\n\n","category":"page"},{"location":"private_api/#MatrixBandwidth.jl-–-Private-API","page":"Private API","title":"MatrixBandwidth.jl – Private API","text":"","category":"section"},{"location":"private_api/","page":"Private API","title":"Private API","text":"Documentation for MatrixBandwidth's private API.","category":"page"},{"location":"private_api/","page":"Private API","title":"Private API","text":"note: Note\nThe following documentation covers only the private API of the package. For public details, see the public API documentation.","category":"page"},{"location":"private_api/#MatrixBandwidth.AbstractSolver","page":"Private API","title":"MatrixBandwidth.AbstractSolver","text":"AbstractSolver\n\nTODO: Write here\n\n\n\n\n\n","category":"type"},{"location":"private_api/#MatrixBandwidth.NotImplementedError","page":"Private API","title":"MatrixBandwidth.NotImplementedError","text":"NotImplementedError(f, arg, subtype, abstracttype)\n\nAn exception indicating that a function lacks dispatch to handle a specific argument type.\n\nSemantically, this differs from MethodError in that it connotes a developer-side failure to implement a method rather than erroneous user input. Throughout this package, it is often used to warn when an existing function with multiple dispatch on some abstract type is called on a newly created subtype for which no method has been defined.\n\nFields\n\nf::Function: the function called.\narg::Symbol: the name of the argument with the unsupported type.\nsubtype::Type: the type of the argument. May be the actual concrete type or some   intermediate supertype. (For instance, if the relevant input has concrete type A with   hierarchy A <: B <: C and the abstracttype field is C, then both A and B are   perfectly valid choices for subtype.)\nabstracttype::Type: the abstract type under which the argument is meant to fall.\n\nConstructors\n\nNotImplementedError(::Function, ::Symbol, ::Type, ::Type): constructs a new   NotImplementedError instance. Throws an error if the second type is not abstract or   the first type is not a subtype of the second.\n\n\n\n\n\n","category":"type"},{"location":"private_api/#MatrixBandwidth.random_sparse_banded_matrix-Tuple{Int64, Int64}","page":"Private API","title":"MatrixBandwidth.random_sparse_banded_matrix","text":"random_sparse_banded_matrix(n, k; p=0.75, rng=default_rng()) -> Matrix{Float64}\n\nTODO: Write here\n\n\n\n\n\n","category":"method"},{"location":"private_api/#MatrixBandwidth.Exact.ExactSolver","page":"Private API","title":"MatrixBandwidth.Exact.ExactSolver","text":"ExactSolver <: AbstractSolver\n\nTODO: Write here\n\n\n\n\n\n","category":"type"},{"location":"private_api/#MatrixBandwidth.Heuristic.HeuristicSolver","page":"Private API","title":"MatrixBandwidth.Heuristic.HeuristicSolver","text":"HeuristicSolver <: AbstractSolver\n\nTODO: Write here\n\n\n\n\n\n","category":"type"},{"location":"private_api/#MatrixBandwidth.Heuristic.pseudo_peripheral_node-Tuple{AbstractMatrix{Bool}}","page":"Private API","title":"MatrixBandwidth.Heuristic.pseudo_peripheral_node","text":"pseudo_peripheral_node(A::AbstractMatrix{Bool}) -> Int\n\nSelect a pseudo-peripheral node from the connected graph represented by A.\n\nThis function acts as a node selector for the Cuthill–McKee and Reverse Cuthill–McKee algorithms, heuristically choosing the node \"farthest\" from the others in the graph. It is assumed that A is the adjacency matrix of some connected, undirected graph; otherwise, undefined behavior may arise.\n\nArguments\n\nA::AbstractMatrix{Bool}: the adjacency matrix of some connected, undirected graph. In   practice, this semantically represents the connected component of some larger graph.\n\nReturns\n\nInt: the index of the pseudo-peripheral node selected from the graph.\n\nNotes\n\nThis function takes heavy inspiration from the implementation in [Net25], which accepts a graph object as input and leverages several pre-existing functions in the networkx library. We herein repurpose the logic to work directly on adjacency matrices, avoiding reallocation overhead and an unnecessary dependency on Graphs.jl.\n\n\n\n\n\n","category":"method"},{"location":"private_api/#MatrixBandwidth.Metaheuristic.MetaheuristicSolver","page":"Private API","title":"MatrixBandwidth.Metaheuristic.MetaheuristicSolver","text":"MetaheuristicSolver <: AbstractSolver\n\nTODO: Write here\n\n\n\n\n\n","category":"type"},{"location":"private_api/","page":"Private API","title":"Private API","text":"<!– TODO: Insert a References section here once citations are added –>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<table>\n  <tr>\n    <td>Metadata</td>\n    <td>\n      <img src=\"https://img.shields.io/badge/version-v0.1.0--dev-pink.svg\" alt=\"Version\">\n      <a href=\"https://opensource.org/licenses/MIT\"><img src=\"https://img.shields.io/badge/License-MIT-A31F34.svg\" alt=\"License: MIT\"></a>\n      <a href=\"https://github.com/JuliaDiff/BlueStyle\"><img src=\"https://img.shields.io/badge/code%20style-blue-4495d1.svg\" alt=\"Code Style: Blue\"></a>\n    </td>\n  </tr>\n  <tr>\n    <td>Documentation</td>\n    <td>\n      <a href=\"https://luis-varona.github.io/MatrixBandwidth.jl/stable/\"><img src=\"https://img.shields.io/badge/docs-stable-darkgreen.svg\" alt=\"Documentation of latest stable version\"></a>\n      <a href=\"https://luis-varona.github.io/MatrixBandwidth.jl/dev/\"><img src=\"https://img.shields.io/badge/docs-dev-rebeccapurple.svg\" alt=\"Documentation of dev version\"></a>\n    </td>\n  </tr>\n  <tr>\n    <td>Continuous integration</td>\n    <td>\n      <a href=\"https://github.com/Luis-Varona/MatrixBandwidth.jl/actions?query=workflow%3ACI+branch%3Amain\"><img src=\"https://github.com/Luis-Varona/MatrixBandwidth.jl/actions/workflows/CI.yml/badge.svg\" alt=\"GitHub Workflow Status\"></a>\n    </td>\n  </tr>\n  <tr>\n    <td>Code coverage</td>\n    <td>\n      <a href=\"https://codecov.io/gh/Luis-Varona/MatrixBandwidth.jl\"><img src=\"https://img.shields.io/codecov/c/gh/Luis-Varona/MatrixBandwidth.jl.svg?label=codecov\" alt=\"Test coverage from codecov\"></a>\n    </td>\n    </tr>\n    <tr>\n      <td>Static analysis with</td>\n      <td>\n        <a href=\"https://github.com/JuliaTesting/Aqua.jl\"><img src=\"https://raw.githubusercontent.com/JuliaTesting/Aqua.jl/master/badge.svg\" alt=\"Aqua QA\"></a>\n        <a href=\"https://github.com/aviatesk/JET.jl\"><img src=\"https://img.shields.io/badge/%E2%9C%88%20tested%20with-JET.jl%EF%B8%8F-9cf.svg\" alt=\"JET static analysis\"></a>\n      </td>\n    </tr>\n</table>","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MatrixBandwidth.jl offers several exact, heuristic, and metaheuristic algorithms for matrix bandwidth minimization.","category":"page"},{"location":"#Algorithms","page":"Home","title":"Algorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following algorithms are currently supported:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Exact\nMinimum bandwidth by iterative deepening (MB-ID)\nMinimum bandwidth by perimeter search (MB-PS)\nHeuristic\nCuthill&ndash;McKee algorithm\nReverse Cuthill&ndash;McKee algorithm\nMetaheuristic\nSimulated annealing\nGenetic algorithm\nGreedy randomized adaptive search procedure (GRASP)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(As we remain in the early stages of development, some of these may not yet be fully implememnted and/or tested.)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The only prerequisite is a working Julia installation (v1.10 or later). First, enter Pkg mode by typing ] in the Julia REPL, then run the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/Luis-Varona/MatrixBandwidth.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"When MatrixBandwidth.jl is finally added to the official Julia registry, you will be able to install it more easily with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add MatrixBandwidth","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"I encourage you to cite this work if you have found any of the algorithms herein useful for your research. Starring the MatrixBandwidth.jl repository on GitHub is also appreciated.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The latest citation information may be found in the CITATION.bib file within the repository.","category":"page"},{"location":"#Project-status","page":"Home","title":"Project status","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"I aim to release the first stable version of MatrixBandwidth.jl in mid-June 2025. The current version is a work-in-progress, with much of the API still under development.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
