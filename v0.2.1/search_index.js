var documenterSearchIndex = {"docs":
[{"location":"public_api/#Public-API-Documentation","page":"Public API","title":"Public API Documentation","text":"","category":"section"},{"location":"public_api/","page":"Public API","title":"Public API","text":"Documentation for MatrixBandwidth's public API.","category":"page"},{"location":"public_api/","page":"Public API","title":"Public API","text":"note: Note\nThe following documentation covers only the public API of the package. For internal details, see the private API documentation.","category":"page"},{"location":"public_api/#MatrixBandwidth","page":"Public API","title":"MatrixBandwidth","text":"","category":"section"},{"location":"public_api/#MatrixBandwidth.MatrixBandwidth","page":"Public API","title":"MatrixBandwidth.MatrixBandwidth","text":"MatrixBandwidth\n\nFast algorithms for matrix bandwidth minimization and recognition, written in Julia.\n\nThe bandwidth of an nn matrix A is the minimum non-negative integer k  0 1  n - 1 such that Ai j = 0 whenever i - j  k. Reordering the rows and columns of a matrix to reduce its bandwidth has many practical applications in engineering and scientific computing: it can improve performance when solving linear systems, approximating partial differential equations, optimizing circuit layout, and more [Maf14, p. 184]. There are two variants of this problem: minimization, which involves finding a permutation matrix P such that the bandwidth of PAPᵀ is minimized, and recognition, which entails determining whether there exists a permutation matrix P such that the bandwidth of PAPᵀ is at most some fixed non-negative integer (an optimal permutation that fully minimizes the bandwidth of A is not required).\n\nMany matrix bandwidth reduction algorithms exist in the literature, but implementations in the open-source ecosystem are scarce, with those that do exist primarily tackling older, less efficient algorithms. The Boost libraries in C++, the NetworkX library in Python, and the MATLAB standard library all only implement the reverse Cuthill–McKee algorithm from 1971. This gap in the ecosystem not only makes it difficult for theoretical researchers to benchmark and compare new proposed algorithms but also precludes the application of the most performant modern algorithms in real-life industry settings. MatrixBandwidth.jl aims to bridge this gap by presenting a unified interface for matrix bandwidth reduction algorithms in Julia, designed with extensibility to further methods in mind.\n\nThe following matrix bandwidth reduction algorithms are currently available:\n\nMinimization\nExact\nDel Corso–Manzini (Minimization.DelCorsoManzini)\nDel Corso–Manzini with perimeter search   (Minimization.DelCorsoManziniWithPS)\nCaprara–Salazar-González (Minimization.CapraraSalazarGonzalez)\nSaxe–Gurari–Sudborough (Minimization.SaxeGurariSudborough)\nBrute-force search (Minimization.BruteForceSearch)\nHeuristic\nGibbs–Poole–Stockmeyer (Minimization.GibbsPooleStockmeyer)\nCuthill–McKee (Minimization.CuthillMcKee)\nReverse Cuthill–McKee (Minimization.ReverseCuthillMcKee)\nRecognition\nDel Corso–Manzini (Recognition.DelCorsoManzini)\nDel Corso–Manzini with perimeter search (Recognition.DelCorsoManziniWithPS)\nCaprara–Salazar-González (Recognition.CapraraSalazarGonzalez)\nSaxe–Gurari–Sudborough (Recognition.SaxeGurariSudborough)\nBrute-force search (Recognition.BruteForceSearch)\n\nRecognition algorithms determine whether any row-and-column permutation of a matrix induces bandwidth less than or equal to some fixed integer. Exact minimization algorithms always guarantee optimal orderings to minimize bandwidth, while heuristic minimization algorithms produce near-optimal solutions more quickly. Metaheuristic minimization algorithms employ iterative search frameworks to find better solutions than heuristic methods (albeit more slowly); no such algorithms are already implemented, but several (e.g., simulated annealing) are currently under development.\n\nThis package also exports several additional core functions, including (but not limited to) bandwidth and profile to compute the original bandwidth and profile of a matrix prior to any reordering.\n\nThe full documentation is available at GitHub Pages.\n\nReferences\n\n[Maf14]: L. O. Mafteiu-Scai. The Bandwidths of a Matrix. A Survey of Algorithms.   Annals of West University of Timisoara - Mathematics and Computer Science 52,   183–223 (2014). https://doi.org/10.2478/awutm-2014-0019.\n\n\n\n\n\n","category":"module"},{"location":"public_api/#MatrixBandwidth.AbstractAlgorithm","page":"Public API","title":"MatrixBandwidth.AbstractAlgorithm","text":"AbstractAlgorithm\n\nAbstract base type for all matrix bandwidth reduction algorithms.\n\nInterface\n\nConcrete subtypes of AbstractAlgorithm must implement the following methods:\n\nBase.summary(::T) where {T<:AbstractAlgorithm}: returns a String indicating the name   of the algorithm (e.g., \"Gibbs–Poole–Stockmeyer\").\n_requires_structural_symmetry(::T) where {T<:AbstractAlgorithm}: returns a Bool   indicating whether the algorithm requires the input matrix to be structurally symmetric.\n\nDirect subtypes of AbstractAlgorithm must implement the following method:\n\n_problem(::T) where {T<:AbstractAlgorithm}: returns a Symbol indicating the   matrix bandwidth problem tackled by the algorithm (e.g., :minimization).\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.AbstractResult","page":"Public API","title":"MatrixBandwidth.AbstractResult","text":"AbstractResult\n\nAbstract base type for all matrix bandwidth reduction results.\n\nInterface\n\nConcrete subtypes of AbstractResult must implement parametric types\n\nA<:AbstractAlgorithm;\nM<:AbstractMatrix{<:Number}; and\nO<:Union{Nothing,Vector{Int}},\n\nalongside the following fields:\n\nalgorithm::A: the algorithm used to investigate the bandwidth.\nmatrix::M: the matrix whose bandwidth is investigated.\nordering::O: the corresponding ordering of the rows and columns, if a relevant one is   found; otherwise, nothing.\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.bandwidth-Tuple{AbstractMatrix{<:Number}}","page":"Public API","title":"MatrixBandwidth.bandwidth","text":"bandwidth(A) -> Int\n\nCompute the bandwidth of A before any permutation of its rows and columns.\n\nThe bandwidth of an nn matrix A is the minimum non-negative integer k  0 1  n - 1 such that Ai j = 0 whenever i - j  k.\n\nIn contrast to minimize_bandwidth, this function does not attempt to minimize the bandwidth of A by permuting its rows and columns—it simply computes its bandwidth as is.\n\nArguments\n\nA::AbstractMatrix{<:Number}: the (square) matrix whose bandwidth is computed.\n\nReturns\n\n::Int: the bandwidth of A.\n\nPerformance\n\nGiven an nn input matrix, this relatively simple algorithm runs in O(n²) time.\n\nExamples\n\nbandwidth correctly identifies the bandwidth of a pentadiagonal matrix as 2 and does not attempt to find a minimizing permutation upon shuffling of its rows and columns:\n\njulia> using Random\n\njulia> Random.seed!(242622);\n\njulia> (n, k) = (8, 2);\n\njulia> perm = randperm(n);\n\njulia> A = (!iszero).(MatrixBandwidth.random_banded_matrix(n, k))\n8×8 BitMatrix:\n 1  0  0  0  0  0  0  0\n 0  1  0  1  0  0  0  0\n 0  0  0  1  1  0  0  0\n 0  1  1  1  0  1  0  0\n 0  0  1  0  0  0  0  0\n 0  0  0  1  0  0  0  0\n 0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0\n\njulia> bandwidth(A)\n2\n\njulia> A_shuffled = A[perm, perm]\n8×8 BitMatrix:\n 0  0  0  0  0  0  1  0\n 0  0  0  0  0  0  0  0\n 0  0  0  1  0  0  0  0\n 0  0  1  0  0  0  1  0\n 0  0  0  0  1  0  0  0\n 0  0  0  0  0  1  1  0\n 1  0  0  1  0  1  1  0\n 0  0  0  0  0  0  0  0\n\njulia> bandwidth(A_shuffled)\n6\n\nNotes\n\nSome texts define matrix bandwidth to be the minimum non-negative integer k such that Ai j = 0 whenever i - j  k instead, particularly in more mathematically-minded communities. Effectively, this definition treats diagonal matrices as bandwidth 1, tridiagonal matrices as bandwidth 2, and so on. Our definition, on the other hand, is more common in computer science contexts, treating diagonal matrices as bandwidth 0 and tridiagonal matrices as bandwidth 1. (Both definitions, however, agree that the bandwidth of an empty matrix is simply 0.)\n\n\n\n\n\n","category":"method"},{"location":"public_api/#MatrixBandwidth.bandwidth_lower_bound-Tuple{AbstractMatrix{<:Number}}","page":"Public API","title":"MatrixBandwidth.bandwidth_lower_bound","text":"bandwidth_lower_bound(A) -> Int\n\nCompute a lower bound on the bandwidth of A using [CS05, pp. 359–60]'s results.\n\nA is assumed to be structurally symmetric, since the bound from [CS05, pp.359–60] was discovered in the context of undirected graphs (whose adjacency matrices are symmetric). Since the original algorithm is defined only for connected graphs, we compute the bound on each connected component of the graph represented by A and return the maximum of these.\n\nThe bandwidth of an nn matrix A is the minimum non-negative integer k  0 1  n - 1 such that Ai j = 0 whenever i - j  k.\n\nIn contrast to minimize_bandwidth, this function does not attempt to truly minimize the bandwidth of A—it simply returns a lower bound on its bandwidth up to symmetric permutation of its rows and columns. This bound is not generally tight, but it indeed matches the true minimum in many non-trivial cases and is easily computable in O(n³) time (dominated by the Floyd–Warshall algorithm call; the core logic itself runs in O(n²) time).\n\nArguments\n\nA::AbstractMatrix{<:Number}: the (square) matrix on whose bandwidth a lower bound is to   be computed. A must be structurally symmetric (i.e., A[i, j] must be nonzero if   and only if A[j, i] is nonzero for 1  i j  n).\n\nReturns\n\n::Int: a lower bound on the bandwidth of A. (This bound is tight in many non-trivial   cases but not universally so.)\n\nExamples\n\njulia> using Random, SparseArrays, Combinatorics\n\njulia> Random.seed!(21);\n\njulia> (n, p) = (9, 0.4);\n\njulia> A = sprand(n, n, p);\n\njulia> A = A + A' # Ensure structural symmetry;\n\njulia> minimize_bandwidth(A, Minimization.BruteForceSearch())\nResults of Bandwidth Minimization Algorithm\n * Algorithm: Brute-force search\n * Approach: exact\n * Minimum Bandwidth: 5\n * Original Bandwidth: 8\n * Matrix Size: 9×9\n\njulia> bandwidth_lower_bound(A) # Always less than or equal to the true minimum bandwidth\n4\n\nNotes\n\nSome texts define matrix bandwidth to be the minimum non-negative integer k such that Ai j = 0 whenever i - j  k instead, particularly in more mathematically-minded communities. Effectively, this definition treats diagonal matrices as bandwidth 1, tridiagonal matrices as bandwidth 2, and so on. Our definition, on the other hand, is more common in computer science contexts, treating diagonal matrices as bandwidth 0 and tridiagonal matrices as bandwidth 1. (Both definitions, however, agree that the bandwidth of an empty matrix is simply 0.)\n\nReferences\n\n[CS05]: A. Caprara and J.-J. Salazar-González. Laying Out Sparse Graphs with   Provably Minimum Bandwidth. INFORMS Journal on Computing 17, 356–73 (2005).   https://doi.org/10.1287/ijoc.1040.0083.\n\n\n\n\n\n","category":"method"},{"location":"public_api/#MatrixBandwidth.profile-Tuple{AbstractMatrix{<:Number}}","page":"Public API","title":"MatrixBandwidth.profile","text":"profile(A) -> Int\n\nCompute the profile of A before any permutation of its rows and columns.\n\nThe profile of a structurally symmetric nn matrix A is traditionally defined as the sum of the distances from each diagonal entry to the leftmost nonzero entry in that row—in other words, ᵢ₁ⁿ (i - fᵢ), where each fᵢ is the smallest index such that Ai fᵢ  0 [Maf14, pp. 187-88]. Generalizing this property to all square matrices, we define the column profile of a matrix to be the sum of the distances from each diagonal entry to the farthest (not necessarily topmost) nonzero entry in that column and the row profile to be the sum of the distances from each diagonal entry to the farthest (not necessarily leftmost) nonzero entry in that row. (Note that both of these properties are equal to traditional matrix profile for structurally symmetric matrices.)\n\nOne of the most common contexts in which matrix profile is relevant is sparse matrix storage, where lower-profile matrices occupy less space in memory [Maf14, p.188]. Since the SparseArrays.jl standard library package defaults to compressed sparse column storage over compressed sparse row, we therefore compute column profile by default unless the dimension is otherwise specified.\n\nArguments\n\nA::AbstractMatrix{<:Number}: the (square) matrix whose profile is computed.\n\nKeyword Arguments\n\ndim::Symbol=:col: the dimension along which the profile is computed; must be either   :col (the default) or :row.\n\nReturns\n\n::Int: the profile of A along the specified dimension.\n\nPerformance\n\nGiven an nn input matrix, this relatively simple algorithm runs in O(n²) time.\n\nExamples\n\nprofile computes the column profile of a matrix by default:\n\njulia> using Random, SparseArrays\n\njulia> Random.seed!(2287);\n\njulia> (n, p) = (25, 0.05);\n\njulia> A = sprand(n, n, p)\n25×25 SparseMatrixCSC{Float64, Int64} with 29 stored entries:\n⎡⠀⠀⠀⠀⠀⠀⠐⠀⠒⠀⡀⠀⠀⎤\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠂⠐⠂⎥\n⎢⠀⠀⠀⢀⠌⠀⠀⠀⢀⠈⠀⠀⠀⎥\n⎢⠠⢄⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠂⡀⠀⠀⠌⠀⠈⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠢⡀⢄⡈⠀⠀⠀⎥\n⎣⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⎦\n\njulia> profile(A)\n211\n\nThe dimension (:row or :col) can also be explicitly specified:\n\njulia> using Random, SparseArrays\n\njulia> Random.seed!(3647);\n\njulia> (n, p) = (25, 0.05);\n\njulia> A = sprand(n, n, p)\n25×25 SparseMatrixCSC{Float64, Int64} with 31 stored entries:\n⎡⠄⠀⠀⠀⠀⠀⠀⠘⠀⠀⠀⠁⠀⎤\n⎢⠄⢀⠀⠀⠁⠀⠀⠀⠀⢀⠀⠀⠀⎥\n⎢⠀⢀⡂⠀⠀⠀⠀⠀⠀⠀⠀⡄⠀⎥\n⎢⠀⠀⠀⠀⠀⡀⠂⠀⠀⠀⠀⠀⠀⎥\n⎢⠁⠀⠁⠀⠁⠀⠀⠁⠄⢀⠈⠀⠀⎥\n⎢⠂⠐⠐⠐⠠⠀⠄⠀⠀⠀⠠⣀⠀⎥\n⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎦\n\njulia> profile(A, dim=:row)\n147\n\njulia> profile(A, dim=:col)\n175\n\nReferences\n\n[Maf14]: L. O. Mafteiu-Scai. The Bandwidths of a Matrix. A Survey of Algorithms.   Annals of West University of Timisoara - Mathematics and Computer Science 52,   183–223 (2014). https://doi.org/10.2478/awutm-2014-0019.\n\n\n\n\n\n","category":"method"},{"location":"public_api/#MatrixBandwidth.Minimization","page":"Public API","title":"MatrixBandwidth.Minimization","text":"","category":"section"},{"location":"public_api/#MatrixBandwidth.Minimization","page":"Public API","title":"MatrixBandwidth.Minimization","text":"MatrixBandwidth.Minimization\n\nExact, heuristic, and metaheuristic algorithms for matrix bandwidth minimization in Julia.\n\nThe bandwidth of an nn matrix A is the minimum non-negative integer k  0 1  n - 1 such that Ai j = 0 whenever i - j  k. The matrix bandwidth minimization problem involves finding a permutation matrix P such that the bandwidth of PAPᵀ is minimized.\n\nThe following matrix bandwidth minimization algorithms are currently available:\n\nExact\nDel Corso–Manzini (DelCorsoManzini)\nDel Corso–Manzini with perimeter search (DelCorsoManziniWithPS)\nCaprara–Salazar-González (CapraraSalazarGonzalez)\nSaxe–Gurari–Sudborough (SaxeGurariSudborough)\nBrute-force search (BruteForceSearch)\nHeuristic\nGibbs–Poole–Stockmeyer (GibbsPooleStockmeyer)\nCuthill–McKee (CuthillMcKee)\nReverse Cuthill–McKee (ReverseCuthillMcKee)\n\nExact minimization algorithms always guarantee optimal orderings to minimize bandwidth, while heuristic minimization algorithms produce near-optimal solutions more quickly. Metaheuristic minimization algorithms employ iterative search frameworks to find better solutions than heuristic methods (albeit more slowly); no such algorithms are already implemented, but several (e.g., simulated annealing) are currently under development.\n\nThis submodule is part of the MatrixBandwidth.jl package.\n\n\n\n\n\n","category":"module"},{"location":"public_api/#MatrixBandwidth.Minimization.AbstractSolver","page":"Public API","title":"MatrixBandwidth.Minimization.AbstractSolver","text":"AbstractSolver <: AbstractAlgorithm\n\nAbstract base type for all matrix bandwidth minimization solvers.\n\nInterface\n\nAs per the interface of supertype AbstractAlgorithm, concrete subtypes of AbstractSolver must implement the following methods:\n\nBase.summary(::T) where {T<:AbstractSolver}: returns a String indicating the name   of the solver (e.g., \"Gibbs–Poole–Stockmeyer\").\n_requires_structural_symmetry(::T) where {T<:AbstractSolver}: returns a Bool   indicating whether the solver requires the input matrix to be structurally symmetric.\n\nDirect subtypes of AbstractSolver must implement the following method:\n\n_approach(::T) where {T<:AbstractSolver}: returns a Symbol indicating the   category of solver (e.g., :heuristic).\n\nSupertype Hierarchy\n\nAbstractSolver <: AbstractAlgorithm\n\nNotes\n\nTo implement a new matrix bandwidth minimization algorithm, define a new concrete subtype of AbstractSolver (or of one of its abstract subtypes like MetaheuristicSolver) then implement a corresponding _minimize_bandwidth_impl(::AbstractMatrix{Bool}, ::NewSolverType) method. Do not attempt to directly implement a new minimize_bandwidth method, as the function contains common preprocessing logic independent of the specific algorithm used.\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Minimization.MinimizationResult","page":"Public API","title":"MatrixBandwidth.Minimization.MinimizationResult","text":"MinimizationResult{A,M,O} <: AbstractResult\n\nOutput struct for matrix bandwidth minimization results.\n\nFields\n\nalgorithm::A<:AbstractSolver: the solver used to minimize the bandwidth.\nmatrix::M<:AbstractMatrix{<:Number}: the original matrix whose bandwidth is minimized.\nordering::O<:Vector{Int}: the (near-)optimal ordering of the rows and columns.\nbandwidth::Int: the minimized bandwidth of the matrix.\napproach::Symbol: the approach used by the solver. (Should be one of :exact,   :heuristic, and :metaheuristic.)\n\nConstructors\n\nMinimizationResult(algorithm, matrix, ordering, bandwidth): constructs a new   MinimizationResult instance with the given fields. The approach field is   automatically determined based on the algorithm type.\n\nSupertype Hierarchy\n\nMinimizationResult <: AbstractResult\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Minimization.minimize_bandwidth","page":"Public API","title":"MatrixBandwidth.Minimization.minimize_bandwidth","text":"minimize_bandwidth(A, solver=GibbsPooleStockmeyer()) -> MinimizationResult\n\nMinimize the bandwidth of A using the algorithm defined by solver.\n\nThe bandwidth of an nn matrix A is the minimum non-negative integer k  0 1  n - 1 such that Ai j = 0 whenever i - j  k.\n\nThis function computes a (near-)optimal ordering π of the rows and columns of A so that the bandwidth of PAPᵀ is minimized, where P is the permutation matrix corresponding to π. This is known to be an NP-complete problem; however, several heuristic algorithms such as Gibbs–Poole–Stockmeyer run in polynomial time while still still producing near-optimal orderings in practice. Exact methods like Caprara–Salazar-González are also available, but they are at least exponential in time complexity and thus only feasible for relatively small matrices.\n\nArguments\n\nA::AbstractMatrix{<:Number}: the (square) matrix whose bandwidth is minimized.\nsolver::AbstractSolver: the matrix bandwidth minimization algorithm to use; defaults to   GibbsPooleStockmeyer. (See the Minimization module documentation for   a full list of supported solvers.)\n\nReturns\n\n::MinimizationResult: a struct containing the algorithm used, the original matrix A,   the (near-)optimal ordering of the rows and columns, and the minimized bandwidth.\n\nExamples\n\nMultiple algorithms to minimize the bandwidth of a given matrix are available. In particular, there are exact solvers (which always guarantee optimal solutions), heuristic solvers (which produce near-optimal solutions more quickly than exact methods), and metaheuristic solvers (which employ iterative search frameworks to find better solutions than heuristic methods, but even more slowly).\n\nCertainly, exact solvers will always produce the same optimal bandwidth (but likely different orderings):\n\njulia> using Random, SparseArrays\n\njulia> Random.seed!(38);\n\njulia> (n, p) = (20, 0.05);\n\njulia> A = sprand(n, n, p);\n\njulia> A = A .+ A' # Ensure structural symmetry\n20×20 SparseMatrixCSC{Float64, Int64} with 36 stored entries:\n⎡⠀⠀⠀⠀⠀⣎⠁⠈⠀⠂⎤\n⎢⠀⠀⠀⠀⡀⠐⠀⠀⠀⠠⎥\n⎢⡠⢤⢀⠈⠠⠂⠀⠀⠔⠀⎥\n⎢⡁⠀⠀⠀⠀⠀⠀⠀⡀⠐⎥\n⎣⠠⠀⠀⡀⠐⠁⢀⠈⢐⠔⎦\n\njulia> res_dcm = minimize_bandwidth(A, Minimization.DelCorsoManzini())\nResults of Bandwidth Minimization Algorithm\n * Algorithm: Del Corso–Manzini\n * Approach: exact\n * Minimum Bandwidth: 3\n * Original Bandwidth: 17\n * Matrix Size: 20×20\n\njulia> A[res_dcm.ordering, res_dcm.ordering]\n20×20 SparseMatrixCSC{Float64, Int64} with 36 stored entries:\n⎡⠠⠂⠤⡀⠀⠀⠀⠀⠀⠀⎤\n⎢⠀⠣⡁⠈⠀⡀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠠⡤⠋⠤⡀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠣⡀⡨⠢⡀⎥\n⎣⠀⠀⠀⠀⠀⠀⠈⠢⠁⠀⎦\n\njulia> res_sgs = minimize_bandwidth(A, Minimization.SaxeGurariSudborough())\nResults of Bandwidth Minimization Algorithm\n * Algorithm: Saxe–Gurari–Sudborough\n * Approach: exact\n * Minimum Bandwidth: 3\n * Original Bandwidth: 17\n * Matrix Size: 20×20\n\njulia> A[res_sgs.ordering, res_sgs.ordering]\n20×20 SparseMatrixCSC{Float64, Int64} with 36 stored entries:\n⎡⠀⡠⠀⠀⠀⠀⠀⠀⠀⠀⎤\n⎢⠀⠀⠔⣡⠢⡀⠀⠀⠀⠀⎥\n⎢⠀⠀⠈⠢⡀⡨⣀⡀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠸⡀⠈⢂⡀⎥\n⎣⠀⠀⠀⠀⠀⠀⠈⠰⠄⡡⎦\n\nHowever, the answers of (meta)heuristic solvers may differ from each other:\n\njulia> using Random, SparseArrays\n\njulia> Random.seed!(405);\n\njulia> (n, p) = (400, 0.002);\n\njulia> A = sprand(n, n, p);\n\njulia> A = A .+ A' # Ensure structural symmetry;\n\njulia> minimize_bandwidth(A, Minimization.GibbsPooleStockmeyer())\nResults of Bandwidth Minimization Algorithm\n * Algorithm: Gibbs–Poole–Stockmeyer\n * Approach: heuristic\n * Minimum Bandwidth: 31\n * Original Bandwidth: 380\n * Matrix Size: 400×400\n\njulia> minimize_bandwidth(A, Minimization.ReverseCuthillMcKee())\nResults of Bandwidth Minimization Algorithm\n * Algorithm: Reverse Cuthill–McKee\n * Approach: heuristic\n * Minimum Bandwidth: 37\n * Original Bandwidth: 380\n * Matrix Size: 400×400\n\nIf no solver is specified, then the heuristic Gibbs–Poole–Stockmeyer algorithm is used by default:\n\njulia> using Random, SparseArrays\n\njulia> Random.seed!(80);\n\njulia> (n, p) = (500, 0.001);\n\njulia> A = sprand(n, n, p);\n\njulia> A = A .+ A' # Ensure structural symmetry\n500×500 SparseMatrixCSC{Float64, Int64} with 496 stored entries:\n⎡⠀⠀⠁⠐⠀⠀⠀⠄⠠⢐⠄⠀⡈⠀⠀⡆⠠⠑⠀⠰⠀⠀⠀⠐⠀⠄⠀⠀⡠⠀⠀⠀⠆⠐⠀⠄⢠⡈⠈⠀⎤\n⎢⢁⠀⠄⠁⠠⠊⠀⠀⠂⠀⡀⠂⠀⢀⠀⠀⠀⠈⠠⠠⠀⠠⠠⠀⠀⡀⠀⠁⡀⠀⡀⠐⠀⠄⠀⠀⠄⠂⡈⠠⎥\n⎢⠀⠀⡠⠂⠅⠁⠀⠀⠀⠀⠐⡁⠀⡀⠈⢈⠀⠐⠀⠀⠀⠀⠃⢀⠀⠀⠀⠀⠀⠀⠐⠀⠤⠁⠀⠁⠀⠀⠀⡀⎥\n⎢⠀⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠂⠀⠀⠠⠀⠂⠁⠀⠀⡐⠔⠂⠂⠀⠠⠀⠐⠀⠀⠄⠀⠄⠀⠀⡀⠀⢀⠁⠀⎥\n⎢⢀⢂⠈⠀⠀⠀⠀⠀⠎⠁⠄⠂⠀⠁⣀⠁⠈⠠⠀⠀⠂⠄⢀⠄⠀⠠⠀⠀⠉⠈⠀⠀⠀⠀⠠⠀⠀⠀⠀⡀⎥\n⎢⠀⠁⠠⠈⠔⠠⠠⠀⠠⠁⠊⠄⠀⢀⠀⠀⠠⠀⠠⡌⠀⠈⠀⠀⠀⠠⠈⠀⠀⠀⠂⠀⠀⠀⠀⠡⠀⠠⠠⢂⎥\n⎢⠂⠈⠀⢀⠀⠠⠀⠀⠄⠀⠀⢀⡐⠈⠀⠀⠀⠀⠀⠈⠐⠠⠀⠀⠀⠀⠀⡠⠑⠀⠂⠀⠀⠀⡀⠀⡐⠀⠄⠁⎥\n⎢⠠⠤⠀⠀⡂⢀⠀⠂⠄⠘⠀⠀⠀⠀⠀⠀⠀⠑⠀⠂⡄⠀⠄⠀⡁⡐⠁⠠⠂⠀⠀⠐⠀⠀⠁⠀⠀⠁⠈⠀⎥\n⎢⢄⠂⡀⠀⢀⠀⠌⠀⠂⡀⠀⠂⠀⠀⢄⠀⠀⠀⠀⢀⠀⠀⢀⠄⡀⠂⠂⠀⠅⠀⠀⠀⠀⠁⠀⢀⠄⠀⠀⠀⎥\n⎢⢀⡀⠀⡂⠀⠀⠀⠀⠀⠀⡀⠦⡀⠀⠠⠀⠀⢀⠀⠀⠀⠀⠐⠀⠀⠀⠀⠀⠀⡐⢀⢀⠁⠔⠆⠀⠀⠀⢀⠅⎥\n⎢⠀⠀⠀⡀⠀⠀⢐⠌⠈⠄⡀⠀⠐⡀⠀⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⠌⡀⠀⠀⠀⠀⠀⠀⠂⎥\n⎢⢀⠀⠀⠂⠉⢀⠨⠀⠀⠔⠀⠀⠀⠀⠀⠁⠀⠔⠐⠀⠀⠀⠀⡠⠠⠀⠰⠀⠠⠘⠀⠐⠀⡀⠁⠠⠀⡑⠀⠀⎥\n⎢⠀⠄⠀⠠⠀⠀⠀⡀⠀⡀⠀⡀⠀⠀⢁⠨⠠⠈⠀⠀⠀⠀⠀⠂⠀⠀⠁⠀⠁⠂⠄⠀⠠⠀⠀⠀⠀⠀⡀⠀⎥\n⎢⠀⠀⠄⠀⠀⠀⢀⠀⠀⠀⠂⠀⠀⡠⠁⡀⠈⠀⠀⠀⠀⠠⠐⠂⠁⠀⠀⠀⢁⠊⠠⠀⢀⠀⠀⠀⠰⠌⠀⠀⎥\n⎢⠀⠊⠀⠈⠀⠀⠀⠀⡃⠀⠀⠀⠑⠀⠈⠀⠁⠁⢀⠠⠀⠀⣀⠂⠡⠀⡡⠐⠀⠀⠀⠐⠂⠰⠀⠠⠀⠀⠂⠀⎥\n⎢⠀⠀⢀⠈⠐⠀⠀⠁⠀⠀⠈⠀⠈⠀⢀⠀⠀⠀⠀⢐⡀⠄⢀⠀⠀⠁⠀⠂⢀⠀⠤⠃⠀⠐⠀⠀⠀⠈⠀⠀⎥\n⎢⢈⠁⠀⠄⠄⠃⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠄⠀⢁⠄⠀⠈⠀⠠⠀⠂⠀⠐⢈⡀⢀⠀⠄⠁⠀⠈⠀⠆⠀⠀⎥\n⎢⠀⠄⠀⠀⠄⠀⠀⠠⠀⠂⠄⡀⠀⠈⠁⠀⠀⢀⠈⠁⠀⠀⠁⡀⠀⠀⠀⠀⠀⡀⠀⠀⡀⠀⢠⠒⠈⠀⠀⠀⎥\n⎢⡀⠲⠠⠁⠀⠀⠀⢀⠀⠀⠀⡀⠐⠈⠄⠀⠀⠁⠀⠀⠀⠀⢄⠠⠀⠀⡐⠆⠀⠀⡀⠀⠠⠄⠂⠀⠤⠃⠀⠁⎥\n⎣⠂⠀⠂⡈⠀⠠⠁⠀⠀⠠⠠⢂⠄⠁⠂⠀⠀⠀⠄⠔⠠⠀⠀⠀⠀⠈⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠄⠀⠁⠀⎦\n\njulia> res = minimize_bandwidth(A)\nResults of Bandwidth Minimization Algorithm\n * Algorithm: Gibbs–Poole–Stockmeyer\n * Approach: heuristic\n * Minimum Bandwidth: 6\n * Original Bandwidth: 487\n * Matrix Size: 500×500\n\njulia> A[res.ordering, res.ordering]\n500×500 SparseMatrixCSC{Float64, Int64} with 496 stored entries:\n⎡⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎤\n⎢⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠈⠑⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠐⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠊⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⢄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠱⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠱⢆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠱⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⢆⡀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⢆⡀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⎥\n⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⎦\n\nNotes\n\nTo implement a new matrix bandwidth minimization algorithm, define a new concrete subtype of AbstractSolver (or of one of its abstract subtypes like MetaheuristicSolver) then implement a corresponding _minimize_bandwidth_impl(::AbstractMatrix{Bool}, ::NewSolverType) method. Do not attempt to directly implement a new minimize_bandwidth method, as the function contains common preprocessing logic independent of the specific algorithm used.\n\nNote also that some texts define matrix bandwidth to be the minimum non-negative integer k such that Ai j = 0 whenever i - j  k instead, particularly in more mathematically-minded communities. Effectively, this definition treats diagonal matrices as bandwidth 1, tridiagonal matrices as bandwidth 2, and so on. Our definition, on the other hand, is more common in computer science contexts, treating diagonal matrices as bandwidth 0 and tridiagonal matrices as bandwidth 1. (Both definitions, however, agree that the bandwidth of an empty matrix is simply 0.)\n\n\n\n\n\n","category":"function"},{"location":"public_api/#MatrixBandwidth.Minimization.Exact","page":"Public API","title":"MatrixBandwidth.Minimization.Exact","text":"","category":"section"},{"location":"public_api/#MatrixBandwidth.Minimization.Exact","page":"Public API","title":"MatrixBandwidth.Minimization.Exact","text":"MatrixBandwidth.Minimization.Exact\n\nExact solvers for matrix bandwidth minimization.\n\nExact methods are those which guarantee an optimal ordering producing the true minimum bandwidth of a matrix. Since bandwidth minimization is an NP-complete problem, existing exact algorithms are, at best, exponential in time complexity—much worse than many polynomial-time heuristic approaches (e.g., Gibbs–Poole–Stockmeyer). Such methods, therefore, are not feasible for large matrices, but they remain useful when precise solutions are required for small-to-medium-sized inputs (say, up to 100100).\n\nThe following exact matrix bandwidth minimization algorithms are currently available:\n\nDel Corso–Manzini (DelCorsoManzini)\nDel Corso–Manzini with perimeter search (DelCorsoManziniWithPS)\nCaprara–Salazar-González (CapraraSalazarGonzalez)\nSaxe–Gurari–Sudborough (SaxeGurariSudborough)\nBrute-force search (BruteForceSearch)\n\nThis submodule is part of the MatrixBandwidth.Minimization submodule of the MatrixBandwidth.jl package.\n\n\n\n\n\n","category":"module"},{"location":"public_api/#MatrixBandwidth.Minimization.Exact.BruteForceSearch","page":"Public API","title":"MatrixBandwidth.Minimization.Exact.BruteForceSearch","text":"BruteForceSearch <: ExactSolver <: AbstractSolver <: AbstractAlgorithm\n\nThe simplest exact method for minimizing the bandwidth of a matrix is to iterate over all possible symmetric permutations and compare the bandwidths they induce.\n\nSince i₁ i₂  iₙ induces the same bandwidth as iₙ iₙ₁  i₁, we restrict our search to orderings such that i₁  iₙ (with equality checked just in case n = 1).\n\nSupertype Hierarchy\n\nBruteForceSearch <: ExactSolver <: AbstractSolver <: MatrixBandwidth.AbstractAlgorithm\n\nPerformance\n\nGiven an nn input matrix A, this brute-force algorithm runs in O(n  n²) time:\n\nPrecisely n2 permutations are checked (except when n = 1, in which case   1 = 1 permutation is checked). This is, clearly, O(n).\nFor each permutation, the bandwidth function is called on view(A, perm, perm),   which takes O(n²) time.\nTherefore, the overall time complexity is O(n  n²).\n\nIndeed, due to the need to exhaustively check all permutations, this is close to a lower bound as well on the the algorithm's time complexity. (The only reason we cannot claim to have a precise value for the big-Θ complexity is that the bandwidth function is not exactly Θ(n²), although it is close.)\n\nExamples\n\nThe algorithm always iterates over all possible permutations, so it is infeasible to go above 99 or 1010 without incurring multiple-hour runtimes. Nevertheless, we see that it is quite effective for, say, 88:\n\njulia> using Random, SparseArrays\n\njulia> Random.seed!(628318);\n\njulia> (n, p) = (8, 0.2);\n\njulia> A = sprand(n, n, p);\n\njulia> A = A + A' # Ensure structural symmetry;\n\njulia> minimize_bandwidth(A, Minimization.BruteForceSearch())\nResults of Bandwidth Minimization Algorithm\n * Algorithm: Brute-force search\n * Approach: exact\n * Minimum Bandwidth: 3\n * Original Bandwidth: 6\n * Matrix Size: 8×8\n\nNotes\n\nBrute force is by far the slowest approach to matrix bandwidth minimization and should only be used in very niche cases (like verifying the correctness of other algorithms in unit tests). For 1010 matrices, the algorithm already takes several minutes to run (between 2 to 5 on most commercial machines) and allocates over 4 gigabytes of memory. Given the O(n  n²) time complexity, minimizing the bandwidth of any 1111 matrix would take over an hour.\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Minimization.Exact.CapraraSalazarGonzalez","page":"Public API","title":"MatrixBandwidth.Minimization.Exact.CapraraSalazarGonzalez","text":"CapraraSalazarGonzalez <: ExactSolver <: AbstractSolver <: AbstractAlgorithm\n\nThe Caprara–Salazar-González minimization algorithm is an exact method for minimizing the bandwidth of a structurally symmetric matrix A. For a fixed k  ℕ, the algorithm performs a depth-first search of all partial orderings of the rows and columns of A, adding indices one at a time. Partial orderings are pruned not only by ensuring that adjacent pairs of currently placed indices are within k of each other but also by employing a branch-and-bound framework with lower bounds on bandwidth compatibility computed via integer linear programming relaxations. This search is repeated with incrementing values of k until a bandwidth-k ordering is found [CS05], with k initialized to some lower bound on the minimum bandwidth of A up to symmetric permutation.\n\nSpecifically, this implementation of the Caprara–Salazar-González algorithm uses the min(α(A) γ(A)) lower bound from the original paper [CS05, pp. 359–60] as the initial value of k. (Further implementation details can be found in the source code for bandwidth_lower_bound.)\n\nAs noted above, the Caprara–Salazar-González algorithm requires structurally symmetric input (that is, Ai j must be nonzero if and only if Aj i is nonzero for 1  i j  n).\n\nSupertype Hierarchy\n\nCapraraSalazarGonzalez <: ExactSolver <: AbstractSolver <: MatrixBandwidth.AbstractAlgorithm\n\nPerformance\n\nGiven an nn input matrix, the Caprara–Salazar-González algorithm runs in O(n  n  Tᵢₗₚ(n n²)) time, where Tᵢₗₚ(n m) is the time taken to solve an  integer linear programming (ILP) problem with O(n) variables and O(m) constraints:\n\nFor each underlying \"bandwidth ≤ k\" check, we perform a depth-first search of   O(n) partial orderings.\nAt each search node, we solve ILP relaxations with n variables and O(n²)   constraints (given by the number of nonzero entries in the computed distance matrix),   taking Tᵢₗₚ(n n²) time. (This dominates the O(n²) auxiliary computations needed   to set up the ILP.) Thus, the overall time complexity for each value of k is   O(n  Tᵢₗₚ(n n²)).\nThe difference between the maximum possible bandwidth (n - 1) and our initial lower   bound grows linearly in n, so we run the underlying O(n  Tᵢₗₚ(n n²))   recognition algorithm O(n) times.\nTherefore, the overall time complexity is O(n  n  Tᵢₗₚ(n n²)).\n\nNote that Tᵢₗₚ(n n²) has worst-case complexity O(2ⁿ), although this ultimately depends on the ILP solver used. (Here, we use the HiGHS solver from the HiGHS.jl package.)\n\nOf course, this is all but an upper bound on the time complexity of Caprara–Salazar-González, achieved only in the most pathological of cases. In practice, efficient pruning techniques and compatibility checks—along with [CS05, pp. 359–60]'s relatively tight initial lower bound on the minimum bandwidth—result in approximately exponential growth in time complexity with respect to n.\n\nExamples\n\nWe verify the optimality of the ordering found by Caprara–Salazar-González for a random 88 matrix via a brute-force search over all possible permutations up to reversal:\n\njulia> using Random, SparseArrays\n\njulia> Random.seed!(5883);\n\njulia> (n, p) = (8, 0.25);\n\njulia> A = sprand(n, n, p);\n\njulia> A = A + A' # Ensure structural symmetry;\n\njulia> res_bf = minimize_bandwidth(A, Minimization.BruteForceSearch())\nResults of Bandwidth Minimization Algorithm\n * Algorithm: Brute-force search\n * Approach: exact\n * Minimum Bandwidth: 4\n * Original Bandwidth: 7\n * Matrix Size: 8×8\n\njulia> res_csg = minimize_bandwidth(A, Minimization.CapraraSalazarGonzalez())\nResults of Bandwidth Minimization Algorithm\n * Algorithm: Caprara–Salazar-González\n * Approach: exact\n * Minimum Bandwidth: 4\n * Original Bandwidth: 7\n * Matrix Size: 8×8\n\nNotes\n\nFor readers of the original paper, what we call the Caprara–Salazar-González algorithm here is designated the LAYOUT_LEFT_TO_RIGHT algorithm in [CS05]. The paper also describes a LAYOUT_BOTH_WAYS algorithm that performs a bidirectional search by adding indices to both the left and right ends of the current partial ordering. However, this version is considerably more complex to implement, and we ran into problems enforcing ILP constraints on node pairs added to opposite ends of the ordering. In any case, computational results demonstrate that neither LAYOUT_LEFT_TO_RIGHT nor LAYOUT_BOTH_WAYS is consistently faster, and the paper states that there is no known heuristic for determining which version will be more performant for a given input [CS05, pp. 368–69]. Therefore, we opt to implement only LAYOUT_LEFT_TO_RIGHT as a matter of practicality, although future developers may wish to extend the interface with LAYOUT_BOTH_WAYS as well.\n\nA final implementation detail worth noting is that we use HiGHS as our solver; it is one of the fastest open-source solvers available for mixed-integer linear programming.\n\nReferences\n\n[CS05]: A. Caprara and J.-J. Salazar-González. Laying Out Sparse Graphs with   Provably Minimum Bandwidth. INFORMS Journal on Computing 17, 356–73 (2005).   https://doi.org/10.1287/ijoc.1040.0083.\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Minimization.Exact.DelCorsoManzini","page":"Public API","title":"MatrixBandwidth.Minimization.Exact.DelCorsoManzini","text":"DelCorsoManzini <: ExactSolver <: AbstractSolver <: AbstractAlgorithm\n\nThe Del Corso–Manzini minimization algorithm is an exact method for minimizing the bandwidth of a structurally symmetric matrix A. For a fixed k  ℕ, the algorithm invokes a subroutine that determines whether A has bandwidth at most k up to symmetric permutation. This subroutine performs a depth-first search of all partial orderings of the rows and columns of A, adding indices one at a time. Partial orderings are pruned not only by ensuring that adjacent pairs of currently placed indices are within k of each other but also by tracking the latest positions at which the remaining indices can be placed. This search is repeated with incrementing values of k until a bandwidth-k ordering is found [DM99], with k initialized to some lower bound on the minimum bandwidth of A up to symmetric permutation.\n\nSpecifically, this implementation of the Del Corso–Manzini algorithm uses the min(α(A) γ(A)) lower bound from [CS05, pp. 359–60] as the initial value of k. (Further implementation details can be found in the source code for bandwidth_lower_bound.) This improves upon the original algorithm, which used the maximum number of nonzero off-diagonal entries in a single row as a lower bound on the minimum bandwidth of A up to symmetric permutation [DM99, p. 192–93].\n\nAs noted above, the Del Corso–Manzini algorithm requires structurally symmetric input (that is, Ai j must be nonzero if and only if Aj i is nonzero for 1  i j  n).\n\nSupertype Hierarchy\n\nDelCorsoManzini <: ExactSolver <: AbstractSolver <: MatrixBandwidth.AbstractAlgorithm\n\nPerformance\n\nGiven an nn input matrix, the Del Corso–Manzini algorithm runs in O(n  n³) time:\n\nFor each underlying \"bandwidth ≤ k\" check, we perform a depth-first search of   O(n) partial orderings.\nChecking plausibility of each partial ordering takes O(nk) time, resulting in   O(n  nk) steps for each value of k.\nThe difference between the maximum possible bandwidth (n - 1) and our initial lower   bound grows linearly in n, so we run the underlying O(n  nk) recognition   algorithm O(n) times.\nFinally, ₖ₀ⁿ¹ nk = O(n³), so the overall time complexity is O(n  n³).\n\nOf course, this is but an upper bound on the time complexity of Del Corso–Manzini, achieved only in the most pathological of cases. In practice, efficient pruning techniques and compatibility checks—along with [CS05, pp. 359–60]'s relatively tight initial lower bound on the minimum bandwidth—result in approximately exponential growth in time complexity with respect to n.\n\nBased on experimental results, the algorithm is feasible for nn matrices up to n  100 or so.\n\nExamples\n\nWe verify the optimality of the ordering found by Del Corso–Manzini for a random 99 matrix via a brute-force search over all possible permutations up to reversal:\n\njulia> using Random, SparseArrays\n\njulia> Random.seed!(0117);\n\njulia> (n, p) = (9, 0.5);\n\njulia> A = sprand(n, n, p);\n\njulia> A = A + A' # Ensure structural symmetry;\n\njulia> res_bf = minimize_bandwidth(A, Minimization.BruteForceSearch())\nResults of Bandwidth Minimization Algorithm\n * Algorithm: Brute-force search\n * Approach: exact\n * Minimum Bandwidth: 5\n * Original Bandwidth: 8\n * Matrix Size: 9×9\n\njulia> res_dcm = minimize_bandwidth(A, Minimization.DelCorsoManzini())\nResults of Bandwidth Minimization Algorithm\n * Algorithm: Del Corso–Manzini\n * Approach: exact\n * Minimum Bandwidth: 5\n * Original Bandwidth: 8\n * Matrix Size: 9×9\n\nWe now generate (and shuffle) a random 4040 matrix with minimum bandwidth 10 using MatrixBandwidth.random_banded_matrix. Del Corso–Manzini then finds a bandwidth-10 ordering, which is (we claim) optimal up to symmetric permutation. (In some cases, random_banded_matrix(n, k) does generate matrices with minimum bandwidth < k. Nevertheless, this example demonstrates that Del Corso–Manzini at the very least finds a quite good ordering, even though exact optimality—which is guaranteed by the original paper [DM99]—is not explicitly verified.)\n\njulia> using Random\n\njulia> Random.seed!(0201);\n\njulia> (n, k) = (40, 10);\n\njulia> A = MatrixBandwidth.random_banded_matrix(n, k);\n\njulia> perm = randperm(n);\n\njulia> A_shuffled = A[perm, perm];\n\njulia> bandwidth(A)\n10\n\njulia> bandwidth(A_shuffled) # Much larger after shuffling\n36\n\njulia> minimize_bandwidth(A_shuffled, Minimization.DelCorsoManzini())\nResults of Bandwidth Minimization Algorithm\n * Algorithm: Del Corso–Manzini\n * Approach: exact\n * Minimum Bandwidth: 10\n * Original Bandwidth: 36\n * Matrix Size: 40×40\n\nNotes\n\nFor readers of the original paper, what we call the Del Corso–Manzini minimization algorithm here is designated the \"MB-ID algorithm\" in [DM99, p. 191]. The so-called \"MB-PS algorithm,\" on the other hand, we implement in DelCorsoManziniWithPS.\n\nReferences\n\n[CS05]: A. Caprara and J.-J. Salazar-González. Laying Out Sparse Graphs with   Provably Minimum Bandwidth. INFORMS Journal on Computing 17, 356–73 (2005).   https://doi.org/10.1287/ijoc.1040.0083.\n[DM99]: G. M. Del Corso and G. Manzini. Finding Exact Solutions to the Bandwidth   Minimization Problem. Computing 62, 189–203 (1999).   https://doi.org/10.1007/s006070050002.\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Minimization.Exact.DelCorsoManziniWithPS","page":"Public API","title":"MatrixBandwidth.Minimization.Exact.DelCorsoManziniWithPS","text":"DelCorsoManziniWithPS{D} <: ExactSolver <: AbstractSolver <: AbstractAlgorithm\n\nThe Del Corso–Manzini minimization algorithm with perimeter search is an exact method for minimizing the bandwidth of a structurally symmetric matrix A. The base Del Corso–Manzini algorithm performs a depth-first search of all partial orderings of the rows and columns of A for some fixed k  ℕ, adding indices one at a time. Partial orderings are pruned not only by ensuring that adjacent pairs of currently placed indices are within k of each other but also by tracking the latest positions at which the remaining indices can be placed. This search is repeated with incrementing values of k until a bandwidth-k ordering is found [DM99], with k initialized to some lower bound on the minimum bandwidth of A up to symmetric permutation.\n\nThe incorporation of perimeter search to this approach entails precomputing a \"perimeter\" of d-permutations of row indices of A, where d is a positive integer passed as a parameter to the solver. Each permutation represents a way to select the last d entries of the ordering, and as the construction of the partial ordering progresses, potential endings are pruned to exclude those incompatible with already placed indices. In addition to pruning a potential ending if it contains indices already placed, compatibility is also checked via precomputed time stamps indicating, for each potential ending, a loose lower bound on the earliest position at which any given index can be placed should said ending be selected.\n\nLike our implementation of the base Del Corso–Manzini algorithm (see DelCorsoManzini), this implementation uses the min(α(A) γ(A)) lower bound from [CS05, pp. 359–60] as the initial value of k. (Further implementation details can be found in the source code for bandwidth_lower_bound.) This improves upon the original algorithm, which used the maximum number of nonzero off-diagonal entries in a single row as a lower bound on the minimum bandwidth of A up to symmetric permutation [DM99, p. 194].\n\nAs noted above, the Del Corso–Manzini algorithm with perimeter search requires structurally symmetric input (that is, Ai j must be nonzero if and only if Aj i is nonzero for 1  i j  n).\n\nFields\n\ndepth::D<:Union{Nothing,Int}: the perimeter search depth. If this field is not set (and)   thus automatically initialized to nothing), a default depth is automatically computed   by Recognition.dcm_ps_optimal_depth as a function of the input matrix every   time the solver is passed to MatrixBandwidth.Minimization.minimize_bandwidth.   Otherwise, it must be manually set to a positive integer.\n\nConstructors\n\nDelCorsoManziniWithPS(): constructs a new DelCorsoManziniWithPS instance with the   default perimeter search depth initialized to nothing.\nDelCorsoManziniWithPS(depth::Integer): constructs a new DelCorsoManziniWithPS instance   with the specified perimeter search depth. depth must be a positive integer.\n\nSupertype Hierarchy\n\nDelCorsoManziniWithPS <: ExactSolver <: AbstractSolver <: MatrixBandwidth.AbstractAlgorithm\n\nPerformance\n\nGiven an nn input matrix and perimeter search depth d, the Del Corso–Manzini algorithm with perimeter search runs in O(n  nᴰ¹) time, where Dᴰ = max(d 2):\n\nFor each underlying \"bandwidth ≤ k\" check, we perform a depth-first search of   O(n) partial orderings.\nChecking plausibility of each partial ordering takes O(nk) time, and checking   compatibility with all size-d LPOs takes O(nᵈ) time. Thus, the overall time   complexity for each value of k is O(n  (nᵈ + nk)).\nThe difference between the maximum possible bandwidth (n - 1) and our initial lower   bound grows linearly in n, so we run the underlying O(n  (nᵈ + nk))   recognition algorithm O(n) times.\nFinally, ₖ₀ⁿ¹ (nᵈ + nk) = O(nᵈ¹ + n³), so the overall time complexity   is O(n  nᴰ¹), where D = max(d 2).\n\nOf course, this is but an upper bound on the time complexity of Del Corso–Manzini with perimeter search, achieved only in the most pathological of cases. In practice, efficient pruning techniques and compatibility checks—along with [CS05, pp. 359–60]'s relatively tight initial lower bound on the minimum bandwidth—result in approximately exponential growth in time complexity with respect to n.\n\nBased on experimental results, the algorithm is feasible for nn matrices up to n  100 or so.\n\nExamples\n\nWe verify the optimality of the ordering found by Del Corso–Manzini with perimeter search for a random 99 matrix via a brute-force search over all possible permutations up to reversal. The depth parameter is not explicitly set; instead, some near-optimal value is automatically computed upon the first MatrixBandwidth.Minimization.minimize_bandwidth function call.\n\njulia> using Random, SparseArrays\n\njulia> Random.seed!(548836);\n\njulia> (n, p) = (9, 0.2);\n\njulia> A = sprand(n, n, p);\n\njulia> A = A + A' # Ensure structural symmetry;\n\njulia> res_bf = minimize_bandwidth(A, Minimization.BruteForceSearch())\nResults of Bandwidth Minimization Algorithm\n * Algorithm: Brute-force search\n * Approach: exact\n * Minimum Bandwidth: 3\n * Original Bandwidth: 8\n * Matrix Size: 9×9\n\njulia> res_dcm_ps = minimize_bandwidth(A, Minimization.DelCorsoManziniWithPS())\nResults of Bandwidth Minimization Algorithm\n * Algorithm: Del Corso–Manzini with perimeter search\n * Approach: exact\n * Minimum Bandwidth: 3\n * Original Bandwidth: 8\n * Matrix Size: 9×9\n\nWe now generate (and shuffle) a random 3030 matrix with minimum bandwidth 8 using MatrixBandwidth.random_banded_matrix. Del Corso–Manzini with perimeter search then finds a bandwidth-8 ordering, which is (we claim) optimal up to symmetric permutation. (In some cases, random_banded_matrix(n, k) does generate matrices with minimum bandwidth < k. Nevertheless, this example demonstrates that Del Corso–Manzini at the very least finds a quite good ordering, even though exact optimality—which is guaranteed by the original paper [DM99]—is not explicitly verified.) In this case, we set the depth parameter to 4 beforehand instead of relying on Recognition.dcm_ps_optimal_depth.\n\njulia> using Random\n\njulia> Random.seed!(78779);\n\njulia> (n, k, depth) = (30, 8, 4);\n\njulia> A = MatrixBandwidth.random_banded_matrix(n, k);\n\njulia> perm = randperm(n);\n\njulia> A_shuffled = A[perm, perm];\n\njulia> bandwidth(A)\n8\n\njulia> bandwidth(A_shuffled) # Much larger after shuffling\n25\n\njulia> minimize_bandwidth(A_shuffled, Minimization.DelCorsoManziniWithPS(depth))\nResults of Bandwidth Minimization Algorithm\n * Algorithm: Del Corso–Manzini with perimeter search\n * Approach: exact\n * Minimum Bandwidth: 8\n * Original Bandwidth: 25\n * Matrix Size: 30×30\n\nNotes\n\nFor readers of the original paper, what we call the Del Corso–Manzini minimization algorithm with perimeter search here is designated the \"MB-PS algorithm\" in [DM99. p. 193]. The so-called \"MB-ID algorithm,\" on the other hand, we implement in DelCorsoManzini.\n\nReferences\n\n[CS05]: A. Caprara and J.-J. Salazar-González. Laying Out Sparse Graphs with   Provably Minimum Bandwidth. INFORMS Journal on Computing 17, 356–73 (2005).   https://doi.org/10.1287/ijoc.1040.0083.\n[DM99]: G. M. Del Corso and G. Manzini. Finding Exact Solutions to the Bandwidth   Minimization Problem. Computing 62, 189–203 (1999).   https://doi.org/10.1007/s006070050002.\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Minimization.Exact.ExactSolver","page":"Public API","title":"MatrixBandwidth.Minimization.Exact.ExactSolver","text":"ExactSolver <: AbstractSolver <: AbstractAlgorithm\n\nAbstract type for all exact matrix bandwidth minimization solvers.\n\nExact methods are those which guarantee an optimal ordering producing the true minimum bandwidth of a matrix. Since bandwidth minimization is an NP-complete problem, existing exact algorithms are, at best, exponential in time complexity—much worse than many polynomial-time heuristic approaches (e.g., Gibbs–Poole–Stockmeyer). Such methods, therefore, are not feasible for large matrices, but they remain useful when precise solutions are required for small-to-medium-sized inputs (say, up to 100100).\n\nSupertype Hierarchy\n\nExactSolver <: AbstractSolver <: MatrixBandwidth.AbstractAlgorithm\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Minimization.Exact.SaxeGurariSudborough","page":"Public API","title":"MatrixBandwidth.Minimization.Exact.SaxeGurariSudborough","text":"SaxeGurariSudborough <: ExactSolver <: AbstractSolver <: AbstractAlgorithm\n\nThe Saxe–Gurari–Sudborough minimization algorithm is an exact method for minimizing the bandwidth of a structurally symmetric matrix A. For a fixed k  ℕ, the algorithm invokes a subroutine that determines whether A has bandwidth at most k up to symmetric permutation. This subroutine employs dynamic programming to search over equivalence classes of partial orderings, where two partial orderings of length l are equivalent if they share the same active region. (The active region of a partial ordering is defined as the sequence of the last min(k l) vertices in the ordering taken together with all dangling edges—edges with one endpoint in the ordering and the other endpoint not yet in the ordering.) It extends these partial layouts one vertex at a time in a breadth-first manner, pruning implausible classes that violate bandwidth-k constraints such as degree bounds on active vertices and excessive numbers of dangling edges [GS84]. This search is repeated with incrementing values of k until a bandwidth-k ordering is found, with k initialized to some lower bound on the minimum bandwidth of A up to symmetric permutation.\n\nSpecifically, this implementation of the Saxe–Gurari–Sudborough algorithm uses the min(α(A) γ(A)) lower bound from [CS05, pp. 359–60] as the initial value of k. (Further implementation details can be found in the source code for bandwidth_lower_bound.)\n\nAs noted above, the Saxe–Gurari–Sudborough algorithm requires structurally symmetric input (that is, Ai j must be nonzero if and only if Aj i is nonzero for 1  i j  n).\n\nSupertype Hierarchy\n\nSaxeGurariSudborough <: ExactSolver <: AbstractSolver <: MatrixBandwidth.AbstractAlgorithm\n\nPerformance\n\nGiven an nn input matrix, the Saxe–Gurari–Sudborough algorithm runs in O(nⁿ¹) time:\n\nFor each underlying \"bandwidth ≤ k\" check, we call the Saxe–Gurari–Sudborough recognition algorithm, which runs in O(nᵏ) time [GS84, p. 531]. (This is an improvement upon the original O(nᵏ¹) Saxe algorithm [Sax80, p. 363].)\nThe difference between the maximum possible bandwidth (n - 1) and our initial lower   bound grows linearly in n, so we run the underlying O(nᵏ) recognition algorithm   O(n) times.\nTherefore, the overall time complexity is ₖ₀ⁿ¹ nᵏ = O(nⁿ¹).\n\nWhereas most exact bandwidth minimization algorithms are technically factorial-time (with respect to n) in the worst case but practically always approximate exponential time complexity in real life, the O(nⁿ¹) upper bound on Saxe–Gurari–Sudborough is typically a good representation of actual performance in most cases. Indeed, these other types of algorithms tend to outperform Saxe–Gurari–Sudborough for larger n, given that their aggressive pruning strategies keep their effective search space very small in practice and O(2ⁿ) ⊂ O(nⁿ¹).\n\nExamples\n\nWe verify the optimality of the ordering found by Saxe–Gurari–Sudborough for a random 99 matrix via a brute-force search over all possible permutations up to reversal:\n\njulia> using Random, SparseArrays\n\njulia> Random.seed!(52452);\n\njulia> (n, p) = (9, 0.5);\n\njulia> A = sprand(n, n, p);\n\njulia> A = A + A' # Ensure structural symmetry;\n\njulia> res_bf = minimize_bandwidth(A, Minimization.BruteForceSearch())\nResults of Bandwidth Minimization Algorithm\n * Algorithm: Brute-force search\n * Approach: exact\n * Minimum Bandwidth: 5\n * Original Bandwidth: 8\n * Matrix Size: 9×9\n\njulia> res_sgs = minimize_bandwidth(A, Minimization.SaxeGurariSudborough())\nResults of Bandwidth Minimization Algorithm\n * Algorithm: Saxe–Gurari–Sudborough\n * Approach: exact\n * Minimum Bandwidth: 5\n * Original Bandwidth: 8\n * Matrix Size: 9×9\n\nWe now generate (and shuffle) a random 2525 matrix with minimum bandwidth 5 using MatrixBandwidth.random_banded_matrix. Saxe–Gurari–Sudborough then finds a bandwidth-4 ordering, which is (we claim) optimal up to symmetric permutation. (In some cases, random_banded_matrix(n, k) generates matrices with minimum bandwidth < k—this appears to be one such case. Although we do not explicitly verify exact optimality—which is guaranteed by the original paper [GS84]—here via brute-force search, this example demonstrates that Saxe–Gurari–Sudborough at the very least finds a quite good ordering.)\n\njulia> using Random\n\njulia> Random.seed!(937497);\n\njulia> (n, k, p) = (25, 5, 0.25);\n\njulia> A = MatrixBandwidth.random_banded_matrix(n, k; p=p);\n\njulia> perm = randperm(n);\n\njulia> A_shuffled = A[perm, perm];\n\njulia> bandwidth(A)\n5\n\njulia> bandwidth(A_shuffled) # Much larger after shuffling\n19\n\njulia> minimize_bandwidth(A_shuffled, Minimization.SaxeGurariSudborough())\nResults of Bandwidth Minimization Algorithm\n * Algorithm: Saxe–Gurari–Sudborough\n * Approach: exact\n * Minimum Bandwidth: 4\n * Original Bandwidth: 19\n * Matrix Size: 25×25\n\nNotes\n\nThe Saxe–Gurari–Sudborough algorithm was originally a bandwidth recognition algorithm, not a minimization one—as previously mentioned, we repurpose it here by repeatedly invoking the original procedure for incrementing values of k until a valid ordering is found. The general family of recognition algorithms to which Saxe–Gurari–Sudborough belongs was conceived as a response to a question posed by [GGJK78, p. 494]: is the \"bandwidth ≤ k?\" problem NP-complete for arbitrary k? [Sax80] answered this question in the negative by providing a O(nᵏ¹) algorithm, constructively proving that the problem is class P. Later, [GS84] improved upon this algorithm by reducing time complexity to O(nᵏ). Whereas the original Saxe algorithm considers extensions of partial orderings with any remaining unplaced vertex (of which there are O(n) at any point in the breadth-first search), the Gurari–Sudborough refinement only considers extensions with vertices reachable by paths beginning with a dangling edge that never again traverse a dangling edge [GS84, pp. 535–36].\n\nReferences\n\n[GGJK78]: M. R. Garey, R. L. Graham, D. S. Johnson and D. E. Knuth. Complexity   Results for Bandwidth Minimization. SIAM Journal on Applied Mathematics 34, 477–95   (1978). https://doi.org/10.1137/0134037.\n[GS84]: E. M. Gurari and I. H. Sudborough. Improved dynamic programming algorithms   for bandwidth minimization and the MinCut Linear Arrangement problem. Journal of   Algorithms 5, 531–46 (1984). https://doi.org/10.1016/0196-6774(84)90006-3.\n[Sax80]: J. B. Saxe. Dynamic-Programming Algorithms for Recognizing   Small-Bandwidth Graphs in Polynomial Time. SIAM Journal on Algebraic and Discrete   Methods 1, 363–69 (1980). https://doi.org/10.1137/0601042.\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Minimization.Heuristic","page":"Public API","title":"MatrixBandwidth.Minimization.Heuristic","text":"","category":"section"},{"location":"public_api/#MatrixBandwidth.Minimization.Heuristic","page":"Public API","title":"MatrixBandwidth.Minimization.Heuristic","text":"MatrixBandwidth.Minimization.Heuristic\n\nHeuristic solvers for matrix bandwidth minimization.\n\nHeuristic methods are those which aim to produce near-optimal solutions in a more performant manner than exact methods. While precise bandwidth minimization is NP-complete, many heuristic algorithms (such as Gibbs–Poole–Stockmeyer) run in polynomial time.\n\nHeuristic algorithms differ from metaheuristic ones in that they do not employ higher-level iterative search frameworks (e.g., stochastic techniques) to survey the global search space and escape local minima; instead, they rely on straightforward deterministic procedures to find good solutions in a single pass.\n\nThe following heuristic matrix bandwidth minimization algorithms are currently available:\n\nGibbs–Poole–Stockmeyer (GibbsPooleStockmeyer)\nCuthill–McKee (CuthillMcKee)\nReverse Cuthill–McKee (ReverseCuthillMcKee)\n\nThis submodule is part of the MatrixBandwidth.Minimization submodule of the MatrixBandwidth.jl package.\n\n\n\n\n\n","category":"module"},{"location":"public_api/#MatrixBandwidth.Minimization.Heuristic.CuthillMcKee","page":"Public API","title":"MatrixBandwidth.Minimization.Heuristic.CuthillMcKee","text":"CuthillMcKee <: HeuristicSolver <: AbstractSolver <: AbstractAlgorithm\n\nThe Cuthill–McKee algorithm is a heuristic method for minimizing the bandwidth of a structurally symmetric matrix A. It considers the graph G(A) whose adjacency matrix is A (ignoring weights and self-loops) and performs a breadth-first search of each connected component of G(A), starting from a low-degree node then visiting its neighbors in order of increasing degree. Particularly effective when A is sparse, this heuristic typically produces an ordering which induces a matrix bandwidth either equal to or very close to the true minimum [CM69, pp. 157–58].\n\nAs noted above, the Cuthill–McKee algorithm requires structurally symmetric input (that is, Ai j must be nonzero if and only if Aj i is nonzero for 1  i j  n).\n\nFields\n\nnode_finder::Function: a function that selects a node from some connected component of   the input matrix from which to start the breadth-first search. If no custom heuristic is   specified, this field defaults to bi_criteria_node_finder, which picks a node   \"farthest\" from the others in the component (not necessarily the lowest-degree node).\n\nSupertype Hierarchy\n\nCuthillMcKee <: HeuristicSolver <: AbstractSolver <: MatrixBandwidth.AbstractAlgorithm\n\nPerformance\n\nGiven an nn input matrix A, the Cuthill–McKee algorithm runs in O(n²) time.\n\n[CG80] provide a linear-time implementation in the number of nonzero entries of A, which is still quadratic when A is dense but often much faster when dealing with sparse matrices. However, this would require that A be stored as a graph or a sparse matrix, which runs counter to our desire to provide a bandwidth minimization API for all AbstractMatrix{<:Number} types, including dense matrices. (In the future, however, we may indeed consider supporting this more performant implementation for sparse matrices.)\n\nIt was found in [Geo71, pp. 114–15] that reversing the ordering produced by Cuthill–McKee tends to induce a more optimal matrix profile (a measure of how far, on average, nonzero entries are from the diagonal; see also MatrixBandwidth.profile). This so-called reverse Cuthill–McKee variant is preferred in almost all cases—see ReverseCuthillMcKee and the associated method of _minimize_bandwidth_impl for our implementation.\n\nExamples\n\nIn the following examples, MatrixBandwidth.random_banded_matrix is used to generate random matrices with minimum bandwidth close to k. In some cases, however, the true minimum bandwidth up to symmetric permutation may be even less than k, making it hard to verify whether Cuthill–McKee finds a truly optimal ordering or simply a near-optimal one. Nevertheless, the results are still very good in practice.\n\nCuthill–McKee finds a good ordering for a 3030 matrix:\n\njulia> using Random\n\njulia> Random.seed!(13);\n\njulia> (n, k) = (30, 5);\n\njulia> A = MatrixBandwidth.random_banded_matrix(n, k);\n\njulia> perm = randperm(n);\n\njulia> A_shuffled = A[perm, perm];\n\njulia> bandwidth(A)\n5\n\njulia> bandwidth(A_shuffled) # Much larger after shuffling\n25\n\njulia> minimize_bandwidth(A_shuffled, Minimization.CuthillMcKee())\nResults of Bandwidth Minimization Algorithm\n * Algorithm: Cuthill–McKee\n * Approach: heuristic\n * Minimum Bandwidth: 8\n * Original Bandwidth: 25\n * Matrix Size: 30×30\n\nCuthill–McKee finds a good ordering for a structurally symmetric 183183 matrix with multiple (separate) connected components:\n\njulia> using Random, SparseArrays\n\njulia> Random.seed!(37452);\n\njulia> (max_cc_size, max_band, p, num_ccs) = (60, 9, 0.2, 7);\n\njulia> components = Vector{SparseMatrixCSC{Float64, Int64}}(undef, num_ccs);\n\njulia> for i in 1:num_ccs # Some components may themselves be disconnected\n           cc_size = rand(1:max_cc_size);\n           cc_band = rand(0:min(max_band, cc_size - 1));\n           components[i] = sparse(\n               MatrixBandwidth.random_banded_matrix(cc_size, cc_band; p=p)\n           );\n       end\n\njulia> A = blockdiag(components...); # `A` has least 7 connected components\n\njulia> perm = randperm(sum(map(cc -> size(cc, 1), components)));\n\njulia> A_shuffled = A[perm, perm];\n\njulia> res = minimize_bandwidth(A_shuffled, Minimization.CuthillMcKee());\n\njulia> A # The original matrix\n276×276 SparseMatrixCSC{Float64, Int64} with 464 stored entries:\n⎡⢾⡷⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎤\n⎢⠀⠘⢻⣲⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠘⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠈⠿⡧⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠉⢯⡷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠚⣤⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⢻⣶⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠯⡧⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣤⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠛⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠱⣢⡀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⡢⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢴⣷⡀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠿⣧⡀⠀⎥\n⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⡷⎦\n\njulia> A_shuffled # A far-from-optimal ordering of `A`\n276×276 SparseMatrixCSC{Float64, Int64} with 464 stored entries:\n⎡⠁⢄⠀⢀⠀⠀⠀⢀⠠⠀⠀⠐⠀⠀⠀⠐⢀⡐⠀⠀⠀⢀⠀⠀⠀⠀⠐⠀⢠⠀⠀⠀⡄⠀⠀⠐⠀⠀⠂⠄⎤\n⎢⠀⢀⠱⠂⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⢨⠀⠀⠀⠀⠀⡀⠁⠠⠀⠘⠀⠀⠡⢀⠈⠀⠀⠀⠀⠀⠀⠄⠀⠁⠁⎥\n⎢⠀⠀⠀⠀⠑⢀⠀⠂⠀⠀⠀⠀⢐⠀⠀⠠⠈⠠⠀⠀⠀⠐⠀⠐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⢢⢀⢀⠀⎥\n⎢⠀⢀⡀⠀⠠⠀⠁⠄⠀⠠⠀⠄⠀⠀⠀⠄⠀⠀⠀⠀⢀⠀⠀⢀⠀⠑⠀⠀⠐⠠⠀⠀⠠⠨⠂⠀⠀⠀⠀⠀⎥\n⎢⠀⠂⠀⠀⠀⠀⠀⡀⠱⢆⡀⠂⠀⠀⠀⠀⠀⠀⢀⢊⠀⠐⠐⠈⠀⠈⠀⢀⠄⠀⡀⠀⢁⢀⠠⠀⠃⠀⠊⠀⎥\n⎢⢀⠀⠀⠀⠀⠀⠀⠄⠠⠈⠑⠀⢀⠐⠀⠌⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠀⢀⠉⢀⠀⠠⠈⠀⠀⣁⠁⎥\n⎢⠀⠀⠀⠀⠐⠐⠀⠀⠀⠀⢀⠐⠁⠄⠈⠀⢌⠀⠆⠠⢀⠀⠄⠐⠰⠀⠀⠀⠁⠰⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⢀⠀⠂⠒⠀⡀⠀⠄⠀⠀⡀⠄⠂⠀⠐⢄⠁⢀⠀⠀⠀⡀⠀⠀⠀⠀⡠⠀⠀⠀⠀⠀⠀⠀⠀⢈⠀⠀⠀⠁⎥\n⎢⢀⠰⠀⠀⠂⡀⠀⠀⠀⠀⠀⠈⠂⠑⠁⢀⠐⠄⠄⠂⠂⠜⠄⠀⠀⠀⡄⠀⠀⢀⠀⠠⠀⢀⠄⠀⢀⠀⠂⡂⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⡠⢐⠀⠀⠈⡁⠀⠀⠠⠁⠀⢀⠀⠀⠀⠀⡀⠀⠀⢀⠀⠈⠃⠀⠸⠈⠠⠀⠀⠀⢄⠂⎥\n⎢⠀⢀⠄⠈⢀⠀⠀⠐⢀⠀⠀⠀⠀⠐⠀⠠⣈⠄⠀⠀⠐⢀⠀⡀⠀⠀⠀⠀⠀⠀⠐⠀⠀⠊⠀⠠⠀⠐⠀⠀⎥\n⎢⠀⠀⠀⠂⢀⠀⠀⢀⡐⠀⠀⠀⢀⠁⠀⠀⠀⠁⠀⠀⠀⠠⠄⣥⠉⠈⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⡀⠀⠀⠀⎥\n⎢⠀⠀⠒⠀⠀⠀⢄⠀⡀⠀⠀⠀⠐⠂⠀⠀⠀⠀⠀⠈⠀⠀⡃⠀⠁⢀⠀⠀⢀⡀⢈⠈⠀⠀⠀⠂⠀⠠⠂⠂⎥\n⎢⠐⠀⠄⡀⠀⠀⠀⠀⠀⢀⠀⠈⠀⠀⠀⠊⠀⠉⠀⢀⠀⠀⠀⠀⠀⠀⠑⠀⠀⠀⠀⠀⢀⠀⠈⠀⠛⠃⢄⠀⎥\n⎢⠀⠒⡀⠐⠀⠀⠐⡀⠀⠁⠀⠀⢁⡀⠀⠀⠀⢀⡀⠀⠀⠀⠀⠀⠀⠰⠀⠀⠀⢄⠀⠰⠀⠠⠠⢀⠀⠀⢂⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⡄⠐⠂⠀⠀⠀⠀⡀⠉⠀⠐⠀⠀⠈⡂⠐⠀⠀⢀⡀⠀⣠⠀⠄⠠⠀⠀⡀⠀⠀⎥\n⎢⠀⠉⠀⠀⠀⠀⡀⡂⠁⢐⠀⠐⠀⠀⠀⠀⠀⢀⡒⠂⡠⠀⠀⠀⠀⠀⠀⠐⠀⡀⠀⠄⠑⠄⠀⠀⠀⠀⠀⠀⎥\n⎢⢀⠀⠀⠀⠀⡀⠈⠀⠀⠂⡀⠂⠀⠀⡀⢀⠀⠁⠀⠂⠀⡀⠀⠀⠠⠀⠂⠀⠀⢂⠀⠂⠀⠀⠁⢀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠁⠈⢒⠀⠀⠉⠀⠀⠀⠀⠀⠀⠀⠀⠐⠀⠀⢀⠀⠀⠈⠀⡀⠿⠀⠀⠀⠀⠠⠀⠀⠀⠀⠱⠆⠀⠀⎥\n⎣⠈⠄⠅⠀⠀⠐⠀⠀⠊⠀⠅⠘⠀⠀⠄⠀⠨⠠⠠⠑⠀⠀⠀⠀⠨⠀⠀⠑⠈⠐⠀⠀⠀⠀⠀⠀⠀⠀⠔⢅⎦\n\njulia> A_shuffled[res.ordering, res.ordering] # A near-optimal reordering of `A_shuffled`\n276×276 SparseMatrixCSC{Float64, Int64} with 464 stored entries:\n⎡⠱⣦⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎤\n⎢⠀⠉⠻⣦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠘⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⡦⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⡦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠺⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠚⣤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⣤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⢄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⢀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⢄⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢄⠀⠀⎥\n⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⎦\n\njulia> bandwidth(A)\n7\n\njulia> bandwidth(A_shuffled) # Much larger after shuffling\n266\n\njulia> res # Even better than the original bandwidth (which was, clearly, not yet optimal)\nResults of Bandwidth Minimization Algorithm\n * Algorithm: Cuthill–McKee\n * Approach: heuristic\n * Minimum Bandwidth: 5\n * Original Bandwidth: 266\n * Matrix Size: 276×276\n\nNotes\n\nNote that the node_finder field must be of the form (A::AbstractMatrix{Bool}) -> Integer (i.e., it must take in an boolean matrix and return an integer). If this is not the case, an ArgumentError is thrown upon construction.\n\nReferences\n\n[CG80]: W. M. Chan and A. George. A linear time implementation of the reverse   Cuthill–McKee algorithm. BIT Numerical Mathematics 20, 8–14 (1980).   https://doi.org/10.1007/BF01933580.\n[CM69]: E. Cuthill and J. McKee. Reducing the bandwidth of sparse symmetric   matrices. In: Proceedings of the 24th National Conference of the ACM (Brandon Systems   Press, 1969); pp. 157–72. https://doi.org/10.1145/800195.805928.\n[Geo71]: J. A. George. Computer Implementation of the Finite Element Method.   Ph.D. Thesis, Department of Computer Science, Stanford University (1971).   https://apps.dtic.mil/sti/tr/pdf/AD0726171.pdf.\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Minimization.Heuristic.GibbsPooleStockmeyer","page":"Public API","title":"MatrixBandwidth.Minimization.Heuristic.GibbsPooleStockmeyer","text":"GibbsPooleStockmeyer <: HeuristicSolver <: AbstractSolver <: AbstractAlgorithm\n\nThe Gibbs–Poole–Stockmeyer algorithm is a heuristic method for minimizing the bandwidth of a structurally symmetric matrix A. It considers the graph G(A) whose adjacency matrix is A (ignoring weights and self-loops) and builds an ordering by identifying a pair of \"endpoints\" in the graph far from each other, constructing sets of levels from these endpoints, and merging these level structures in such a way that minimizes the size of the largest level in the final combined structure. Based on the classical reverse Cuthill–McKee algorithm [Geo71], this heuristic typically produces an ordering which induces a matrix bandwidth either equal to or very close to the true minimum, with improvements in bandwidths over reverse Cuthill–McKee more noticeable once input size exceeds 400400 or so [GPS76, pp. 246–47].\n\nWhereas the original paper outlined a strategy for conditionally reversing the orderings of individual \"connected components\" (treating the input matrix A as an undirected graph) [GPS76, p. 241], this implementation instead reverses the entire final ordering in every case, similarly to ReverseCuthillMcKee. Conditional reversals are not only more complex to implement but also slightly more time-consuming, with the only benefit being a marginally smaller matrix profile (a measure of how far, on average, nonzero entries are from the diagonal; see also MatrixBandwidth.profile). Since such reversal strategies do not affect matrix bandwidth (the primary focus of this package), we opt instead for the simpler unconditional reversal.\n\nAs noted above, the Gibbs–Poole–Stockmeyer algorithm requires structurally symmetric input (that is, Ai j must be nonzero if and only if Aj i is nonzero for 1  i j  n).\n\nFields\n\nnode_finder::Function: a function that selects a node from some connected component of   the input matrix from which to start the breadth-first search. If no custom heuristic is   specified, this field defaults to bi_criteria_node_finder, which picks a node   \"farthest\" from the others in the component (not necessarily the lowest-degree node).\n\nSupertype Hierarchy\n\nGibbsPooleStockmeyer <: HeuristicSolver <: AbstractSolver <: MatrixBandwidth.AbstractAlgorithm\n\nPerformance\n\nGiven an nn input matrix, the Gibbs–Poole–Stockmeyer algorithm runs in O(n²) time.\n\n[Lew82] provides a notably faster and more memory-efficient implementation, relying on sparse storage of the input matrix. However, this would run counter to our desire to provide a bandwidth minimization API for all AbstractMatrix{<:Number} types, including dense matrices. (In the future, however, we may indeed consider supporting this more performant implementation for sparse matrices.)\n\nOn that note, Gibbs–Poole–Stockmeyer has been found to take considerably less time than reverse Cuthill–McKee when matrices are stored in sparse format [GPS76, pp. 246–47]. The dense-matrix implementations of both algorithms in this package, however, result in reverse Cuthill–McKee consistently outperforming Gibbs–Poole–Stockmeyer in terms of runtime (although Gibbs–Poole–Stockmeyer still typically produces lower-bandwidth orderings for larger matrices). This further motivates the desire to implement a sparse version of both algorithms in the future.\n\nExamples\n\nIn the following examples, MatrixBandwidth.random_banded_matrix is used to generate random matrices with minimum bandwidth close to k. In some cases, however, the true minimum bandwidth up to symmetric permutation may be even less than k, making it hard to verify whether Gibbs–Poole–Stockmeyer finds a truly optimal ordering or simply a near-optimal one. Nevertheless, the results are still very good in practice.\n\nGibbs–Poole–Stockmeyer finds a good ordering for a 4040 matrix:\n\njulia> using Random\n\njulia> Random.seed!(561);\n\njulia> (n, k) = (40, 7);\n\njulia> A = MatrixBandwidth.random_banded_matrix(n, k);\n\njulia> perm = randperm(n);\n\njulia> A_shuffled = A[perm, perm];\n\njulia> bandwidth(A)\n7\n\njulia> bandwidth(A_shuffled)\n37\n\njulia> minimize_bandwidth(A_shuffled, Minimization.GibbsPooleStockmeyer())\nResults of Bandwidth Minimization Algorithm\n * Algorithm: Gibbs–Poole–Stockmeyer\n * Approach: heuristic\n * Minimum Bandwidth: 7\n * Original Bandwidth: 37\n * Matrix Size: 40×40\n\nGibbs–Poole–Stockmeyer finds a good ordering for a 748748 matrix with multiple (separate) connected components:\n\njulia> using Random, SparseArrays\n\njulia> Random.seed!(271828);\n\njulia> (max_cc_size, max_band, p, num_ccs) = (120, 13, 0.3, 11);\n\njulia> components = Vector{SparseMatrixCSC{Float64, Int64}}(undef, num_ccs);\n\njulia> for i in 1:num_ccs # Some components may themselves be disconnected\n           cc_size = rand(0:max_cc_size);\n           cc_band = rand(1:min(max_band, cc_size - 1));\n           components[i] = sparse(\n               MatrixBandwidth.random_banded_matrix(cc_size, cc_band; p=p)\n           );\n       end\n\njulia> A = blockdiag(components...); # `A` has least 8 connected components\n\njulia> perm = randperm(sum(map(cc -> size(cc, 1), components)));\n\njulia> A_shuffled = A[perm, perm];\n\njulia> res = minimize_bandwidth(A_shuffled, Minimization.GibbsPooleStockmeyer());\n\njulia> A # The original matrix\n748×748 SparseMatrixCSC{Float64, Int64} with 2526 stored entries:\n⎡⢿⣷⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎤\n⎢⠀⠘⠿⣧⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠘⢿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠉⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠑⣤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⎥\n⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⎦\n\njulia> A_shuffled # A far-from-optimal ordering of `A`\n748×748 SparseMatrixCSC{Float64, Int64} with 2526 stored entries:\n⎡⠰⣦⢎⢪⢐⠆⣗⣔⠆⠀⠀⠠⢃⡦⠵⠸⡐⢌⠴⠤⣤⢅⢒⠰⡢⡄⡰⣄⢂⢊⠎⠀⢝⡀⣼⠤⠅⢒⠰⠢⎤\n⎢⡪⣑⡋⢌⠈⢀⣖⣠⢠⡀⡂⠀⠐⠤⣠⠰⣃⠀⢊⢃⡨⡇⡝⠢⣀⠈⢬⢁⠽⡼⠐⡦⠤⠐⠤⠚⠪⢠⠦⢈⎥\n⎢⠰⠔⠂⢀⡑⢌⠐⠀⠐⡒⠤⡅⠂⡱⡕⠈⡑⠹⠱⣨⢓⣑⠀⠂⠀⢬⢂⣅⡤⢑⠢⢁⠀⢒⡑⡬⡆⠚⠀⡀⎥\n⎢⢙⢽⠘⣹⠐⠀⢱⣶⠂⠂⠈⡵⢰⡤⠖⠰⡂⣠⢨⢰⣛⠀⠰⡌⡐⠄⠠⡦⠜⠃⠐⣦⢂⠄⠷⢅⣉⠰⠿⢴⎥\n⎢⠈⠁⠀⠲⢰⠠⠨⠀⣑⣼⠩⡃⠂⢰⢁⠓⢐⣘⣂⢦⠂⡐⠔⢄⡨⣃⠦⢁⢈⠀⡂⠀⡅⠈⠀⢌⠀⡀⠵⠫⎥\n⎢⠀⡀⠈⠈⠄⠧⢆⡤⠧⠢⠕⢅⡍⢔⡴⠀⡀⠆⡨⠈⣄⠲⠌⠳⢁⠐⠠⠴⠀⠄⠔⠺⠁⡉⢂⣭⠠⡠⠀⣉⎥\n⎢⠩⡴⠐⡄⢌⡠⠐⡶⢈⣀⢃⢍⠋⢄⡖⢩⢌⣖⠈⢀⣴⣙⡀⢓⠁⠠⢬⢈⠅⡤⠅⢰⣁⠌⣌⠆⠸⢀⠒⣁⎥\n⎢⣑⡃⢀⡚⡑⠉⢘⡁⢥⠐⠐⠋⡜⣉⠑⢄⠍⣢⣓⢉⠊⢖⠀⢐⡀⠲⡈⢑⠀⠊⠀⠛⠀⢃⠘⠀⢁⣒⢀⢁⎥\n⎢⡐⢌⠉⠘⣕⡈⠈⣨⣐⢰⠠⠌⢢⢵⠣⣡⢕⣱⣂⢭⢎⠜⠀⠉⡂⣃⢐⠅⠒⠔⡂⠨⡂⢳⠍⢤⠰⡠⣩⡏⎥\n⎢⠐⡇⠮⢐⡑⣢⢂⣒⠨⣜⡂⠊⠂⢀⡝⢘⡌⣜⣱⢞⠂⠾⠊⢔⠙⣢⢭⣹⠑⡑⠀⡉⡄⠁⠀⠴⣇⣃⠃⡑⎥\n⎢⠄⢟⠦⠮⢝⢰⠛⠘⢈⠠⢠⡙⣔⢻⢪⢄⣊⠕⣨⡄⢕⣵⢐⠊⠊⣱⡠⣢⠀⠣⠀⣍⠔⠀⢝⢄⣌⡄⡌⠆⎥\n⎢⢘⡐⠳⡉⠠⠀⡐⠦⠐⢅⢦⡁⢤⢈⢀⢀⡄⠀⢊⢄⡰⠐⠑⢄⠴⡅⠁⢆⡠⣄⠤⢐⠈⡀⠺⠂⠀⢀⡴⡀⎥\n⎢⠈⠮⡀⠘⡀⣄⠐⠌⠦⢪⢁⠐⠁⡀⢠⡈⠬⢨⠳⣠⢎⣠⠔⠧⠛⢄⡀⡹⠡⠌⠃⢀⠣⠁⠉⢀⠑⠁⢦⡉⎥\n⎢⠐⢮⠆⢓⠌⢴⠠⡦⠌⢃⢀⡆⡂⢓⢆⢈⠔⠔⣇⣳⠠⣪⠡⢄⣄⡨⠛⢄⠑⢐⠐⡠⠪⠃⢤⢁⡝⠐⡀⢎⎥\n⎢⡨⢐⣓⡧⢄⢋⠶⠁⠂⠐⠀⠄⠁⡥⡠⠀⢘⠄⢕⠠⠤⡀⠀⢮⡁⠆⢑⢀⠕⣥⣑⠼⡀⡅⠝⠢⠠⠄⠀⠔⎥\n⎢⠊⠁⠰⡤⠌⢂⠰⣤⠈⠈⣰⡁⢁⣁⣤⠀⡈⡈⡄⠠⡄⢤⢀⢃⠉⢀⠐⡠⣑⡜⠑⢄⠀⡼⠠⠲⢈⠠⢃⠁⎥\n⎢⠓⠱⢀⠃⢠⢀⠈⠔⡁⠉⡅⠠⡁⠜⠤⢀⢬⣈⠄⠉⠐⠁⠂⠠⠍⠂⠮⠂⠄⠬⣀⡤⠵⢇⠈⠀⠣⠡⠩⡎⎥\n⎢⠒⡟⣠⠃⡑⡬⠝⢇⡀⢄⡌⣴⠢⠝⠒⠀⠃⣅⢀⡄⠓⢕⠺⠂⠃⢀⠄⢓⠳⡁⢠⡂⠂⠀⠛⢄⡀⢒⠒⠂⎥\n⎢⢡⢁⠊⣂⣨⠉⢃⡘⠀⠠⠀⡢⠒⢂⢡⢰⠐⡢⠭⢹⠂⠽⠀⢀⠕⠀⢓⠉⠀⠆⠂⡐⠍⡂⢠⢈⠁⣤⢀⡈⎥\n⎣⠰⡂⡈⢃⠀⠠⢛⣇⡵⡃⡄⢠⠜⢠⠄⢐⡧⠾⢍⠠⠢⠍⠐⠫⡌⠳⡠⢌⢀⠄⠍⠐⡣⠦⠸⠀⡀⠰⡛⢌⎦\n\njulia> A_shuffled[res.ordering, res.ordering] # A near-optimal reordering of `A_shuffled`\n748×748 SparseMatrixCSC{Float64, Int64} with 2526 stored entries:\n⎡⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎤\n⎢⠀⠀⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠑⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠱⢆⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠱⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠑⢄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢻⣶⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣤⣀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢻⣶⡀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣤⡀⠀⎥\n⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⎦\n\njulia> bandwidth(A)\n12\n\njulia> bandwidth(A_shuffled) # Much larger after shuffling\n731\n\njulia> res # Gets very close to the original bandwidth\nResults of Bandwidth Minimization Algorithm\n * Algorithm: Gibbs–Poole–Stockmeyer\n * Approach: heuristic\n * Minimum Bandwidth: 18\n * Original Bandwidth: 731\n * Matrix Size: 748×748\n\nNotes\n\nNote that the node_finder field must be of the form (A::AbstractMatrix{Bool}) -> Integer (i.e., it must take in an boolean matrix and return an integer). If this is not the case, an ArgumentError is thrown upon construction.\n\nReferences\n\n[Geo71]: J. A. George. Computer Implementation of the Finite Element Method.   Ph.D. Thesis, Department of Computer Science, Stanford University (1971).   https://apps.dtic.mil/sti/tr/pdf/AD0726171.pdf.\n[GPS76]: N. E. Gibbs, W. G. Poole Jr. and P. K. Stockmeyer. An Algorithm for   Reducing the Bandwidth and Profile of a Sparse Matrix. SIAM Journal on Numerical   Analysis 13, 236–50 (1976). https://doi.org/10.1137/0713023.\n[Lew82]: J. G. Lewis. Implementation of the Gibbs–Poole–Stockmeyer and Gibbs–King   Algorithms. ACM Transactions on Mathematical Software 8, 180–89 (1982).   https://doi.org/10.1145/355993.355998.\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Minimization.Heuristic.HeuristicSolver","page":"Public API","title":"MatrixBandwidth.Minimization.Heuristic.HeuristicSolver","text":"HeuristicSolver <: AbstractSolver <: AbstractAlgorithm\n\nAbstract type for all heuristic matrix bandwidth minimization solvers.\n\nHeuristic methods are those which aim to produce near-optimal solutions in a more performant manner than exact methods. While precise bandwidth minimization is NP-complete, many heuristic algorithms (such as Gibbs–Poole–Stockmeyer) run in polynomial time.\n\nHeuristic algorithms differ from metaheuristic ones in that they do not employ higher-level iterative search frameworks (e.g., stochastic techniques) to survey the global search space and escape local minima; instead, they rely on straightforward deterministic procedures to find good solutions in a single pass.\n\nSupertype Hierarchy\n\nHeuristicSolver <: AbstractSolver <: MatrixBandwidth.AbstractAlgorithm\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Minimization.Heuristic.ReverseCuthillMcKee","page":"Public API","title":"MatrixBandwidth.Minimization.Heuristic.ReverseCuthillMcKee","text":"ReverseCuthillMcKee <: HeuristicSolver <: AbstractSolver <: AbstractAlgorithm\n\nThe reverse Cuthill–McKee algorithm is a variant of the Cuthill–McKee algorithm—a heuristic method for minimizing the bandwidth of a structurally symmetric matrix A. Cuthill–McKee considers the graph G(A) whose adjacency matrix is A (ignoring weights and self-loops) and performs a breadth-first search of each connected component of G(A), starting from a low-degree node then visiting its neighbors in order of increasing degree. Particularly effective when A is sparse, this heuristic typically produces an ordering which induces a matrix bandwidth either equal to or very close to the true minimum [CM69, pp. 157–58]. The reverse Cuthill–McKee algorithm simply reverses the ordering produced by application of Cuthill–McKee; it was found in [Geo71, pp. 114–15] that although the bandwidth remains the same, this tends to produce a more optimal matrix profile (a measure of how far, on average, nonzero entries are from the diagonal; see also MatrixBandwidth.profile).\n\nAs noted above, the reverse Cuthill–McKee algorithm requires structurally symmetric input (that is, Ai j must be nonzero if and only if Aj i is nonzero for 1  i j  n).\n\nPerformance\n\nGiven an nn input matrix A, the reverse Cuthill–McKee algorithm runs in O(n²) time.\n\n[CG80] provide a linear-time implementation in the number of nonzero entries of A, which is still quadratic when A is dense but often much faster when dealing with sparse matrices. However, this would require that A be stored as a graph or a sparse matrix, which runs counter to our desire to provide a bandwidth minimization API for all AbstractMatrix{<:Number} types, including dense matrices. (In the future, however, we may indeed consider supporting this more performant implementation for sparse matrices.)\n\nFields\n\nnode_finder::Function: a function that selects a node from some connected component of   the input matrix from which to start the breadth-first search. If no custom heuristic is   specified, this field defaults to bi_criteria_node_finder, which picks a node   \"farthest\" from the others in the component (not necessarily the lowest-degree node).\n\nSupertype Hierarchy\n\nReverseCuthillMcKee <: HeuristicSolver <: AbstractSolver <: MatrixBandwidth.AbstractAlgorithm\n\nExamples\n\nIn the following examples, MatrixBandwidth.random_banded_matrix is used to generate random matrices with minimum bandwidth close to k. In some cases, however, the true minimum bandwidth up to symmetric permutation may be even less than k, making it hard to verify whether reverse Cuthill–McKee finds a truly optimal ordering or simply a near-optimal one. Nevertheless, the results are still very good in practice.\n\nReverse Cuthill–McKee finds a good ordering for a 3535 matrix:\n\njulia> using Random\n\njulia> Random.seed!(87);\n\njulia> (n, k) = (35, 3);\n\njulia> A = MatrixBandwidth.random_banded_matrix(n, k);\n\njulia> perm = randperm(n);\n\njulia> A_shuffled = A[perm, perm];\n\njulia> bandwidth(A)\n3\n\njulia> bandwidth(A_shuffled) # Much larger after shuffling\n30\n\njulia> minimize_bandwidth(A_shuffled, Minimization.ReverseCuthillMcKee())\nResults of Bandwidth Minimization Algorithm\n * Algorithm: Reverse Cuthill–McKee\n * Approach: heuristic\n * Minimum Bandwidth: 3\n * Original Bandwidth: 30\n * Matrix Size: 35×35\n\nReverse Cuthill–McKee finds a good ordering for a 235235 matrix with multiple (separate) connected components:\n\njulia> using Random, SparseArrays\n\njulia> Random.seed!(5747);\n\njulia> (max_cc_size, max_band, p, num_ccs) = (60, 9, 0.2, 8);\n\njulia> components = Vector{SparseMatrixCSC{Float64, Int64}}(undef, num_ccs);\n\njulia> for i in 1:num_ccs # Some components may themselves be disconnected\n           cc_size = rand(0:max_cc_size);\n           cc_band = rand(1:min(max_band, cc_size - 1));\n           components[i] = sparse(\n               MatrixBandwidth.random_banded_matrix(cc_size, cc_band; p=p)\n           );\n       end\n\njulia> A = blockdiag(components...); # `A` has least 8 connected components\n\njulia> perm = randperm(sum(map(cc -> size(cc, 1), components)));\n\njulia> A_shuffled = A[perm, perm];\n\njulia> res = minimize_bandwidth(A_shuffled, Minimization.ReverseCuthillMcKee());\n\njulia> A # The original matrix\n235×235 SparseMatrixCSC{Float64, Int64} with 445 stored entries:\n⎡⢾⣳⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎤\n⎢⠀⠘⢿⡷⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠈⠏⣥⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠉⢴⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠙⠻⢂⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣮⣿⣢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠚⢿⡳⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⢰⣶⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠾⡧⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⣢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⡠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⠖⣀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢏⡱⣄⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢮⣷⣄⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢻⣲⣄⠀⎥\n⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢻⢖⎦\n\njulia> A_shuffled # A far-from-optimal ordering of `A`\n235×235 SparseMatrixCSC{Float64, Int64} with 445 stored entries:\n⎡⠑⠄⠀⠀⠀⠀⠀⢀⢀⠀⠄⠀⠀⠀⠀⠀⠀⠀⠀⠄⠀⡐⠀⠐⠀⠂⠀⠀⠀⠀⠀⠀⡂⠀⢀⠄⠁⠠⠐⠀⎤\n⎢⠀⠀⠀⢄⡀⠀⢁⠀⠀⠈⠀⠁⠀⠀⠀⢀⠁⠄⠈⠀⠀⠀⠀⠐⠀⠀⠀⠀⠀⠈⠀⠂⠠⠀⠀⠀⠀⠀⡀⠐⎥\n⎢⠀⠀⠀⠈⠁⢀⠀⠑⠀⢀⠁⢀⠀⠈⠀⠘⠌⠀⢀⠀⠄⠀⠂⡄⠄⠁⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⣂⠀⠀⠀⎥\n⎢⠀⢀⠁⠐⢄⠀⠠⢆⠀⠀⠀⠀⠀⠀⠀⢀⠠⡀⠀⠀⠠⠀⠀⠀⠐⠀⠀⡀⠀⢀⠀⠀⠀⠈⠀⡀⠀⠀⠘⠀⎥\n⎢⠀⠐⡀⠀⠀⢀⠀⠀⢀⢔⠈⢀⠀⠀⣐⠀⠀⠀⢀⠀⠀⠀⠀⠀⠐⠀⠄⢠⠀⠀⠀⠀⠀⠀⠀⡀⠀⠈⠣⡀⎥\n⎢⠀⠁⠄⠀⠁⢀⠀⠀⠂⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⠀⡀⠀⠀⡐⠐⠀⡀⠀⠀⠂⠀⠀⠀⢀⠀⠀⠄⠀⎥\n⎢⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠑⠀⠀⠀⠀⠀⠀⠀⡠⠀⡀⠀⠀⠄⠀⠀⠠⠀⠀⠠⠀⠀⠀⠀⡠⠄⠀⠄⎥\n⎢⠀⠀⠀⢀⣀⠀⠀⢀⠐⠘⠀⠀⠀⠀⠕⢅⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⢀⠐⡀⠀⠈⠀⠂⠀⠀⢀⠀⠃⠀⠄⎥\n⎢⠀⠀⠁⠄⠂⠁⠀⠢⠀⠀⠀⠀⠀⠀⠀⠀⠛⢄⢸⠘⠀⠀⠀⠀⠄⠈⠁⠀⠀⠨⠀⠀⢀⠀⠀⠨⠀⠀⠈⠀⎥\n⎢⠀⠄⠂⠀⠀⠐⠀⠀⠀⠐⠀⠀⠀⠀⠀⠀⣒⠒⠁⠀⢠⠀⠀⠀⠐⠀⠀⠀⢁⠀⠐⠈⠀⠀⠂⠀⠂⡀⠀⠀⎥\n⎢⢀⠠⠀⠀⠀⠁⠀⠂⠀⠀⠀⠂⠀⠊⠀⠀⠀⠀⠀⠒⠑⠀⠀⠀⠀⠂⢀⠁⡂⠀⠀⢀⠀⠀⠀⠀⠁⠂⡊⠂⎥\n⎢⢀⠀⢀⠀⠈⠤⠀⠀⠀⠀⠀⠈⠀⠈⠀⠠⠀⠀⠀⠀⠀⠀⠁⢀⠅⠀⢀⠀⠀⠀⢀⠀⡁⠀⠀⠀⠀⠠⠀⠀⎥\n⎢⠠⠀⠀⠀⠄⠁⠐⠀⠐⠀⢀⠠⠀⠄⠀⠀⡀⠁⠐⠀⠠⠀⠁⠁⠁⠀⢀⠄⠀⠉⠀⠃⠀⠀⠀⠀⠠⢠⠂⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠠⠀⣁⠐⠀⠀⠀⢀⠐⠁⠀⠀⠀⠄⠐⠀⠐⠀⠔⡑⠌⠀⠀⠀⠀⠢⢉⠀⠀⠄⠀⠀⠄⎥\n⎢⠀⠀⡀⠀⠂⠀⠀⢀⠀⠀⠀⠈⠀⠂⠀⠈⡀⡀⠁⠐⠈⠈⠀⠀⡄⠀⠀⠀⠄⠅⠀⡀⠀⠀⠀⠠⠀⠰⠀⠂⎥\n⎢⠀⠀⠠⠀⠀⠀⠀⠀⠀⠀⠠⠀⠀⡀⠂⠀⠀⠀⡐⠀⠀⢀⠀⠐⠤⠀⠀⠀⠀⠠⠀⢀⠀⠀⠀⠀⠀⠀⠒⢀⎥\n⎢⠈⠈⠀⠂⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠐⠀⠀⠀⠀⠁⠈⠀⠀⡌⢂⠀⠀⠀⠀⠀⠄⠈⠀⠀⡀⠀⠀⎥\n⎢⠀⠔⠀⠀⠀⠀⠀⠠⠀⠠⠀⢀⠀⠀⠀⢀⡀⡀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀⠂⠀⠡⠂⠀⠀⡠⠀⎥\n⎢⠁⡀⠀⠀⠈⠘⠀⠀⡀⠀⠀⠀⠀⠎⠤⠀⠀⠀⠈⠠⠡⠀⠀⡀⠀⣂⠀⠁⢀⡀⠀⠀⠀⠠⠀⠀⠰⠆⠌⠀⎥\n⎣⠐⠀⢀⠈⠀⠀⠒⠀⠉⠢⠀⠁⠀⠄⠀⠄⠂⠀⠀⠀⠪⠈⠀⠀⠈⠀⠀⠄⠠⠀⠘⢀⠀⠀⠀⠊⠂⠁⠐⢀⎦\n\njulia> A_shuffled[res.ordering, res.ordering] # A near-optimal reordering of `A_shuffled`\n235×235 SparseMatrixCSC{Float64, Int64} with 445 stored entries:\n⎡⠁⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎤\n⎢⠀⠀⠁⢄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠈⠀⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠁⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠑⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢞⡵⡦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠫⢥⣳⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠡⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠫⡦⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⢻⣶⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢫⣶⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢪⣶⣄⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢾⣳⡀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣦⣄⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠿⣧⡀⠀⎥\n⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠱⣦⎦\n\njulia> bandwidth(A)\n9\n\njulia> bandwidth(A_shuffled) # Much larger after shuffling\n226\n\njulia> res # Gets very close to the original bandwidth\nResults of Bandwidth Minimization Algorithm\n * Algorithm: Reverse Cuthill–McKee\n * Approach: heuristic\n * Minimum Bandwidth: 11\n * Original Bandwidth: 226\n * Matrix Size: 235×235\n\nNotes\n\nNote that the node_finder field must be of the form (A::AbstractMatrix{Bool}) -> Integer (i.e., it must take in an boolean matrix and return an integer). If this is not the case, an ArgumentError is thrown upon construction.\n\nSee also the documentation for CuthillMcKee—the original (non-reversed) algorithm. (Indeed, the reverse Cuthill–McKee method of _minimize_bandwidth_impl is merely a wrapper around the Cuthill–McKee method.)\n\nReferences\n\n[CG80]: W. M. Chan and A. George. A linear time implementation of the reverse   Cuthill–McKee algorithm. BIT Numerical Mathematics 20, 8–14 (1980).   https://doi.org/10.1007/BF01933580.\n[CM69]: E. Cuthill and J. McKee. Reducing the bandwidth of sparse symmetric   matrices. In: Proceedings of the 24th National Conference of the ACM (Brandon Systems   Press, 1969); pp. 157–72. https://doi.org/10.1145/800195.805928.\n[Geo71]: J. A. George. Computer Implementation of the Finite Element Method.   Ph.D. Thesis, Department of Computer Science, Stanford University (1971).   https://apps.dtic.mil/sti/tr/pdf/AD0726171.pdf.\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Minimization.Metaheuristic","page":"Public API","title":"MatrixBandwidth.Minimization.Metaheuristic","text":"","category":"section"},{"location":"public_api/#MatrixBandwidth.Minimization.Metaheuristic","page":"Public API","title":"MatrixBandwidth.Minimization.Metaheuristic","text":"MatrixBandwidth.Minimization.Metaheuristic\n\nMetaheuristic solvers for matrix bandwidth minimization.\n\nMetaheuristic methods are those which employ higher-level iterative search frameworks such as stochastic techniques or nature-inspired processes to survey the global search space and escape local minima. Unlike heuristic methods—which follow fixed deterministic procedures—metaheuristics adaptively refine candidate solutions over multiple iterations. Although metaheuristic approaches are often slower than heuristic ones (but certainly still faster than exact ones), they shine in complex cases where the latter may get trapped in poor-quality local minima.\n\nNo metaheuristic matrix bandwidth minimization algorithms are already implemented, but several (e.g., simulated annealing) are currently under development.\n\nThis submodule is part of the MatrixBandwidth.Minimization submodule of the MatrixBandwidth.jl package.\n\n\n\n\n\n","category":"module"},{"location":"public_api/#MatrixBandwidth.Minimization.Metaheuristic.AntColony","page":"Public API","title":"MatrixBandwidth.Minimization.Metaheuristic.AntColony","text":"AntColony <: MetaheuristicSolver <: AbstractSolver <: AbstractAlgorithm\n\n[TODO: Write here]\n\nSupertype Hierarchy\n\nAntColony <: MetaheuristicSolver <: AbstractSolver <: MatrixBandwidth.AbstractAlgorithm\n\n[TODO: Write here]\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Minimization.Metaheuristic.GRASP","page":"Public API","title":"MatrixBandwidth.Minimization.Metaheuristic.GRASP","text":"GRASP <: MetaheuristicSolver <: AbstractSolver <: AbstractAlgorithm\n\n[TODO: Write here]\n\nSupertype Hierarchy\n\nGRASP <: MetaheuristicSolver <: AbstractSolver <: MatrixBandwidth.AbstractAlgorithm\n\n[TODO: Write here]\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Minimization.Metaheuristic.GeneticAlgorithm","page":"Public API","title":"MatrixBandwidth.Minimization.Metaheuristic.GeneticAlgorithm","text":"GeneticAlgorithm <: MetaheuristicSolver <: AbstractSolver <: AbstractAlgorithm\n\n[TODO: Write here]\n\nSupertype Hierarchy\n\nGeneticAlgorithm <: MetaheuristicSolver <: AbstractSolver <: MatrixBandwidth.AbstractAlgorithm\n\n[TODO: Write here]\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Minimization.Metaheuristic.MetaheuristicSolver","page":"Public API","title":"MatrixBandwidth.Minimization.Metaheuristic.MetaheuristicSolver","text":"MetaheuristicSolver <: AbstractSolver <: AbstractAlgorithm\n\nAbstract type for all metaheuristic matrix bandwidth minimization solvers.\n\nMetaheuristic methods are those which employ higher-level iterative search frameworks such as stochastic techniques or nature-inspired processes to survey the global search space and escape local minima. Unlike heuristic methods—which follow fixed deterministic procedures—metaheuristics adaptively refine candidate solutions over multiple iterations. Although metaheuristic approaches are often slower than heuristic ones (but certainly still faster than exact ones), they shine in complex cases where the latter may get trapped in poor-quality local minima.\n\nSupertype Hierarchy\n\nMetaheuristicSolver <: AbstractSolver <: MatrixBandwidth.AbstractAlgorithm\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Minimization.Metaheuristic.PSOHC","page":"Public API","title":"MatrixBandwidth.Minimization.Metaheuristic.PSOHC","text":"PSOHC <: MetaheuristicSolver <: AbstractSolver <: AbstractAlgorithm\n\n[TODO: Write here]\n\nSupertype Hierarchy\n\nPSOHC <: MetaheuristicSolver <: AbstractSolver <: MatrixBandwidth.AbstractAlgorithm\n\n[TODO: Write here]\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Minimization.Metaheuristic.SimulatedAnnealing","page":"Public API","title":"MatrixBandwidth.Minimization.Metaheuristic.SimulatedAnnealing","text":"SimulatedAnnealing <: MetaheuristicSolver <: AbstractSolver <: AbstractAlgorithm\n\n[TODO: Write here]\n\nSupertype Hierarchy\n\nSimulatedAnnealing <: MetaheuristicSolver <: AbstractSolver <: MatrixBandwidth.AbstractAlgorithm\n\n[TODO: Write here]\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Minimization.Metaheuristic.TabuSearch","page":"Public API","title":"MatrixBandwidth.Minimization.Metaheuristic.TabuSearch","text":"TabuSearch <: MetaheuristicSolver <: AbstractSolver <: AbstractAlgorithm\n\n[TODO: Write here]\n\nSupertype Hierarchy\n\nTabuSearch <: MetaheuristicSolver <: AbstractSolver <: MatrixBandwidth.AbstractAlgorithm\n\n[TODO: Write here]\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Recognition","page":"Public API","title":"MatrixBandwidth.Recognition","text":"","category":"section"},{"location":"public_api/#MatrixBandwidth.Recognition","page":"Public API","title":"MatrixBandwidth.Recognition","text":"MatrixBandwidth.Recognition\n\nAlgorithms for matrix bandwidth recognition in Julia.\n\nThe bandwidth of an nn matrix A is the minimum non-negative integer k  0 1  n - 1 such that Ai j = 0 whenever i - j  k. The matrix bandwidth recognition problem entails determining whether there exists a permutation matrix P such that the bandwidth of PAPᵀ is at most some fixed non-negative integer (an optimal permutation that fully minimizes the bandwidth of A is not required).\n\nThe following matrix bandwidth recognition algorithms are currently available:\n\nDel Corso–Manzini (DelCorsoManzini)\nDel Corso–Manzini with perimeter search (DelCorsoManziniWithPS)\nCaprara–Salazar-González (CapraraSalazarGonzalez)\nSaxe–Gurari–Sudborough (SaxeGurariSudborough)\nBrute-force search (BruteForceSearch)\n\nThis submodule is part of the MatrixBandwidth.jl package.\n\n\n\n\n\n","category":"module"},{"location":"public_api/#MatrixBandwidth.Recognition.AbstractDecider","page":"Public API","title":"MatrixBandwidth.Recognition.AbstractDecider","text":"AbstractDecider <: AbstractAlgorithm\n\nAbstract base type for all matrix bandwidth recognition deciders.\n\nInterface\n\nAs per the interface of supertype AbstractAlgorithm, concrete subtypes of AbstractDecider must implement the following methods:\n\nBase.summary(::T) where {T<:AbstractDecider}: returns a String indicating the name   of the decider (e.g., \"Caprara–Salazar-González\").\n_requires_structural_symmetry(::T) where {T<:AbstractDecider}: returns a Bool   indicating whether the decider requires the input matrix to be structurally symmetric.\n\nSupertype Hierarchy\n\nAbstractDecider <: AbstractAlgorithm\n\nNotes\n\nTo implement a new matrix bandwidth recognition algorithm, define a new concrete subtype of AbstractDecider then implement a corresponding _has_bandwidth_k_ordering_impl(::AbstractMatrix{Bool}, ::Integer, ::NewDeciderType) method. Do not attempt to directly implement a new has_bandwidth_k_ordering method, as the function contains common preprocessing logic independent of the specific algorithm used.\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Recognition.BruteForceSearch","page":"Public API","title":"MatrixBandwidth.Recognition.BruteForceSearch","text":"BruteForceSearch <: AbstractDecider <: AbstractAlgorithm\n\nThe simplest method for determining, given some fixed k  ℕ, whether a matrix has bandwidth at most k up to symmetric permutation is to iterate over all orderings and compute the bandwidth induced by each.\n\nSince i₁ i₂  iₙ induces the same bandwidth as iₙ iₙ₁  i₁, we restrict our search to orderings such that i₁  iₙ (with equality checked just in case n = 1).\n\nIf a bandwidth-k ordering is found, the algorithm breaks early instead of continuing to check subsequent permutations.\n\nSupertype Hierarchy\n\nBruteForceSearch <: AbstractDecider <: AbstractAlgorithm\n\nPerformance\n\nGiven an nn input matrix, this brute-force algorithm runs in O(n  n²) time:\n\nUp to n2 permutations may be checked (except when n = 1, in which case   1 = 1 permutation is checked). This is, clearly, O(n).\nFor each permutation, the bandwidth function is called on view(A, perm, perm),   which takes O(n²) time.\nTherefore, the overall time complexity is O(n  n²).\n\nExamples\n\nIn many cases, the algorithm iterates over all (if k is smaller than the true minimu bandwidth) or almost all (if k is equally to or only slightly larger than the true minimum) possible permutations—in these cases, it is infeasible to go above 99 or 1010 without incurring multiple-hour runtimes. (Even when k is considerably larger than the true minimum, it is unlikely that a bandwidth-k ordering will be found in a reasonable time frame.) Nevertheless, we see that it is quite effective for, say, 88:\n\njulia> using Random, SparseArrays\n\njulia> Random.seed!(314159);\n\njulia> (n, p) = (8, 0.5);\n\njulia> A = sprand(n, n, p);\n\njulia> A = A + A' # Ensure structural symmetry;\n\njulia> (k_false, k_true) = (3, 5);\n\njulia> has_bandwidth_k_ordering(A, k_false, Recognition.BruteForceSearch())\nResults of Bandwidth Recognition Algorithm\n * Algorithm: Brute-force search\n * Bandwidth Threshold k: 3\n * Has Bandwidth ≤ k Ordering: false\n * Original Bandwidth: 6\n * Matrix Size: 8×8\n\njulia> has_bandwidth_k_ordering(A, k_true, Recognition.BruteForceSearch())\nResults of Bandwidth Recognition Algorithm\n * Algorithm: Brute-force search\n * Bandwidth Threshold k: 5\n * Has Bandwidth ≤ k Ordering: true\n * Original Bandwidth: 6\n * Matrix Size: 8×8\n\nNotes\n\nBrute force is by far the slowest approach to matrix bandwidth minimization and should only be used in very niche cases (like verifying the correctness of other algorithms in unit tests). For 1010 matrices, the algorithm already takes several minutes to run for difficult values of k (namely, values below or only slightly above the true minimum) and allocates several gigabytes of memory. Given the O(n  n²) time complexity, checking \"bandwidth ≤ k\" would take over an hour for many 1111 matrices.\n\nThis holds true even when k is considerably larger than the true minimum bandwidth—as long as it remains below the bandwidth induced by the original ordering, it is unlikely that a bandwidth-k ordering will be found early simply by random chance. Additionally, time complexity will remain on the order of n  n² in the average case.\n\nSee also MatrixBandwidth.Minimization.Exact.BruteForceSearch for the minimization variant of this algorithm (which simply never breaks early, instead iterating over all permutations up to reversal to ensure that the minimum bandwidth is found).\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Recognition.CapraraSalazarGonzalez","page":"Public API","title":"MatrixBandwidth.Recognition.CapraraSalazarGonzalez","text":"CapraraSalazarGonzalez <: AbstractDecider <: AbstractAlgorithm\n\nThe Caprara–Salazar-González recognition algorithm is a method for determining, given some fixed k  ℕ, whether a structurally symmetric matrix A has a bandwidth at most k up to symmetric permutation. The algorithm performs a depth-first search of all partial orderings of the rows and columns of A, adding indices one at a time. Partial orderings are pruned not only by ensuring that adjacent pairs of currently placed indices are within k of each other but also by employing a branch-and-bound framework with lower bounds on bandwidth compatibility computed via integer linear programming relaxations. This search is repeated with incrementing values of k until a bandwidth-k ordering is found [CS05], with k initialized to some lower bound on the minimum bandwidth of A up to symmetric permutation.\n\nAs noted above, the Caprara–Salazar-González algorithm requires structurally symmetric input (that is, Ai j must be nonzero if and only if Aj i is nonzero for 1  i j  n).\n\nSupertype Hierarchy\n\nCapraraSalazarGonzalez <: AbstractDecider <: AbstractAlgorithm\n\nPerformance\n\nGiven an nn input matrix and threshold bandwidth k, the Caprara–Salazar-González algorithm runs in O(n  Tᵢₗₚ(n n²)) time, where Tᵢₗₚ(n m) is the time taken to solve an integer linear programming (ILP) problem with O(n) variables and O(m) constraints:\n\nWe perform a depth-first search of O(n) partial orderings.\nAt each search node, we solve ILP relaxations with n variables and O(n²)   constraints (given by the number of nonzero entries in the computed distance matrix),   taking Tᵢₗₚ(n n²) time. (This dominates the O(n²) auxiliary computations needed   to set up the ILP.)\nTherefore, the overall time complexity is O(n  Tᵢₗₚ(n n²)).\n\nNote that Tᵢₗₚ(n n²) has worst-case complexity O(2ⁿ), although this ultimately depends on the ILP solver used. (Here, we use the HiGHS solver from the HiGHS.jl package.)\n\nOf course, this is all but an upper bound on the time complexity of Caprara–Salazar-González, achieved only in the most pathological of cases. In practice, efficient pruning techniques and compatibility checks result in approximately exponential growth in time complexity with respect to n.\n\nExamples\n\njulia> using Random, SparseArrays\n\njulia> Random.seed!(17);\n\njulia> (n, p) = (10, 0.17);\n\njulia> A = sprand(n, n, p);\n\njulia> A = A + A' # Ensure structural symmetry;\n\njulia> (k_false, k_true) = (3, 6);\n\njulia> has_bandwidth_k_ordering(A, k_false, Recognition.CapraraSalazarGonzalez())\nResults of Bandwidth Recognition Algorithm\n * Algorithm: Caprara–Salazar-González\n * Bandwidth Threshold k: 3\n * Has Bandwidth ≤ k Ordering: false\n * Original Bandwidth: 9\n * Matrix Size: 10×10\n\njulia> has_bandwidth_k_ordering(A, k_true, Recognition.CapraraSalazarGonzalez())\nResults of Bandwidth Recognition Algorithm\n * Algorithm: Caprara–Salazar-González\n * Bandwidth Threshold k: 6\n * Has Bandwidth ≤ k Ordering: true\n * Original Bandwidth: 9\n * Matrix Size: 10×10\n\nNotes\n\nFor readers of the original paper, what we call the Caprara–Salazar-González algorithm here is designated the LAYOUT_LEFT_TO_RIGHT algorithm in [CS05]. The paper also describes a LAYOUT_BOTH_WAYS algorithm that performs a bidirectional search by adding indices to both the left and right ends of the current partial ordering. However, this version is considerably more complex to implement, and we ran into problems enforcing ILP constraints on node pairs added to opposite ends of the ordering. In any case, computational results demonstrate that neither LAYOUT_LEFT_TO_RIGHT nor LAYOUT_BOTH_WAYS is consistently faster, and the paper states that there is no known heuristic for determining which version will be more performant for a given input [CS05, pp. 368–69]. Therefore, we opt to implement only LAYOUT_LEFT_TO_RIGHT as a matter of practicality, although future developers may wish to extend the interface with LAYOUT_BOTH_WAYS as well.\n\nDo also note that this algorithm is not the main LAYOUT_LEFT_TO_RIGHT procedure described in the original paper, which actually never explicitly tackles matrix bandwidth recognition [CS05]. However, the LAYOUT_LEFT_TO_RIGHT algorithm presented therein for bandwidth minimization does repeatedly call a recognition subroutine—this is precisely the logic we implement here. (We do, however, also implement said minimization algorithm in MatrixBandwidth.Minimization.Exact.CapraraSalazarGonzalez.)\n\nA final implementation detail worth noting is that we use HiGHS as our solver; it is one of the fastest open-source solvers available for mixed-integer linear programming.\n\nReferences\n\n[CS05]: A. Caprara and J.-J. Salazar-González. Laying Out Sparse Graphs with   Provably Minimum Bandwidth. INFORMS Journal on Computing 17, 356–73 (2005).   https://doi.org/10.1287/ijoc.1040.0083.\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Recognition.DelCorsoManzini","page":"Public API","title":"MatrixBandwidth.Recognition.DelCorsoManzini","text":"DelCorsoManzini <: AbstractDecider <: AbstractAlgorithm\n\nThe Del Corso–Manzini recognition algorithm is a method for determining, given some fixed k  ℕ, whether a structurally symmetric matrix A has bandwidth at most k up to symmetric permutation. The algorithm performs a depth-first search of all partial orderings of the rows and columns of A, adding indices one at a time. Partial orderings are pruned not only by ensuring that adjacent pairs of currently placed indices are within k of each other but also by tracking the latest positions at which the remaining indices can be placed [DM99].\n\nAs noted above, the Del Corso–Manzini algorithm requires structurally symmetric input (that is, Ai j must be nonzero if and only if Aj i is nonzero for 1  i j  n).\n\nSupertype Hierarchy\n\nDelCorsoManzini <: AbstractDecider <: AbstractAlgorithm\n\nPerformance\n\nGiven an nn input matrix and threshold bandwidth k, the Del Corso–Manzini algorithm runs in O(n  nk) time:\n\nWe perform a depth-first search of O(n) partial orderings.\nChecking plausibility of each partial ordering takes O(nk) time.\nTherefore, the overall time complexity is O(n  nk).\n\nOf course, this is but an upper bound on the time complexity of Del Corso–Manzini, achieved only in the most pathological of cases. In practice, efficient pruning techniques and compatibility checks result in approximately exponential growth in time complexity with respect to n.\n\nBased on experimental results, the algorithm is feasible for nn matrices up to n  100 or so.\n\nExamples\n\njulia> using Random, SparseArrays\n\njulia> Random.seed!(7878);\n\njulia> (n, p) = (40, 0.1);\n\njulia> A = sprand(n, n, p);\n\njulia> A = A + A' # Ensure structural symmetry;\n\njulia> (k_false, k_true) = (13, 26);\n\njulia> has_bandwidth_k_ordering(A, k_false, Recognition.DelCorsoManzini())\nResults of Bandwidth Recognition Algorithm\n * Algorithm: Del Corso–Manzini\n * Bandwidth Threshold k: 13\n * Has Bandwidth ≤ k Ordering: false\n * Original Bandwidth: 34\n * Matrix Size: 40×40\n\njulia> has_bandwidth_k_ordering(A, k_true, Recognition.DelCorsoManzini())\nResults of Bandwidth Recognition Algorithm\n * Algorithm: Del Corso–Manzini\n * Bandwidth Threshold k: 26\n * Has Bandwidth ≤ k Ordering: true\n * Original Bandwidth: 34\n * Matrix Size: 40×40\n\nNotes\n\nFor readers of the original paper, what we call the Del Corso–Manzini recognition algorithm here is essentially a wrapper around the underlying AddNode subroutine in what [DM99, p. 191] term the \"MB-ID algorithm\" for bandwidth minimization (not mere recognition). MB-ID (which we also implement in MatrixBandwidth.Minimization.Exact.DelCorsoManzini) calls this recognition procedure with incrementing values of k until a bandwidth-k ordering is found, with k initialized to some lower bound on the minimum bandwidth of A up to symmetric permutation.\n\n[DM99, p. 193] also describe an \"MB-PS algorithm\" for bandwidth minimization, which we implement in MatrixBandwidth.Minimization.Exact.DelCorsoManziniWithPS. Similarly, the underlying recognition subroutine for MB-PS is implemented in DelCorsoManziniWithPS.\n\nReferences\n\n[DM99]: G. M. Del Corso and G. Manzini. Finding Exact Solutions to the Bandwidth   Minimization Problem. Computing 62, 189–203 (1999).   https://doi.org/10.1007/s006070050002.\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Recognition.DelCorsoManziniWithPS","page":"Public API","title":"MatrixBandwidth.Recognition.DelCorsoManziniWithPS","text":"DelCorsoManziniWithPS{D} <: AbstractDecider <: AbstractAlgorithm\n\nThe Del Corso–Manzini recognition algorithm with perimeter search is a method for determining, given some fixed k  ℕ, whether a structurally symmetric matrix A has bandwidth at most k up to symmetric permutation. The base Del Corso–Manzini algorithm performs a depth-first search of all partial orderings of the rows and columns of A, adding indices one at a time. Partial orderings are pruned not only by ensuring that adjacent pairs of currently placed indices are within k of each other but also by tracking the latest positions at which the remaining indices can be placed [DM99].\n\nThe incorporation of perimeter search to this approach entails precomputing a \"perimeter\" of d-permutations of row indices of A, where d is a positive integer passed as a parameter to the decider. Each permutation represents a way to select the last d entries of the ordering, and as the construction of the partial ordering progresses, potential endings are pruned to exclude those incompatible with already placed indices. In addition to pruning a potential ending if it contains indices already placed, compatibility is also checked via precomputed time stamps indicating, for each potential ending, a loose lower bound on the earliest position at which any given index can be placed should said ending be selected.\n\nAs noted above, the Del Corso–Manzini algorithm with perimeter search requires structurally symmetric input (that is, Ai j must be nonzero if and only if Aj i is nonzero for 1  i j  n).\n\nFields\n\ndepth::D<:Union{Nothing,Integer}: the perimeter search depth. If this field is not set   (and thus automatically initialized to nothing), a default depth is computed by   dcm_ps_optimal_depth as a function of the input matrix every time the decider   is passed to has_bandwidth_k_ordering as a function of the input matrix.   Otherwise, it must be manually set to a positive integer.\n\nConstructors\n\nDelCorsoManziniWithPS(): constructs a new DelCorsoManziniWithPS instance with the   default perimeter search depth initialized to nothing.\nDelCorsoManziniWithPS(depth::Integer): constructs a new DelCorsoManziniWithPS instance   with the specified perimeter search depth. depth must be a positive integer.\n\nSupertype Hierarchy\n\nDelCorsoManziniWithPS <: AbstractDecider <: AbstractAlgorithm\n\nPerformance\n\nGiven an nn input matrix, perimeter search depth d, and threshold bandwidth k, the Del Corso–Manzini algorithm with perimeter search runs in O(n  max(nᵈ nk)) time:\n\nWe perform a depth-first search of O(n) partial orderings.\nChecking plausibility of each partial ordering takes O(nk) time, and checking   compatibility with all size-d LPOs takes O(nᵈ) time. Thus, the overall time   complexity for each value of k is O(n  (nᵈ + nk)).\nTherefore, the overall time complexity is O(n  max(nᵈ nk)).\n\nOf course, this is but an upper bound on the time complexity of Del Corso–Manzini with perimeter search, achieved only in the most pathological of cases. In practice, efficient pruning techniques and compatibility checks result in approximately exponential growth in time complexity with respect to n.\n\nBased on experimental results, the algorithm is feasible for nn matrices up to n  100 or so.\n\nExamples\n\nHere, Del Corso–Manzini with perimeter search ascertains that A random 3030 matrix has a minimum bandwidth greater than 9. The depth parameter is not explicitly set; instead, some near-optimal value is automatically computed upon the first has_bandwidth_k_ordering function call.\n\njulia> using Random, SparseArrays\n\njulia> Random.seed!(5847);\n\njulia> (n, p) = (30, 0.05);\n\njulia> A = sprand(n, n, p);\n\njulia> A = A + A' # Ensure structural symmetry;\n\njulia> k = 6;\n\njulia> has_bandwidth_k_ordering(A, k, Recognition.DelCorsoManziniWithPS())\nResults of Bandwidth Recognition Algorithm\n * Algorithm: Del Corso–Manzini with perimeter search\n * Bandwidth Threshold k: 6\n * Has Bandwidth ≤ k Ordering: false\n * Original Bandwidth: 27\n * Matrix Size: 30×30\n\nNow, Del Corso–Manzini with perimeter search recognizes that a random 3535 matrix has a minimum bandwidth at most 8. In this case, we explicitly set the depth parameter to 4 beforehand instead of relying on Recognition.dcm_ps_optimal_depth.\n\njulia> using Random, SparseArrays\n\njulia> Random.seed!(23552);\n\njulia> (n, p, depth) = (35, 0.02, 4);\n\njulia> A = sprand(n, n, p);\n\njulia> A = A + A' # Ensure structural symmetry;\n\njulia> k = 8;\n\njulia> has_bandwidth_k_ordering(A, k, Recognition.DelCorsoManziniWithPS(depth))\nResults of Bandwidth Recognition Algorithm\n * Algorithm: Del Corso–Manzini with perimeter search\n * Bandwidth Threshold k: 8\n * Has Bandwidth ≤ k Ordering: true\n * Original Bandwidth: 32\n * Matrix Size: 35×35\n\nNotes\n\nFor readers of the original paper, what we call the Del Corso–Manzini recognition algorithm with perimeter search here is essentially a wrapper around the underlying AddNode1 and Prune subroutines in what [DM99, p. 193] term the \"MB-PS algorithm\" for bandwidth minimization (not mere recognition). MB-PS (which we also implement in MatrixBandwidth.Minimization.Exact.DelCorsoManziniWithPS) calls this recognition procedure with incrementing values of k until a bandwidth-k ordering is found, with k initialized to some lower bound on the minimum bandwidth of A up to symmetric permutation.\n\n[DM99, p. 191] also describe an \"MB-ID algorithm\" for bandwidth minimization, which we implement in MatrixBandwidth.Minimization.Exact.DelCorsoManzini. Similarly, the underlying recognition subroutine for MB-ID is implemented in DelCorsoManzini.\n\nReferences\n\n[DM99]: G. M. Del Corso and G. Manzini. Finding Exact Solutions to the Bandwidth   Minimization Problem. Computing 62, 189–203 (1999).   https://doi.org/10.1007/s006070050002.\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Recognition.RecognitionResult","page":"Public API","title":"MatrixBandwidth.Recognition.RecognitionResult","text":"RecognitionResult{A,M,O} <: AbstractResult\n\nOutput struct for matrix bandwidth recognition results.\n\nFields\n\nalgorithm::A<:AbstractDecider: the decider used to test the bandwidth.\nmatrix::M<:AbstractMatrix{<:Number}: the original matrix whose bandwidth is tested.\nordering::O<:Union{Nothing,Vector{Int}}: an ordering of the rows and columns of matrix   inducing a bandwidth at most k, if such an ordering exists; otherwise, nothing.\nk::Integer: the threshold bandwidth against which to test.\nhas_ordering::Bool: whether the matrix has an ordering inducing a bandwidth at most k.   (This is true if and only if ordering is not nothing.)\n\nConstructors\n\nRecognitionResult(decider, matrix, ordering, k): constructs a new RecognitionResult   instance with the given fields. The has_ordering field is automatically determined   based on whether ordering is nothing or a Vector{Int}.\n\nSupertype Hierarchy\n\nRecognitionResult <: AbstractResult\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Recognition.SaxeGurariSudborough","page":"Public API","title":"MatrixBandwidth.Recognition.SaxeGurariSudborough","text":"SaxeGurariSudborough <: AbstractDecider <: AbstractAlgorithm\n\nThe Saxe–Gurari–Sudborough recognition algorithm is a method for determining, given some fixed k  ℕ, whether a structurally symmetric matrix A has bandwidth at most k up to symmetric permutation. The algorithm employs dynamic programming to search over equivalence classes of partial orderings, where two partial orderings of length l are equivalent if they share the same active region. (The active region of a partial ordering is defined as the sequence of the last min(k l) vertices in the ordering taken together with all dangling edges—edges with one endpoint in the ordering and the other endpoint not yet in the ordering.) It extends these partial layouts one vertex at a time in a breadth-first manner, pruning implausible classes that violate bandwidth-k constraints such as degree bounds on active vertices and excessive numbers of dangling edges [GS84].\n\nAs noted above, the Saxe–Gurari–Sudborough algorithm requires structurally symmetric input (that is, Ai j must be nonzero if and only if Aj i is nonzero for 1  i j  n).\n\nSupertype Hierarchy\n\nSaxeGurariSudborough <: AbstractDecider <: AbstractAlgorithm\n\nPerformance\n\nGiven an nn input matrix and threshold bandwidth k, the Saxe–Gurari–Sudborough algorithm runs in O(nᵏ) time [GS84, p. 531]. This is an improvement upon the original O(nᵏ¹) Saxe algorithm [Sax80, p. 363]. (Of course, when k  3, then the initial O(n³) bandwidth lower bound computation performed in all has_bandwidth_k_ordering calls dominates the overall complexity, although the constant scaling factor of that subroutine is generally much smaller than that of the algorithm proper).\n\nWhereas most bandwidth recognition algorithms are technically factorial-time (with respect to n) in the worst case but practically always approximate exponential time complexity in real life (see: DelCorsoManzini), the O(nᵏ) upper bound on Saxe–Gurari–Sudborough is typically a good representation of actual performance in most cases. Indeed, these other types of algorithms tend to outperform Saxe–Gurari–Sudborough for larger k, given that their aggressive pruning strategies keep their effective search space very small in practice.\n\nExamples\n\njulia> using Random, SparseArrays\n\njulia> Random.seed!(274);\n\njulia> (n, p) = (20, 0.08);\n\njulia> A = sprand(n, n, p);\n\njulia> A = A + A' # Ensure structural symmetry;\n\njulia> (k_false, k_true) = (3, 5);\n\njulia> has_bandwidth_k_ordering(A, k_false, Recognition.SaxeGurariSudborough())\nResults of Bandwidth Recognition Algorithm\n * Algorithm: Saxe–Gurari–Sudborough\n * Bandwidth Threshold k: 3\n * Has Bandwidth ≤ k Ordering: false\n * Original Bandwidth: 12\n * Matrix Size: 20×20\n\njulia> has_bandwidth_k_ordering(A, k_true, Recognition.SaxeGurariSudborough())\nResults of Bandwidth Recognition Algorithm\n * Algorithm: Saxe–Gurari–Sudborough\n * Bandwidth Threshold k: 5\n * Has Bandwidth ≤ k Ordering: true\n * Original Bandwidth: 12\n * Matrix Size: 20×20\n\nNotes\n\nThis general family of bandwidth recognition algorithms was conceived as a response to a question posed by [GGJK78, p. 494]: is the \"bandwidth ≤ k?\" problem NP-complete for arbitrary k? [Sax80] answered this question in the negative by providing a O(nᵏ¹) algorithm, constructively proving that the problem is class P. Later, [GS84] improved upon this algorithm by reducing time complexity to O(nᵏ). Whereas the original Saxe algorithm considers extensions of partial orderings with any remaining unplaced vertex (of which there are O(n) at any point in the breadth-first search), the Gurari–Sudborough refinement only considers extensions with vertices reachable by paths beginning with a dangling edge that never again traverse a dangling edge [GS84, pp. 535–36].\n\nReferences\n\n[GGJK78]: M. R. Garey, R. L. Graham, D. S. Johnson and D. E. Knuth. Complexity   Results for Bandwidth Minimization. SIAM Journal on Applied Mathematics 34, 477–95   (1978). https://doi.org/10.1137/0134037.\n[GS84]: E. M. Gurari and I. H. Sudborough. Improved dynamic programming algorithms   for bandwidth minimization and the MinCut Linear Arrangement problem. Journal of   Algorithms 5, 531–46 (1984). https://doi.org/10.1016/0196-6774(84)90006-3.\n[Sax80]: J. B. Saxe. Dynamic-Programming Algorithms for Recognizing   Small-Bandwidth Graphs in Polynomial Time. SIAM Journal on Algebraic and Discrete   Methods 1, 363–69 (1980). https://doi.org/10.1137/0601042.\n\n\n\n\n\n","category":"type"},{"location":"public_api/#MatrixBandwidth.Recognition.has_bandwidth_k_ordering","page":"Public API","title":"MatrixBandwidth.Recognition.has_bandwidth_k_ordering","text":"has_bandwidth_k_ordering(A, k, decider=CapraraSalazarGonzalez()) -> RecognitionResult\n\nDetermine whether A has bandwidth at most k using the algorithm defined by decider.\n\nThe bandwidth of an nn matrix A is the minimum non-negative integer k  0 1  n - 1 such that Ai j = 0 whenever i - j  k.\n\nGiven some fixed non-negative integer k, this function determines (with 100% certainty) whether there exists some ordering π of the rows and columns of A such that the bandwidth of PAPᵀ is at most k, where P is the permutation matrix corresponding to π. This is known to be decidable in O(nᵏ) time, although some deciders (e.g., CapraraSalazarGonzalez) run in exponential time instead to produce even quicker runtimes in practice.\n\nIf k  n - 1, then this function immediately answers in the affirmative, since the maximum possible bandwidth of an nn matrix is n - 1. After this initial check, a preliminary lower bound on the bandwidth is computed in O(n³) time using results from Caprara and Salazar-González (2005). If this lower bound is greater than k`\n\nArguments\n\nA::AbstractMatrix{<:Number}: the (square) matrix whose bandwidth is tested.\nk::Integer: the threshold bandwidth against which to test.\ndecider::AbstractDecider: the matrix bandwidth recognition algorithm to use; defaults to   CapraraSalazarGonzalez. (See the Recognition module documentation   for a full list of supported deciders.)\n\nReturns\n\n::RecognitionResult: a struct containing the algorithm used, the original matrix A,   the identified ordering of the rows and columns (if one exists), the threshold bandwidth   k, and a boolean indicating whether the ordering exists.\n\nExamples\n\nMultiple algorithms to decide whether a given matrix has bandwidth at most k are available. Naturally, they will always agree, but the final orderings produced (in the case of an affirmative) may differ:\n\njulia> using Random, SparseArrays\n\njulia> Random.seed!(52);\n\njulia> (n, p) = (8, 0.2);\n\njulia> A = sprand(Bool, n, n, p);\n\njulia> A = A .|| A' # Ensure structural symmetry\n8×8 SparseMatrixCSC{Bool, Int64} with 22 stored entries:\n 1  ⋅  ⋅  1  ⋅  1  1  ⋅\n ⋅  ⋅  ⋅  ⋅  1  1  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1\n 1  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅\n ⋅  1  ⋅  ⋅  ⋅  ⋅  1  1\n 1  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n 1  ⋅  ⋅  1  1  ⋅  ⋅  1\n ⋅  ⋅  1  ⋅  1  ⋅  1  1\n\njulia> k = 3;\n\njulia> res_csg = has_bandwidth_k_ordering(A, k, Recognition.CapraraSalazarGonzalez())\nResults of Bandwidth Recognition Algorithm\n * Algorithm: Caprara–Salazar-González\n * Bandwidth Threshold k: 3\n * Has Bandwidth ≤ k Ordering: true\n * Original Bandwidth: 6\n * Matrix Size: 8×8\n\njulia> A[res_csg.ordering, res_csg.ordering]\n8×8 SparseMatrixCSC{Bool, Int64} with 22 stored entries:\n ⋅  ⋅  1  1  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  1  ⋅  1  ⋅  ⋅  ⋅\n 1  1  1  1  ⋅  ⋅  ⋅  ⋅\n 1  ⋅  1  ⋅  ⋅  1  1  ⋅\n ⋅  1  ⋅  ⋅  ⋅  1  ⋅  ⋅\n ⋅  ⋅  ⋅  1  1  ⋅  1  ⋅\n ⋅  ⋅  ⋅  1  ⋅  1  1  1\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅\n\njulia> res_sgs = has_bandwidth_k_ordering(A, k, Recognition.SaxeGurariSudborough())\nResults of Bandwidth Recognition Algorithm\n * Algorithm: Saxe–Gurari–Sudborough\n * Bandwidth Threshold k: 3\n * Has Bandwidth ≤ k Ordering: true\n * Original Bandwidth: 6\n * Matrix Size: 8×8\n\njulia> A[res_sgs.ordering, res_sgs.ordering]\n8×8 SparseMatrixCSC{Bool, Int64} with 22 stored entries:\n ⋅  1  ⋅  1  ⋅  ⋅  ⋅  ⋅\n 1  ⋅  1  ⋅  1  ⋅  ⋅  ⋅\n ⋅  1  1  ⋅  1  1  ⋅  ⋅\n 1  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅\n ⋅  1  1  ⋅  ⋅  ⋅  1  1\n ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  1  1  ⋅  1  1\n ⋅  ⋅  ⋅  ⋅  1  ⋅  1  ⋅\n\nIf no decider is specified, then the Del Corso–Manzini algorithm is used by default:\n\njulia> using Random, SparseArrays\n\njulia> Random.seed!(174);\n\njulia> (n, p, k) = (20, 0.1, 4);\n\njulia> A = sprand(n, n, p);\n\njulia> A = A .+ A' # Ensure structural symmetry;\n\njulia> has_bandwidth_k_ordering(A, k)\nResults of Bandwidth Recognition Algorithm\n * Algorithm: Del Corso–Manzini\n * Bandwidth Threshold k: 4\n * Has Bandwidth ≤ k Ordering: false\n * Original Bandwidth: 15\n * Matrix Size: 20×20\n\nNotes\n\nTo implement a new matrix bandwidth recognition algorithm, define a new concrete subtype of AbstractDecider then implement a corresponding _has_bandwidth_k_ordering_impl(::AbstractMatrix{Bool}, ::Integer, ::NewDeciderType) method. Do not attempt to directly implement a new has_bandwidth_k_ordering method, as the function contains common preprocessing logic independent of the specific algorithm used.\n\nNote also that some texts define matrix bandwidth to be the minimum non-negative integer k such that Ai j = 0 whenever i - j  k instead, particularly in more mathematically-minded communities. Effectively, this definition treats diagonal matrices as bandwidth 1, tridiagonal matrices as bandwidth 2, and so on. Our definition, on the other hand, is more common in computer science contexts, treating diagonal matrices as bandwidth 0 and tridiagonal matrices as bandwidth 1. (Both definitions, however, agree that the bandwidth of an empty matrix is simply 0.)\n\n\n\n\n\n","category":"function"},{"location":"public_api/#References","page":"Public API","title":"References","text":"","category":"section"},{"location":"public_api/","page":"Public API","title":"Public API","text":"A. Caprara and J.-J. Salazar-González. Laying Out Sparse Graphs with Provably Minimum Bandwidth. INFORMS Journal on Computing 17, 356–73 (2005).\n\n\n\nW. M. Chan and A. George. A linear time implementation of the reverse Cuthill–McKee algorithm. BIT Numerical Mathematics 20, 8–14 (1980).\n\n\n\nE. Cuthill and J. McKee. Reducing the bandwidth of sparse symmetric matrices. In: Proceedings of the 24th National Conference of the ACM (Brandon Systems Press, 1969); pp. 157–72.\n\n\n\nG. M. Del Corso and G. Manzini. Finding Exact Solutions to the Bandwidth Minimization Problem. Computing 62, 189–203 (1999).\n\n\n\nM. R. Garey, R. L. Graham, D. S. Johnson and D. E. Knuth. Complexity Results for Bandwidth Minimization. SIAM Journal on Applied Mathematics 34, 477–95 (1978).\n\n\n\nJ. A. George. Computer Implementation of the Finite Element Method. Ph.D. Thesis, Department of Computer Science, Stanford University (1971).\n\n\n\nN. E. Gibbs, W. G. Poole Jr. and P. K. Stockmeyer. An Algorithm for Reducing the Bandwidth and Profile of a Sparse Matrix. SIAM Journal on Numerical Analysis 13, 236–50 (1976).\n\n\n\nE. M. Gurari and I. H. Sudborough. Improved dynamic programming algorithms for bandwidth minimization and the   MinCut Linear Arrangement problem. Journal of Algorithms 5, 531–46 (1984).\n\n\n\nJ. G. Lewis. Implementation of the Gibbs–Poole–Stockmeyer and Gibbs–King Algorithms. ACM Transactions on Mathematical Software 8, 180–89 (1982).\n\n\n\nL. O. Mafteiu-Scai. The Bandwidths of a Matrix. A Survey of Algorithms. Annals of West University of Timisoara - Mathematics and Computer Science 52, 183–223 (2014).\n\n\n\nJ. B. Saxe. Dynamic-Programming Algorithms for Recognizing Small-Bandwidth Graphs in   Polynomial Time. SIAM Journal on Algebraic and Discrete Methods 1, 363–69 (1980).\n\n\n\n","category":"page"},{"location":"private_api/#Private-API-Documentation","page":"Private API","title":"Private API Documentation","text":"","category":"section"},{"location":"private_api/","page":"Private API","title":"Private API","text":"Documentation for MatrixBandwidth's private API.","category":"page"},{"location":"private_api/","page":"Private API","title":"Private API","text":"note: Note\nThe following documentation covers only the private API of the package. For public details, see the public API documentation.","category":"page"},{"location":"private_api/#MatrixBandwidth","page":"Private API","title":"MatrixBandwidth","text":"","category":"section"},{"location":"private_api/#MatrixBandwidth.ALGORITHMS","page":"Private API","title":"MatrixBandwidth.ALGORITHMS","text":"const ALGORITHMS :: Dict{Symbol, Union{Dict{Symbol}, Vector}}\n\nA dictionary indexing the data types of all available algorithms by submodule.\n\nFor instance, to access all metaheuristic minimization algorithms, use MatrixBandwidth.ALGORITHMS[:Minimization][:Metaheuristic]. Similarly, to access all recognition algorithms, use MatrixBandwidth.ALGORITHMS[:Recognition].\n\n\n\n\n\n","category":"constant"},{"location":"private_api/#MatrixBandwidth.NotImplementedError","page":"Private API","title":"MatrixBandwidth.NotImplementedError","text":"NotImplementedError{Nothing}(f, subtype, abstracttype)\nNotImplementedError{Symbol}(f, arg, subtype, abstracttype)\n\nAn exception indicating that a function lacks dispatch to handle a specific argument type.\n\nSemantically, this differs from MethodError in that it connotes a developer-side failure to implement a method rather than erroneous user input. Throughout this package, it is often used to warn when an existing function with multiple dispatch on some abstract type is called on a newly created subtype for which no method has been defined.\n\nFields\n\nf::Function: the function called.\narg::Symbol: the name of the argument with the unsupported type, if the function has   multiple arguments. If the function has only one argument, this field should be set to   nothing.\nsubtype::Type: the type of the argument. May be the actual concrete type or some   intermediate supertype. (For instance, if the relevant input has concrete type A with   hierarchy A <: B <: C and the abstracttype field is C, then both A and B are   perfectly valid choices for subtype.)\nabstracttype::Type: the abstract type under which the argument is meant to fall.\n\nConstructors\n\nNotImplementedError(::Function, ::Type, ::Type): constructs a new NotImplementedError   instance for a single-argument function. Throws an error if the second type is not   abstract or the first type is not a subtype of the second.\nNotImplementedError(::Function, ::Symbol, ::Type, ::Type): constructs a new   NotImplementedError instance for a multi-argument function. Throws an error if the   second type is not abstract or the first type is not a subtype of the second.\n\nSupertype Hierarchy\n\nNotImplementedError <: Exception\n\n\n\n\n\n","category":"type"},{"location":"private_api/#MatrixBandwidth.RectangularMatrixError","page":"Private API","title":"MatrixBandwidth.RectangularMatrixError","text":"RectangularMatrixError(A)\n\nAn exception indicating that the matrix A is not square.\n\nMatrix bandwidth is only defined for square matrices, so this exception is raised when a bandwidth minimization or recognition algorithm is called with a non-square input.\n\nFields\n\nA::AbstractMatrix{<:Number}: the input matrix.\nm::Int: the number of rows of A.\nn::Int: the number of columns of A.\n\nConstructors\n\nRectangularMatrixError(A::AbstractMatrix{<:Number}): constructs a new   RectangularMatrixError instance, automatically inferring m and n by calling   size(A).\n\nSupertype Hierarchy\n\nRectangularMatrixError <: Exception\n\n\n\n\n\n","category":"type"},{"location":"private_api/#MatrixBandwidth.StructuralAsymmetryError","page":"Private API","title":"MatrixBandwidth.StructuralAsymmetryError","text":"StructuralAsymmetryError(A, algorithm)\n\nAn exception indicating that the matrix A is not structurally symmetric.\n\nAn n×n matrix A is structurally symmetric if Ai j is nonzero if and only if Aj i is nonzero for 1  i j  n. Many (albeit not all) matrix bandwidth minimization and recognition algorithms assume structural symmetry, so this exception is raised when one of these algorithms is called with a structurally asymmetric input.\n\nFields\n\nA::AbstractMatrix{<:Number}: the input matrix.\nalgorithm::AbstractAlgorithm: the algorithm that was called.\nproblem::Symbol: the matrix bandwidth problem tackled by the algorithm (e.g.,   :minimization).\n\nConstructors\n\nStructuralAsymmetryError(A::AbstractMatrix{<:Number}, algorithm::AbstractAlgorithm):   constructs a new StructuralAsymmetryError instance, automatically inferring problem   by calling _problem(algorithm).\n\nSupertype Hierarchy\n\nStructuralAsymmetryError <: Exception\n\nNotes\n\nAs noted in the error message for StructuralAsymmetryError instances, users may want to consider symmetrization techniques from [RS06] to minimize the bandwidth of structurally asymmetric matrices. (A prominent one is to simply replace Ai j with 1 whenever Ai j = 0 but Aj i  0.) Of course, the reliability of minimization algorithms is diminished after such a transformation, so users should proceed with caution nonetheless.\n\nReferences\n\n[RS06]: J. K. Reid and J. A. Scott. Reducing the Total Bandwidth of a Sparse   Unsymmetric Matrix. SIAM Journal on Matrix Analysis and Applications 28, 805–21   (2006). https://doi.org/10.1137/050629938.\n\n\n\n\n\n","category":"type"},{"location":"private_api/#Base.popfirst!","page":"Private API","title":"Base.popfirst!","text":"popfirst!(q::Queue)\n\nRemoves an element from the front of the queue q and returns it.\n\n\n\n\n\n","category":"function"},{"location":"private_api/#Base.push!","page":"Private API","title":"Base.push!","text":"push!(q::Queue, x)\n\nInserts the value x to the end of the queue q.\n\n\n\n\n\n","category":"function"},{"location":"private_api/#MatrixBandwidth.connected_components-Tuple{AbstractMatrix{Bool}}","page":"Private API","title":"MatrixBandwidth.connected_components","text":"connected_components(A) -> Vector{Vector{Int}}\n\nFind the indices of all connected components of the graph whose adjacency matrix is A.\n\nA is assumed to be symmetric, representing an undirected graph.\n\nArguments\n\nA::AbstractMatrix{Bool}: the adjacency matrix of the graph. Must be symmetric.\n\nReturns\n\n::Vector{Vector{Int}}: a vector of vectors, where each element is a vector of node   indices belonging to a connected component.\n\nExamples\n\njulia> using Graphs\n\njulia> g = complement(complete_multipartite_graph([3, 4, 2]))\n{9, 10} undirected simple Int64 graph\n\njulia> A = Bool.(adjacency_matrix(g))\n9×9 SparseArrays.SparseMatrixCSC{Bool, Int64} with 20 stored entries:\n ⋅  1  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n 1  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n 1  1  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  1  1  1  ⋅  ⋅\n ⋅  ⋅  ⋅  1  ⋅  1  1  ⋅  ⋅\n ⋅  ⋅  ⋅  1  1  ⋅  1  ⋅  ⋅\n ⋅  ⋅  ⋅  1  1  1  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅\n\njulia> MatrixBandwidth.connected_components(A)\n3-element Vector{Vector{Int64}}:\n [1, 2, 3]\n [4, 5, 6, 7]\n [8, 9]\n\n\n\n\n\n","category":"method"},{"location":"private_api/#MatrixBandwidth.find_direct_subtype-Tuple{Type, Type}","page":"Private API","title":"MatrixBandwidth.find_direct_subtype","text":"find_direct_subtype(abstracttype, subtype) -> Type\n\nIdentify the highest supertype of subtype that is also a subtype of abstracttype.\n\nArguments\n\nabstracttype::Type: an abstract type.\nsubtype::Type: a subtype of abstracttype.\n\nReturns\n\n::Type: the direct subtype of abstracttype that is a supertype of subtype.\n\nExamples\n\njulia> abstract type Parent end\n\njulia> abstract type Child1 <: Parent end\n\njulia> abstract type Grandchild1 <: Child1 end\n\njulia> struct Grandchild2 <: Child1 end\n\njulia> abstract type Child2 <: Parent end\n\njulia> struct Child3 <: Parent end\n\njulia> MatrixBandwidth.find_direct_subtype(Parent, Child1)\nChild1\n\njulia> MatrixBandwidth.find_direct_subtype(Parent, Grandchild1)\nChild1\n\njulia> MatrixBandwidth.find_direct_subtype(Parent, Grandchild2)\nChild1\n\njulia> MatrixBandwidth.find_direct_subtype(Parent, Child2)\nChild2\n\njulia> MatrixBandwidth.find_direct_subtype(Parent, Child3)\nChild3\n\n\n\n\n\n","category":"method"},{"location":"private_api/#MatrixBandwidth.floyd_warshall_shortest_paths-Tuple{AbstractMatrix{Bool}}","page":"Private API","title":"MatrixBandwidth.floyd_warshall_shortest_paths","text":"floyd_warshall_shortest_paths(A) -> Matrix{Float64}\n\nCompute a distance matrix from the adjacency matrix A using the Floyd–Warshall algorithm.\n\nRelatively isolated pairs of nodes (those unreachable from each other) are assigned distances of Inf.\n\nA is assumed to be symmetric with an all-false diagonal, representing a simple graph.\n\nArguments\n\nA::AbstractMatrix{Bool}: the adjacency matrix of the graph. Must be symmetric with an   all-false diagonal.\n\nReturns\n\n::Matrix{Float64}: an n×n matrix D, where D[i, j] is the length of the shortest   path between nodes i and j, or Inf if no such path exists.\n\nPerformance\n\nGiven an nn input matrix, the Floyd–Warshall algorithm runs in O(n³) time, given that each level in the triple-nested loop iterates over O(n) entries.\n\nExamples\n\nFloyd–Warshall finds the shortest distances between all pairs of nodes in a connected graph:\n\njulia> using Graphs\n\njulia> g = ladder_graph(5)\n{10, 13} undirected simple Int64 graph\n\njulia> A = Bool.(adjacency_matrix(g))\n10×10 SparseArrays.SparseMatrixCSC{Bool, Int64} with 26 stored entries:\n ⋅  1  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅\n 1  ⋅  1  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅\n ⋅  1  ⋅  1  ⋅  ⋅  ⋅  1  ⋅  ⋅\n ⋅  ⋅  1  ⋅  1  ⋅  ⋅  ⋅  1  ⋅\n ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅  ⋅  ⋅  1\n 1  ⋅  ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅\n ⋅  1  ⋅  ⋅  ⋅  1  ⋅  1  ⋅  ⋅\n ⋅  ⋅  1  ⋅  ⋅  ⋅  1  ⋅  1  ⋅\n ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅  1  ⋅  1\n ⋅  ⋅  ⋅  ⋅  1  ⋅  ⋅  ⋅  1  ⋅\n\njulia> Int.(MatrixBandwidth.floyd_warshall_shortest_paths(A))\n10×10 Matrix{Int64}:\n 0  1  2  3  4  1  2  3  4  5\n 1  0  1  2  3  2  1  2  3  4\n 2  1  0  1  2  3  2  1  2  3\n 3  2  1  0  1  4  3  2  1  2\n 4  3  2  1  0  5  4  3  2  1\n 1  2  3  4  5  0  1  2  3  4\n 2  1  2  3  4  1  0  1  2  3\n 3  2  1  2  3  2  1  0  1  2\n 4  3  2  1  2  3  2  1  0  1\n 5  4  3  2  1  4  3  2  1  0\n\nFloyd–Warshall assigns Inf to pairs of nodes in different connected components:\n\njulia> using Graphs\n\njulia> g = complement(wheel_graph(8))\n{8, 14} undirected simple Int64 graph\n\njulia> A = Bool.(adjacency_matrix(g))\n8×8 SparseArrays.SparseMatrixCSC{Bool, Int64} with 28 stored entries:\n ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  1  1  1  1  ⋅\n ⋅  ⋅  ⋅  ⋅  1  1  1  1\n ⋅  1  ⋅  ⋅  ⋅  1  1  1\n ⋅  1  1  ⋅  ⋅  ⋅  1  1\n ⋅  1  1  1  ⋅  ⋅  ⋅  1\n ⋅  1  1  1  1  ⋅  ⋅  ⋅\n ⋅  ⋅  1  1  1  1  ⋅  ⋅\n\njulia> MatrixBandwidth.floyd_warshall_shortest_paths(A)\n8×8 Matrix{Float64}:\n  0.0  Inf   Inf   Inf   Inf   Inf   Inf   Inf\n Inf    0.0   2.0   1.0   1.0   1.0   1.0   2.0\n Inf    2.0   0.0   2.0   1.0   1.0   1.0   1.0\n Inf    1.0   2.0   0.0   2.0   1.0   1.0   1.0\n Inf    1.0   1.0   2.0   0.0   2.0   1.0   1.0\n Inf    1.0   1.0   1.0   2.0   0.0   2.0   1.0\n Inf    1.0   1.0   1.0   1.0   2.0   0.0   2.0\n Inf    2.0   1.0   1.0   1.0   1.0   2.0   0.0\n\n\n\n\n\n","category":"method"},{"location":"private_api/#MatrixBandwidth.is_structurally_symmetric-Tuple{AbstractMatrix{<:Number}}","page":"Private API","title":"MatrixBandwidth.is_structurally_symmetric","text":"is_structurally_symmetric(A) -> Bool\n\nCheck whether A[i, j] is nonzero if and only if A[j, i] is nonzero for all i and j.\n\nArguments\n\nA::AbstractMatrix{<:Number}: the matrix to check for structural symmetry.\n\nReturns\n\n::Bool: whether A is structurally symmetric.\n\nExamples\n\njulia> A = [4 0 9 -2; 0 0 1 0; 3 -1 5 0; 4 0 0 3]\n4×4 Matrix{Int64}:\n 4   0  9  -2\n 0   0  1   0\n 3  -1  5   0\n 4   0  0   3\n\njulia> MatrixBandwidth.is_structurally_symmetric(A)\ntrue\n\njulia> B = [1.12 2.36 0.00; 5.99 0.0 0.0; 0.0 3.1 -7.49]\n3×3 Matrix{Float64}:\n 1.12  2.36   0.0\n 5.99  0.0    0.0\n 0.0   3.1   -7.49\n\njulia> MatrixBandwidth.is_structurally_symmetric(B)\nfalse\n\nNotes\n\nInstead of transposing A and allocating a new matrix, it suffices to iterate over all opposing pairs of off-diagonal entries.\n\n\n\n\n\n","category":"method"},{"location":"private_api/#MatrixBandwidth.offdiag_nz_support-Tuple{AbstractMatrix{<:Number}}","page":"Private API","title":"MatrixBandwidth.offdiag_nz_support","text":"offdiag_nz_support(A) -> AbstractMatrix{Bool}\n\nConvert A to a boolean matrix and set all its diagonal entries to false.\n\nArguments\n\nA::AbstractMatrix{<:Number}: the matrix to convert.\n\nReturns\n\n::AbstractMatrix{Bool}: the nonzero support of A, with all diagonal entries set to   false.\n\nExamples\n\njulia> A = [0 2 0 7; 0 -8 0 3; -1 9 0 0; 0 0 0 5]\n4×4 Matrix{Int64}:\n  0   2  0  7\n  0  -8  0  3\n -1   9  0  0\n  0   0  0  5\n\njulia> MatrixBandwidth.offdiag_nz_support(A)\n4×4 BitMatrix:\n 0  1  0  1\n 0  0  0  1\n 1  1  0  0\n 0  0  0  0\n\nNotes\n\nIn the context of matrix bandwidth reduction algorithms (which are only concerned with the nonzero support of the input matrix), this improves performance via cache optimizations, availability of bitwise operations, etc.\n\n\n\n\n\n","category":"method"},{"location":"private_api/#MatrixBandwidth.random_banded_matrix-Tuple{Integer, Integer}","page":"Private API","title":"MatrixBandwidth.random_banded_matrix","text":"random_banded_matrix(n, k; p=0.5, rng=default_rng()) -> Matrix{Float64}\n\nGenerate a random n×n structurally symmetric k-banded matrix with band density ≈ p.\n\nBy definition of structural symmetry, the (i j)-th entry of the matrix is nonzero if and only if the (j i)-th entry is nonzero as well. All entries from this matrix are from the interval [0, 1]. Entries up to the kᵗʰ superdiagonal and down to the kᵗʰ subdiagonal are nonzero with probability p.\n\nIt is also guaranteed that each of these bands (besides the main diagonal) has at least one nonzero entry (even when p is very small), thus ensuring that the matrix has bandwidth precisely k before any reordering. (There may, however, still exist a symmetric permutation inducing a minimum bandwidth less than k, especially for small values of p.)\n\nArguments\n\nn::Integer: the order of the matrix to generate. Must be positive.\nk::Integer: the desired matrix bandwidth. Must satisfy 0 ≤ k < n.\n\nKeyword Arguments\n\np::Real=0.5: the band density. Must satisfy 0 < p ≤ 1. Defaults to 0.5.\nrng::AbstractRNG=Random.default_rng(): the random number generator to use. Defaults to   Random.default_rng().\n\nReturns\n\n::Matrix{Float64}: a random n×n matrix with bandwidth exactly k and sparse bands   with density p.\n\nExamples\n\nGenerate a 66 matrix with bandwidth 1 and the maximum number of nonzero entries:\n\njulia> using Random\n\njulia> A = MatrixBandwidth.random_banded_matrix(6, 1; p=1, rng=MersenneTwister(1228))\n6×6 Matrix{Float64}:\n 0.310239  0.346413  0.0       0.0        0.0       0.0\n 0.509981  0.917073  0.390771  0.0        0.0       0.0\n 0.0       0.760045  0.808396  0.0195686  0.0       0.0\n 0.0       0.0       0.222338  0.853164   0.806888  0.0\n 0.0       0.0       0.0       0.421603   0.132165  0.805813\n 0.0       0.0       0.0       0.0        0.305339  0.0799183\n\njulia> bandwidth(A)\n1\n\nGenerate a 77 matrix with bandwidth 3 and band density 03:\n\njulia> using Random\n\njulia> A = MatrixBandwidth.random_banded_matrix(7, 3; p=0.3, rng=MersenneTwister(0402))\n7×7 Matrix{Float64}:\n 0.0       0.132699  0.0       0.0       0.0  0.0       0.0\n 0.869352  0.0       0.324319  0.926496  0.0  0.0       0.0\n 0.0       0.891878  0.0       0.658102  0.0  0.0       0.0\n 0.0       0.88859   0.399559  0.0       0.0  0.284285  0.703377\n 0.0       0.0       0.0       0.0       0.0  0.0       0.0\n 0.0       0.0       0.0       0.489594  0.0  0.0       0.393573\n 0.0       0.0       0.0       0.412412  0.0  0.47063   0.0\n\njulia> bandwidth(A)\n3\n\nGenerate an 88 diagonal (bandwidth 0) matrix with default band density (05):\n\njulia> using Random\n\njulia> A = MatrixBandwidth.random_banded_matrix(8, 0; rng=MersenneTwister(0102))\n8×8 Matrix{Float64}:\n 0.0  0.0        0.0       0.0       0.0  0.0      0.0  0.0\n 0.0  0.0762399  0.0       0.0       0.0  0.0      0.0  0.0\n 0.0  0.0        0.373113  0.0       0.0  0.0      0.0  0.0\n 0.0  0.0        0.0       0.726309  0.0  0.0      0.0  0.0\n 0.0  0.0        0.0       0.0       0.0  0.0      0.0  0.0\n 0.0  0.0        0.0       0.0       0.0  0.41974  0.0  0.0\n 0.0  0.0        0.0       0.0       0.0  0.0      0.0  0.0\n 0.0  0.0        0.0       0.0       0.0  0.0      0.0  0.293132\n\njulia> bandwidth(A)\n0\n\nNotes\n\nUsers of the MatrixBandwidth package may find this function useful when generating random test data for whatever frameworks, algorithms, etc. they are implementing.\n\n\n\n\n\n","category":"method"},{"location":"private_api/#MatrixBandwidth.Minimization","page":"Private API","title":"MatrixBandwidth.Minimization","text":"","category":"section"},{"location":"private_api/#MatrixBandwidth.Minimization.Exact","page":"Private API","title":"MatrixBandwidth.Minimization.Exact","text":"","category":"section"},{"location":"private_api/#MatrixBandwidth.Minimization.Heuristic","page":"Private API","title":"MatrixBandwidth.Minimization.Heuristic","text":"","category":"section"},{"location":"private_api/#MatrixBandwidth.Minimization.Heuristic.bi_criteria_node_finder-Tuple{AbstractMatrix{Bool}}","page":"Private API","title":"MatrixBandwidth.Minimization.Heuristic.bi_criteria_node_finder","text":"bi_criteria_node_finder(A) -> Int\n\nSelect a pseudo-peripheral node from the graph of A based on both eccentricity and width.\n\nThis function acts as a node finder for heuristic matrix bandwidth minimization algorithms such as reverse Cuthill–McKee and Gibbs–Poole–Stockmeyer when applies to connected graphs (or their adjacency matrices). It heuristically identifies the node \"farthest\" from the others in the graph (i.e., a pseudo-peripheral node) as a good starting point for the search process. The heuristic is based on both eccentricity (the maximum distance from a candidate node to any other node in the graph) and width (the maximum number of nodes in any level of the breadth-first search level structure rooted at a candidate node).\n\nIt is assumed that A is the adjacency matrix of some undirected connected graph; otherwise, undefined behavior may arise.\n\nArguments\n\nA::AbstractMatrix{Bool}: a symmetric boolean matrix with an all-false diagonal,   representing the adjacency matrix of some undirected connected graph.\n\nReturns\n\nInt: the index of the pseudo-peripheral node selected from the graph.\n\nNotes\n\nThis algorithm was initially presented in [HLZ24], which in turn is a refinement of the original, more widely known procedure described in [GL79]. Whereas the [GL79] version used only eccentricity as a heuristic, the [HLZ24] version uses width as a tiebreaker when multiple nodes have the same eccentricity, which tends to yield better results.\n\nReferences\n\n[GL79]: A. George and J. W. Liu. An Implementation of a Pseudoperipheral Node   Finder. ACM Transactions on Mathematical Software 5, 284–95 (1979).   https://doi.org/10.1145/355841.355845.\n[HLZ24]: J. Hou, H. Liu and S. Zhu. RCM++:Reverse Cuthill-McKee ordering with   Bi-Criteria Node Finder (2024), arXiv:2409.04171 [cs.DS].   https://arxiv.org/abs/2409.04171\n\n\n\n\n\n","category":"method"},{"location":"private_api/#MatrixBandwidth.Minimization.Heuristic.pseudo_peripheral_node_finder-Tuple{AbstractMatrix{Bool}}","page":"Private API","title":"MatrixBandwidth.Minimization.Heuristic.pseudo_peripheral_node_finder","text":"pseudo_peripheral_node_finder(A) -> Int\n\nSelect a pseudo-peripheral node from the graph of A based on eccentricity.\n\nThis function acts as a node finder for heuristic matrix bandwidth minimization algorithms such as reverse Cuthill–McKee and Gibbs–Poole–Stockmeyer when applies to connected graphs (or their adjacency matrices). It heuristically identifies the node \"farthest\" from the others in the graph (i.e., a pseudo-peripheral node) as a good starting point for the search process. The heuristic is based solely on eccentricity (the maximum distance from a candidate node to any other node in the graph).\n\nIt is assumed that A is the adjacency matrix of some undirected connected graph; otherwise, undefined behavior may arise.\n\nArguments\n\nA::AbstractMatrix{Bool}: a symmetric boolean matrix with an all-false diagonal,   representing the adjacency matrix of some undirected connected graph.\n\nReturns\n\nInt: the index of the pseudo-peripheral node selected from the graph.\n\nNotes\n\nThis function takes heavy inspiration from the implementation in [Net25], which in turn is based on the algorithm described in [GL79]. Whereas the [Net25] implementation accepts a graph object as input and leverages several pre-existing functions in the networkx library, we repurpose the logic to work directly on adjacency matrices, avoiding reallocation overhead and an unnecessary dependency on the Graphs.jl package.\n\nReferences\n\n[GL79]: A. George and J. W. Liu. An Implementation of a Pseudoperipheral Node   Finder. ACM Transactions on Mathematical Software 5, 284–95 (1979).   https://doi.org/10.1145/355841.355845.\n[Net25]: NetworkX Developers. Source code for networkx.utils.rcm. NetworkX v3.5   documentation (2025). Accessed: 2025-06-11.   https://networkx.org/documentation/stable/_modules/networkx/utils/rcm.html.\n\n\n\n\n\n","category":"method"},{"location":"private_api/#MatrixBandwidth.Minimization.Metaheuristic","page":"Private API","title":"MatrixBandwidth.Minimization.Metaheuristic","text":"","category":"section"},{"location":"private_api/#MatrixBandwidth.Recognition","page":"Private API","title":"MatrixBandwidth.Recognition","text":"","category":"section"},{"location":"private_api/#MatrixBandwidth.Recognition.dcm_ps_optimal_depth-Tuple{AbstractMatrix{Bool}}","page":"Private API","title":"MatrixBandwidth.Recognition.dcm_ps_optimal_depth","text":"dcm_ps_optimal_depth(A) -> Int\n\nCompute a (hopefully) near-optimal Del Corso–Manzini perimeter search depth for A.\n\nTaking experimental results from [DM99, pp. 197–99] into account, this function tries to approximate the optimal depth parameter as a function of both matrix size and density. This depth parameter determines how large of a \"perimeter\" of last-placed indices is precomputed in the Del Corso–Manzini algorithm with perimeter search.\n\nArguments\n\nA::AbstractMatrix{Bool}: the (structurally symmetric and square) input matrix whose   bandwidth is investigated.\n\nReturns\n\n::Int: a (hopefully) near-optimal perimeter search depth for the Del Corso–Manzini   algorithm with perimeter search on A.\n\nNotes\n\nSee Tables 4, 5, and 6 from the original paper for more details on experimental results regarding the optimal perimeter search depth [DM99, pp. 197–99].\n\nSee also DelCorsoManziniWithPS and MatrixBandwidth.Minimization.Exact.DelCorsoManziniWithPS) for our implementation of the relevant bandwidth recognition and bandwidth minimization algorithms, respectively.\n\nReferences\n\n[DM99]: G. M. Del Corso and G. Manzini. Finding Exact Solutions to the Bandwidth   Minimization Problem. Computing 62, 189–203 (1999).   https://doi.org/10.1007/s006070050002.\n\n\n\n\n\n","category":"method"},{"location":"private_api/#References","page":"Private API","title":"References","text":"","category":"section"},{"location":"private_api/","page":"Private API","title":"Private API","text":"A. George and J. W. Liu. An Implementation of a Pseudoperipheral Node Finder. ACM Transactions on Mathematical Software 5, 284–95 (1979).\n\n\n\nJ. Hou, H. Liu and S. Zhu. RCM++:Reverse Cuthill-McKee ordering with Bi-Criteria Node Finder (2024), arXiv:2409.04171 [cs.DS].\n\n\n\nJ. K. Reid and J. A. Scott. Reducing the Total Bandwidth of a Sparse Unsymmetric Matrix. SIAM Journal on Matrix Analysis and Applications 28, 805–21 (2006).\n\n\n\nNetworkX Developers. Source code for networkx.utils.rcm. NetworkX v3.5 documentation (2025). Accessed: 2025-06-11.\n\n\n\n","category":"page"},{"location":"#MatrixBandwidth.jl","page":"Home","title":"MatrixBandwidth.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<figure style=\"text-align: left; margin-left: 0;\">\n  <img src=\"https://github.com/Luis-Varona/MatrixBandwidth.jl/raw/main/docs/src/assets/logo.png\" alt=\"MatrixBandwidth.jl logo by Rebekka Jonasson\">\n  <figcaption>\n    MatrixBandwidth.jl logo by <a href=\"https://github.com/RebekkaJonasson\">Rebekka Jonasson</a>\n  </figcaption>\n</figure>\n\n<table>\n  <tr>\n    <td>Metadata</td>\n    <td>\n      <img src=\"https://img.shields.io/badge/version-v0.2.1-pink.svg\" alt=\"Version\">\n      <a href=\"https://opensource.org/licenses/MIT\"><img src=\"https://img.shields.io/badge/License-MIT-A31F34.svg\" alt=\"License: MIT\"></a>\n      <a href=\"https://github.com/JuliaDiff/BlueStyle\"><img src=\"https://img.shields.io/badge/code%20style-blue-4495d1.svg\" alt=\"Code Style: Blue\"></a>\n    </td>\n  </tr>\n  <tr>\n    <td>Documentation</td>\n    <td>\n      <a href=\"https://luis-varona.github.io/MatrixBandwidth.jl/stable/\"><img src=\"https://img.shields.io/badge/docs-stable-darkgreen.svg\" alt=\"Documentation of latest stable version\"></a>\n      <a href=\"https://luis-varona.github.io/MatrixBandwidth.jl/dev/\"><img src=\"https://img.shields.io/badge/docs-dev-rebeccapurple.svg\" alt=\"Documentation of dev version\"></a>\n    </td>\n  </tr>\n  <tr>\n    <td>Continuous integration</td>\n    <td>\n      <a href=\"https://github.com/Luis-Varona/MatrixBandwidth.jl/actions?query=workflow%3ACI+branch%3Amain\"><img src=\"https://github.com/Luis-Varona/MatrixBandwidth.jl/actions/workflows/CI.yml/badge.svg\" alt=\"GitHub Workflow Status\"></a>\n    </td>\n  </tr>\n  <tr>\n    <td>Code coverage</td>\n    <td>\n      <a href=\"https://codecov.io/gh/Luis-Varona/MatrixBandwidth.jl\"><img src=\"https://codecov.io/gh/Luis-Varona/MatrixBandwidth.jl/branch/main/graph/badge.svg\" alt=\"Test coverage from codecov\"></a>\n    </td>\n    </tr>\n    <tr>\n      <td>Static analysis with</td>\n      <td>\n        <a href=\"https://github.com/JuliaTesting/Aqua.jl\"><img src=\"https://raw.githubusercontent.com/JuliaTesting/Aqua.jl/master/badge.svg\" alt=\"Aqua QA\"></a>\n        <a href=\"https://github.com/aviatesk/JET.jl\"><img src=\"https://img.shields.io/badge/%E2%9C%88%20tested%20with-JET.jl%EF%B8%8F-9cf.svg\" alt=\"JET static analysis\"></a>\n      </td>\n    </tr>\n</table>","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MatrixBandwidth.jl offers fast algorithms for matrix bandwidth minimization and recognition. The bandwidth of an n times n matrix A is the minimum non-negative integer k in 0 1 ldots n - 1 such that A_ij = 0 whenever i - j  k. Reordering the rows and columns of a matrix to reduce its bandwidth has many practical applications in engineering and scientific computing: it can improve performance when solving linear systems, approximating partial differential equations, optimizing circuit layout, and more. There are two variants of this problem: minimization, which involves finding a permutation matrix P such that the bandwidth of PAP^mathsfT is minimized, and recognition, which entails determining whether there exists a permutation matrix P such that the bandwidth of PAP^mathsfT is less than or equal to some fixed non-negative integer (an optimal permutation that fully minimizes the bandwidth of A is not required).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Many matrix bandwidth reduction algorithms exist in the literature, but implementations in the open-source ecosystem are scarce, with those that do exist primarily tackling older, less efficient algorithms. The Boost libraries in C++, the NetworkX library in Python, and the MATLAB standard library all only implement the reverse Cuthill–McKee algorithm from 1971. This gap in the ecosystem not only makes it difficult for theoretical researchers to benchmark and compare new proposed algorithms but also precludes the application of the most performant modern algorithms in real-life industry settings. MatrixBandwidth.jl aims to bridge this gap by presenting a unified interface for matrix bandwidth reduction algorithms in Julia, designed with extensibility to further methods in mind.","category":"page"},{"location":"#Algorithms","page":"Home","title":"Algorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following algorithms are currently supported:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Minimization\nExact\nDel Corso–Manzini\nDel Corso–Manzini with perimeter search\nCaprara–Salazar-González\nSaxe–Gurari–Sudborough\nBrute-force search\nHeuristic\nGibbs–Poole–Stockmeyer\nCuthill–McKee\nReverse Cuthill–McKee\nRecognition\nDel Corso–Manzini\nDel Corso–Manzini with perimeter search\nCaprara–Salazar-González\nSaxe–Gurari–Sudborough\nBrute-force search","category":"page"},{"location":"","page":"Home","title":"Home","text":"Recognition algorithms determine whether any row-and-column permutation of a matrix induces bandwidth less than or equal to some fixed integer. Exact minimization algorithms always guarantee optimal orderings to minimize bandwidth, while heuristic minimization algorithms produce near-optimal solutions more quickly. Metaheuristic minimization algorithms employ iterative search frameworks to find better solutions than heuristic methods (albeit more slowly); no such algorithms are already implemented, but several are currently under development:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Greedy randomized adaptive search procedure (GRASP)\nParticle swarm optimization with hill climbing (PSO-HC)\nSimulated annealing\nGenetic algorithm\nAnt colony optimization\nTabu search","category":"page"},{"location":"","page":"Home","title":"Home","text":"An index of all available algorithms by submodule (not including the unfinished metaheuristic algorithms) may also be accessed via the MatrixBandwidth.ALGORITHMS constant; simply run the following command in the Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> MatrixBandwidth.ALGORITHMS\nDict{Symbol, Union{Dict{Symbol}, Vector}} with 2 entries:\n[...]","category":"page"},{"location":"","page":"Home","title":"Home","text":"To extend the interface with a new matrix bandwidth minimization algorithm, define a new concrete subtype of AbstractSolver (or of one of its abstract subtypes like MetaheuristicSolver) then implement a corresponding Minimization._minimize_bandwidth_impl(::AbstractMatrix{Bool}, ::NewSolverType) method. Similarly, to implement a new bandwidth recognition algorithm, define a new concrete subtype of AbstractDecider then implement a corresponding Recognition._has_bandwidth_k_ordering_impl(::AbstractMatrix{Bool}, ::Integer, ::NewDeciderType) method. Do not attempt to directly implement new minimize_bandwidth or has_bandwidth_k_ordering methods, as these functions contain common preprocessing logic independent of the specific algorithm used.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The only prerequisite is a working Julia installation (v1.10 or later). First, enter Pkg mode by typing ] in the Julia REPL, then run the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add MatrixBandwidth","category":"page"},{"location":"#Basic-use","page":"Home","title":"Basic use","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MatrixBandwidth.jl offers unified interfaces for both bandwidth minimization and bandwidth recognition via the minimize_bandwidth and has_bandwidth_k_ordering functions, respectively—the algorithm itself is specified as an argument. For example, to minimize the bandwidth of a random matrix with the reverse Cuthill–McKee algorithm, you can run the following code:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Random, SparseArrays\n\njulia> Random.seed!(8675309);\n\njulia> A = sprand(60, 60, 0.01); A = A + A' # Ensure structural symmetry\n60×60 SparseMatrixCSC{Float64, Int64} with 93 stored entries:\n⎡⠀⠀⠀⠀⠠⠀⠀⠀⠀⠀⠀⠀⠠⠀⢀⠀⠀⠒⠀⠀⠀⠀⠀⠀⡀⠨⠀⠀⠀⠀⎤\n⎢⠀⠀⠀⠀⠅⠀⠀⠀⠀⠀⠐⠀⠠⡀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠂⠠⠀⠀⠀⠀⎥\n⎢⠀⠂⠁⠁⢀⠐⠀⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠁⠀⡀⠀⠀⠀⠀⠀⠀⠈⠁⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠐⠀⠀⠀⠀⠀⠀⠀⠀⠐⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠄⡀⠀⠀⎥\n⎢⠀⠂⠀⠢⠀⠀⠀⠀⠀⠀⠀⠄⠀⠀⠀⠀⢀⠀⠁⠀⠀⠀⠐⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠐⠀⠐⠀⠀⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠁⠀⠀⎥\n⎢⢠⠀⠀⠀⠀⢀⠀⠠⢀⠀⠀⠀⠀⠐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠂⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠊⠀⠀⢠⠀⠀⠀⠀⠀⠠⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠀⠀⠀⠀⠀⠀⠀⠀⣀⠀⠀⠁⠀⠀⠀⠄⠀⎥\n⎢⡀⡈⠈⡀⠀⠀⠆⠀⠀⠀⠁⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠡⠀⠀⠔⠀⠀⠀⠐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⎥\n⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠁⠀⠀⠀⠠⠄⠁⎦\n\njulia> res_minimize = minimize_bandwidth(A, Minimization.ReverseCuthillMcKee())\nResults of Bandwidth Minimization Algorithm\n * Algorithm: Reverse Cuthill–McKee\n * Approach: heuristic\n * Minimum Bandwidth: 9\n * Original Bandwidth: 51\n * Matrix Size: 60×60\n\njulia> A[res_minimize.ordering, res_minimize.ordering]\n60×60 SparseMatrixCSC{Float64, Int64} with 93 stored entries:\n⎡⠠⡢⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎤\n⎢⠀⠈⠠⡢⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠠⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠠⡢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠢⡀⠈⠀⠂⠀⢠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⠀⠀⠀⠀⠘⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⠀⠀⠀⠣⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠢⣀⡸⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠪⡢⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢊⠐⢠⡀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠲⢄⡱⢀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠪⢂⡄⠀⎥\n⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠪⡢⎦","category":"page"},{"location":"","page":"Home","title":"Home","text":"Similarly, to determine whether said matrix has bandwidth at most, say, 3 (not necessarily caring about the true minimum) via the Saxe–Gurari–Sudborough algorithm, you can run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> res_recognize = has_bandwidth_k_ordering(A, 3, Recognition.SaxeGurariSudborough())\nResults of Bandwidth Recognition Algorithm\n * Algorithm: Saxe–Gurari–Sudborough\n * Bandwidth Threshold k: 3\n * Has Bandwidth ≤ k Ordering: true\n * Original Bandwidth: 51\n * Matrix Size: 60×60\n\njulia> A[res_recognize.ordering, res_recognize.ordering]\n60×60 SparseMatrixCSC{Float64, Int64} with 93 stored entries:\n⎡⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎤\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠠⠂⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠘⠀⡠⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠐⠊⠀⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠀⠀⠠⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠢⡄⠉⡢⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠪⢀⠔⢂⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠰⡊⠈⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠊⠀⠠⡀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠢⣀⡸⢀⡀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠰⡀⠈⢠⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠒⣀⡸⢂⡀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠰⡀⠈⠠⡀⎥\n⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠢⠊⡠⎦","category":"page"},{"location":"","page":"Home","title":"Home","text":"(In this case, though, it turns out that 3 is the true minimum bandwidth of the matrix, as can be verified by running minimize_bandwidth with any exact algorithm.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If no algorithm is explicitly specified, minimize_bandwidth defaults to the Gibbs–Poole–Stockmeyer algorithm:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> res_minimize_default = minimize_bandwidth(A)\nResults of Bandwidth Minimization Algorithm\n * Algorithm: Gibbs–Poole–Stockmeyer\n * Approach: heuristic\n * Minimum Bandwidth: 5\n * Original Bandwidth: 51\n * Matrix Size: 60×60\n\njulia> A[res_minimize_default.ordering, res_minimize_default.ordering]\n60×60 SparseMatrixCSC{Float64, Int64} with 93 stored entries:\n⎡⠠⡢⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎤\n⎢⠀⠈⠠⡢⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠠⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠠⡢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⠄⠁⠀⢢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⣀⣀⠘⠄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠡⠄⡡⠢⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠢⣀⠘⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⠀⡠⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠪⢂⡄⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⢊⡰⢀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⢤⠓⣠⠀⎥\n⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠚⠠⡢⎦","category":"page"},{"location":"","page":"Home","title":"Home","text":"(We default to Gibbs–Poole–Stockmeyer because it is one of the most accurate heuristic algorithms—note how in this case, it produced a lower-bandwidth ordering than reverse Cuthill–McKee. Of course, if true optimality is required, an exact algorithm should be used instead.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"has_bandwidth_k_ordering similarly defaults to the Del Corso–Manzini algorithm:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> res_recognize_default = has_bandwidth_k_ordering(A, 6)\nResults of Bandwidth Recognition Algorithm\n * Algorithm: Del Corso–Manzini\n * Bandwidth Threshold k: 6\n * Has Bandwidth ≤ k Ordering: true\n * Original Bandwidth: 51\n * Matrix Size: 60×60\n\njulia> A[res_recognize_default.ordering, res_recognize_default.ordering]\n60×60 SparseMatrixCSC{Float64, Int64} with 93 stored entries:\n⎡⠀⠀⠄⠑⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎤\n⎢⢄⠁⠀⠀⠀⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⢄⠀⠀⠀⠀⠠⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠑⠀⡀⠀⠀⠌⠑⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠈⢆⠁⠀⠀⠀⠲⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠘⢠⡀⠐⠀⠀⡁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠄⠠⠀⠀⠐⢂⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠰⢀⡀⠈⠀⡐⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢀⠠⠀⠀⠀⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠀⢤⠀⠀⠀⠔⠄⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢀⠄⠀⠀⠠⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠂⠀⠀⠀⠁⢀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⠀⠠⠂⢀⠑⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⢄⠐⠀⠀⠀⠀⎥\n⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎦","category":"page"},{"location":"","page":"Home","title":"Home","text":"Complementing our various bandwidth minimization and recognition algorithms, MatrixBandwidth.jl exports several additional core functions, including (but not limited to) bandwidth and profile to compute the original bandwidth and profile of a matrix:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Random, SparseArrays\n\njulia> Random.seed!(1234);\n\njulia> A = sprand(50, 50, 0.02)\n50×50 SparseMatrixCSC{Float64, Int64} with 49 stored entries:\n⎡⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠀⠀⠀⠀⎤\n⎢⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠂⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⡀⠀⡀⠀⠀⠀⠄⠀⠀⠀⠄⠀⎥\n⎢⠀⠐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠄⠂⠀⠀⠐⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠈⠀⠀⠀⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⢀⠀⠀⠀⠂⠀⠀⠀⠁⎥\n⎢⡀⡀⢀⠄⠀⠁⠄⢀⠀⠀⠀⠀⠀⢀⠀⠀⠠⠀⠀⠀⠀⣀⠀⠀⠀⎥\n⎢⠀⢀⠀⠀⠀⠊⠀⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠄⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠀⠀⠀⠀⠀⠀⎥\n⎢⠈⠀⢀⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠂⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠂⠀⠀⠀⠀⠀⠀⠀⠀⠨⠐⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⎥\n⎣⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎦\n\njulia> bandwidth(A) # Bandwidth prior to any reordering of rows and columns\n38\n\njulia> profile(A) # Profile prior to any reordering of rows and columns\n703","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Closely related to bandwidth, the column profile of a matrix is the sum of the distances from each diagonal entry to the farthest nonzero entry in that column, whereas the row profile is the sum of the distances from each diagonal entry to the farthest nonzero entry in that row. profile(A) computes the column profile of A by default, but it can also be used to compute the row profile.)","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The full documentation is available at GitHub Pages. Documentation for methods and types is also available via the Julia REPL—for instance, to learn more about the minimize_bandwidth function, enter help mode by typing ?, then run the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"help?> minimize_bandwidth\nsearch: minimize_bandwidth bandwidth MatrixBandwidth\n\n  minimize_bandwidth(A, solver=GibbsPooleStockmeyer()) -> MinimizationResult\n\n  Minimize the bandwidth of A using the algorithm defined by solver.\n\n  The bandwidth of an n×n matrix A is the minimum non-negative integer k ∈\n  \\{0, 1, …, n - 1\\} such that A[i, j] = 0 whenever |i - j| > k.\n\n  This function computes a (near-)optimal ordering π of the rows and columns\n  of A so that the bandwidth of PAPᵀ is minimized, where P is the permutation\n  matrix corresponding to π. This is known to be an NP-complete problem;\n  however, several heuristic algorithms such as Gibbs–Poole–Stockmeyer run in\n  polynomial time while still still producing near-optimal orderings in\n  practice. Exact methods like Caprara–Salazar-González are also available,\n  but they are at least exponential in time complexity and thus only feasible\n  for relatively small matrices.\n\n  Arguments\n  ≡≡≡≡≡≡≡≡≡\n  [...]","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"I encourage you to cite this work if you have found any of the algorithms herein useful for your research. Starring the MatrixBandwidth.jl repository on GitHub is also appreciated.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The latest citation information may be found in the CITATION.bib file within the repository.","category":"page"},{"location":"#Project-status","page":"Home","title":"Project status","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The latest stable release of MatrixBandwidth.jl is v0.2.1. Although several metaheuristic algorithms are still under development, the rest of the package is fully functional and covered by unit tests.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently, MatrixBandwidth.jl's core functions generically accept any input of the type AbstractMatrix{<:Number}, not behaving any differently when given sparsely stored matrices (e.g., from the SparseArrays.jl standard library package). Capabilities for directly handling graph inputs (aiming to reduce the matrix bandwidth of a graph's adjacency) are also not available. Given that bandwidth reduction is often applied to sparse matrices and graphs, these limitations will be addressed in a future release of the package.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"#MatrixBandwidth","page":"Home","title":"MatrixBandwidth","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [MatrixBandwidth]","category":"page"},{"location":"#MatrixBandwidth.Minimization","page":"Home","title":"MatrixBandwidth.Minimization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [MatrixBandwidth.Minimization]","category":"page"},{"location":"#MatrixBandwidth.Minimization.Exact","page":"Home","title":"MatrixBandwidth.Minimization.Exact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [MatrixBandwidth.Minimization.Exact]","category":"page"},{"location":"#MatrixBandwidth.Minimization.Heuristic","page":"Home","title":"MatrixBandwidth.Minimization.Heuristic","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [MatrixBandwidth.Minimization.Heuristic]","category":"page"},{"location":"#MatrixBandwidth.Minimization.Metaheuristic","page":"Home","title":"MatrixBandwidth.Minimization.Metaheuristic","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [MatrixBandwidth.Minimization.Metaheuristic]","category":"page"},{"location":"#MatrixBandwidth.Recognition","page":"Home","title":"MatrixBandwidth.Recognition","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [MatrixBandwidth.Recognition]","category":"page"}]
}
